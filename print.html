<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Boost C++ 库</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="frontpage.html"><strong aria-hidden="true">1.</strong> 导言</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">2.</strong> 第 1 章 简介</a></li><li class="chapter-item expanded "><a href="smartpointers.html"><strong aria-hidden="true">3.</strong> 第 2 章 智能指针</a></li><li class="chapter-item expanded "><a href="functionobjects.html"><strong aria-hidden="true">4.</strong> 第 3 章 函数对象</a></li><li class="chapter-item expanded "><a href="eventhandling.html"><strong aria-hidden="true">5.</strong> 第 4 章 事件处理</a></li><li class="chapter-item expanded "><a href="stringhandling.html"><strong aria-hidden="true">6.</strong> 第 5 章 字符串处理</a></li><li class="chapter-item expanded "><a href="multithreading.html"><strong aria-hidden="true">7.</strong> 第 6 章 多线程</a></li><li class="chapter-item expanded "><a href="asio.html"><strong aria-hidden="true">8.</strong> 第 7 章 异步输入输出</a></li><li class="chapter-item expanded "><a href="interprocesscommunication.html"><strong aria-hidden="true">9.</strong> 第 8 章 进程间通讯</a></li><li class="chapter-item expanded "><a href="filesystem.html"><strong aria-hidden="true">10.</strong> 第 9 章 文件系统</a></li><li class="chapter-item expanded "><a href="datetime.html"><strong aria-hidden="true">11.</strong> 第 10 章 日期与时间</a></li><li class="chapter-item expanded "><a href="serialization.html"><strong aria-hidden="true">12.</strong> 第 11 章 序列化</a></li><li class="chapter-item expanded "><a href="parser.html"><strong aria-hidden="true">13.</strong> 第 12 章 词法分析器</a></li><li class="chapter-item expanded "><a href="containers.html"><strong aria-hidden="true">14.</strong> 第 13 章 容器</a></li><li class="chapter-item expanded "><a href="datastructures.html"><strong aria-hidden="true">15.</strong> 第 14 章 数据结构</a></li><li class="chapter-item expanded "><a href="errorhandling.html"><strong aria-hidden="true">16.</strong> 第 15 章 错误处理</a></li><li class="chapter-item expanded "><a href="castoperators.html"><strong aria-hidden="true">17.</strong> 第 16 章 类型转换操作符</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Boost C++ 库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="boost-c-库"><a class="header" href="#boost-c-库">Boost C++ 库</a></h1>
<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/soncoya/storage@assets/imgs/202111171117019.png" alt="img" /> 
<em>The Boost C++ Libraries</em> has been updated. The second edition was published in September 2014 and introduces 72 Boost libraries with more than 430 examples. It is available at <a href="http://www.amazon.com/gp/product/1937434362/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1937434362&amp;linkCode=as2&amp;tag=theboostcppli-20&amp;linkId=ZD2OKWS6OJX5F3S3">Amazon</a>, <a href="http://www.barnesandnoble.com/w/the-boost-c-libraries-boris-schaling/1120389155?ean=9781937434366">Barnes and Noble</a>, <a href="http://www.amazon.com/gp/product/B00OX0KJOK/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B00OX0KJOK&amp;linkCode=as2&amp;tag=theboostcppli-20&amp;linkId=B5LGTSOTEZ6C7EVL">for Kindle</a>, as an <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=F7WCSZLHDU9GN">Epub</a> and as a <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=HMMF8LP558LHL">PDF</a> file. The second edition is based on C++11 and the Boost libraries 1.55.0 and 1.56.0 with the latter version having been released in August 2014.  Find the second edition online at http://theboostcpplibraries.com/ </p>
</blockquote>
<blockquote>
<p>本站点内容由 <a href="http://zh.highscore.de/cpp/boost/">Highscore - The Boost C++ Libraries</a> 提供</p>
</blockquote>
<p><a href="http://creativecommons.org/licenses/by-nc-nd/3.0/de/deed.zh"><img src="https://cdn.jsdelivr.net/gh/soncoya/storage@assets/imgs/202111171123826.png" alt="img" /></a> 该书采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/de/deed.zh">Creative Commons License</a> 授权</p>
<p>本书的中文版由           <a href="mailto:alai04@gmail.com">Albert Lai</a>, <a href="mailto:jerry2mouse@gmail.com">Jerry Guo</a>, <a href="mailto:zengkun100@gmail.com">Kun Zeng</a>, <a href="mailto:chenclf@vrlab.cau.ac.kr">Liangfu Chen</a> (<a href="http://vrlab.cau.ac.kr/%7Echenclf/">主页</a>), <a href="mailto:watsoncui@gmail.com">Cui Wei</a> 和 <a href="mailto:shiruide@gmail.com">Rui Shi</a>          翻译。</p>
<hr />
<h2 id="内容"><a class="header" href="#内容">内容</a></h2>
<h3 id="你将学到些什么"><a class="header" href="#你将学到些什么">你将学到些什么</a></h3>
<p>本书是对 Boost C++ 库的介绍，Boost 库通过加入一些在实践中非常有用的函数对 C++ 标准进行了补充。 由于 Boost C++ 库是基于 C++ 标准的，所以它们是使用最先进的 C++ 来实现的。 它们是平台独立的，并由于有一个大型的开发人员社区，它可以被包括 Windows 和 Linux 在内的许多操作系统所支持。</p>
<p>Boost C++ 库可以提升你作为一个 C++ 开发人员的生产力。 例如，你可以从智能指针中受益，帮助你写出更可靠的代码，或者使用某个库来开发平台独立的网络应用。 因为多数 Boost C++ 库正被收录进下一个版本的 C++ 标准，所以你可以从今天就开始作好准备。</p>
<hr />
<h2 id="要求"><a class="header" href="#要求">要求</a></h2>
<h3 id="你应该懂得些什么"><a class="header" href="#你应该懂得些什么">你应该懂得些什么</a></h3>
<p>因为 Boost C++ 库是基于且扩展了 C++ 标准，所以你应该懂得 C++ 标准。 你应该了解且能够使用容器、迭代器及算法，最好有听说过以下概念：RAII，函数对象，或是谓词。 你越是了解 C++ 标准，就越能从 Boost C++ 库中受益。</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-1-章-简介"><a class="header" href="#第-1-章-简介">第 1 章 简介</a></h1>
<h2 id="11-c-与-boost"><a class="header" href="#11-c-与-boost">1.1. C++ 与 Boost</a></h2>
<p><a href="http://www.boost.org/doc/libs/">Boost C++ 库</a>    是一组基于C++标准的现代库。 其源码按 <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software     License</a> 来发布，允许任何人自由地使用、修改和分发。 这些库是平台独立的，且支持大多数知名和不那么知名的编译器。</p>
<p>Boost 社区负责开发和发布 Boost C++ 库。 社区由一个很大的C++开发人员群组组成，这些开发人员来自于全球，他们通过网站    <a href="http://www.boost.org/">www.boost.org</a>    以及几个邮件列表相互协调。 社区的使命是开发和收集高质量的库，作为C++标准的补充。    那些被证实有价值且对于C++应用开发非常重要的库，将会有很大机会在某天被纳入C++标准中。</p>
<p>Boost 社区在1998年左右出现，当时刚刚发布了C++标准的第一个版本。    从那时起，社区就不断地扩大，现在已成为C++标准化工作中的一个重要角色。 虽然 Boost    社区与标准化委员会之间没有直接的关系，但有部分开发者同时活跃于两方。    下一个版本的C++标准很大可能在2011年通过，其中将扩展一批库，这些库均起源于 Boost 社区。</p>
<p>要增强C++项目的生产力，除了C++标准以外，Boost C++ 库是一个不错的选择。    由于当前版本的C++标准在2003年修订之后，C++又有了新的发展，所以 Boost C++ 库提供了许多新的特性。 由于有了 Boost C++    库，我们无需等待下一个版本的C++标准，就可以立即享用C++演化中取得的最新进展。</p>
<p>Boost C++ 库具有良好的声誉，这基于它们的使用已被证实是非常有价值的。 在面试中询问关于 Boost C++    库的知识是不常见的，因为知道这些库的开发人员通常也清楚C++的最新创新，并且能够编写和理解现代的C++代码。</p>
<h2 id="12-开发过程"><a class="header" href="#12-开发过程">1.2. 开发过程</a></h2>
<p>正是因为大量的独立开发者和组织的支持和参与，才使用 Boost C++ 库的开发成为可能。 由于 Boost    只接受满足以下条件的库：解决了真实存在的问题、表现出令人信服的设计、使用现代C++来开发且以可理解的方式提供文档，所以每一个 Boost C++    库的背后都有大量的工作。</p>
<p>C++ 开发者都可以加入到 Boost 社区中，并提出自己的新库。 但是，要将一个想法变成一个 Boost C++    库，需要投入大量的时间和努力。 其中最重要的是在 Boost 邮件列表中与其他开发者及潜在用户讨论需求和可能的解决方案。</p>
<p>除了这些好象不知从何处冒出来的新库以外，也可以提名一些已有的 C++ 库进入 Boost。 不过，由于对这些库的要求是与专门为    Boost 开发的库一样的，所以可能需要对它们进行大量的修改。</p>
<p>一个库是否被接纳入 Boost，取决于评审过程的结果。 库的开发者可以申请评审，这通常需要10天的时间。    在这段时间内，其他开发者被邀请对这个库进行评分。 基于正面和负面评价的数量，评审经理将决定该库是否被接纳进入 Boost。    由于有些开发者是在评审阶段才首次公开库的代码，所以在评审期间被要求对库进行修改并不罕见。</p>
<p>如果一个库是因为技术原因被拒绝，那么它还有可能在修改之后对更新后的版本申请新的评审。    但是，如果一个库是因为不能解决实际问题或未能提供令人信服的解决方案而被拒绝，那么再一次评审也很可能会被拒绝。</p>
<p>因为可能随时接纳新的库，所以 Boost C++ 库会每三个月发布一次新版本。本书所涉及的库均基于2010年2月发布的 1.42.0    版本。</p>
<p>请注意，另外还有一些库已被接纳，但尚未成为 Boost C++ 库发布版的一部分。在被包含进发布版之前，它们必须手工安装。</p>
<h2 id="13-安装"><a class="header" href="#13-安装">1.3. 安装</a></h2>
<p>Boost C++ 库均带有源代码。其中大多数库只包含头文件，可以直接使用，但也有一些库需要编译。 为了尽可能容易安装，可以使用    Boost Jam 进行自动安装。    无需逐个库进行检查和编译，Boost Jam    自动安装整个库集。 它支持许多操作系统和编译器，并且知道如何基于适当的配置文件来编译单个库。</p>
<p>为了在 Boost Jam    的帮助下自动安装，要使用一个名为 <strong>bjam</strong> 的应用程序，它也带有源代码。 对于某些操作系统，包括    Windows 和 Linux，也有预编译好的 <strong>bjam</strong> 二进制文件。</p>
<p>为了编译 <strong>bjam</strong> 本身，要执行一个名为 <strong>build</strong>    的简单脚本，它也为不同的操作系统提供了源代码。 对于 Windows，它是批处理文件 <code>build.bat</code>。    对于 Linux，文件名为 <code>build.sh</code>。</p>
<p>如果执行 <strong>build</strong> 时不带任何命令行选项，则该脚本尝试找到一个合适的编译器来生成    <strong>bjam</strong>。 通过使用命令行开关，称为 toolset，可以选择特定的编译器。 对于    Windows，<strong>build</strong> 支持 toolsets <code>vc7</code>,    <code>vc8</code> 和 <code>vc9</code>，可以选择不同版本的 Microsoft C++    编译器。 要从 Visual Studio 2008 的C++编译器编译 <strong>bjam</strong>，需要指定命令    <strong>build vc9</strong>。对于 Linux，支持 toolsets <code>gcc</code> 和    <code>intel-linux</code>，分别选定 GCC 和 Intel 的C++编译器。</p>
<p>应用程序 <strong>bjam</strong> 必须复制到本地的 Boost 目录 -    不论它是编译出来的还是下载的预编译二进制文件。 然后就可以不带任何命令行选项地执行 <strong>bjam</strong>，编译并安装    Boost C++ 库。 由于缺省选项 - 在这种情况下所使用的 - 并不一定是最好的选择，所以以下列出最重要的几个选项供参考：</p>
<ul>
<li>声明 <code>stage</code> 或 <code>install</code> 可以指定        Boost C++ 库是安装在一个名为 <code>stage</code>        的子目录下，还是在系统范围内安装。 &quot;系统范围&quot;的意义取决于操作系统。 在 Windows 中，目标目录是 <code>C:\Boost</code>；而在 Linux 中则是 <code>/usr/local</code>。 目标目录也可以用        <code>--prefix</code> 选项明确指出。</li>
<li>如果不带任何命令行选项执行 <strong>bjam</strong>，则它会自己搜索一个合适的C++编译器。 可以通过        <code>--toolset</code> 选项来指定一个特定的编译器。 要在 Windows 中指定 Visual Studio        2008 的 Microsoft C++ 编译器，<strong>bjam</strong> 执行时要带上        <code>--toolset=msvc-9.0</code> 选项。 要在 Linux 中指定 GCC 编译器，则要给出        <code>--toolset=gcc</code> 选项。</li>
<li>命令行选项 <code>--build-type</code> 决定了创建何种方式的库。 缺省情况下，该选项设为        <code>minimal</code>，即只创建发布版。 对于那些想用 Visual Studio 或 GCC        构建他们项目的调试版的开发者来说，可能是一个问题。 因为这些编译器会自动尝试链接调试版的 Boost C++ 库，这样就会给出一个错误信息。        在这种情况下，应将 <code>--build-type</code> 选项设为        <code>complete</code>，以同时生成 Boost C++        库的调试版和发布版，当然，所需时间也会更长一些。</li>
</ul>
<p>要用 Visual Studio 2008 的C++编译器同时生成 Boost C++ 库的调试版和发布版，并将它们安装在目录    <code>D:\Boost</code> 中，应执行的命令是 <strong>bjam    --toolset=msvc-9.0 --build-type=complete --prefix=D:\Boost    install</strong>. 要在 Linux 中使用缺省目录创建它们，则要执行的命令是 <strong>bjam    --toolset=gcc --build-type=complete install</strong>.</p>
<p>其它多个命令行选项可用于指定如何编译 Boost C++ 库的一些细节设定。 我通常在 Windows    下使用以下命令：<strong>bjam --toolset=msvc-9.0 debug release link=static    runtime-link=shared install</strong>. <code>debug</code> 和    <code>release</code> 使得调试版和发布版均被生成。 <code>link=static</code>    则只创建静态库。 <code>runtime-link=shared</code> 则是指定 C++ 运行时库是动态链接的，这是在    Visual Studio 2008 中对C++项目的缺省设置。</p>
<h2 id="14-概述"><a class="header" href="#14-概述">1.4. 概述</a></h2>
<p>Boost C++ 库的 1.42.0 版本包含了超过90个库，本书只详细讨论了以下各库：</p>
<table><thead><tr><th>Boost C++ 库</th><th>C++ 标准</th><th>简要说明</th></tr></thead><tbody>
<tr><td><a href="./datastructures.html#datastructures_any">Boost.Any</a></td><td></td><td>Boost.Any 提供了一个名为 <code>boost::any</code>        的数据类型，可以存放任意的类型。 例如，一个类型为 <code>boost::any</code> 的变量可以先存放一个        <code>int</code> 类型的值，然后替换为一个 <code>std::string</code> 类型的字符串。</td></tr>
<tr><td><a href="./containers.html#containers_array">Boost.Array</a></td><td>TR1</td><td>Boost.Array 可以把 C++ 数组视同 C++ 标准的容器。</td></tr>
<tr><td><a href="./asio.html">Boost.Asio</a></td><td>TR2</td><td>Boost.Asio 可用于开发异步处理数据的应用，如网络应用。</td></tr>
<tr><td><a href="./containers.html#containers_bimap">Boost.Bimap</a></td><td></td><td>Boost.Bimap 提供了一个名为 <code>boost::bimap</code> 的类，它类似于        <code>std::map</code>. 主要的差别在于        <code>boost::bimap</code> 可以同时从键和值进行搜索。</td></tr>
<tr><td><a href="./functionobjects.html#functionobjects_bind">Boost.Bind</a></td><td>TR1</td><td>Boost.Bind 是一种适配器，可以将函数作为模板参数，即使该函数的签名与模板参数不兼容。</td></tr>
<tr><td><a href="./castoperators.html#castoperators_conversion">Boost.Conversion</a></td><td></td><td>Boost.Conversion 提供了三个转型操作符，分别执行向下转型、交叉转型，以及不同数字类型间的值转换。</td></tr>
<tr><td><a href="./datetime.html">Boost.DateTime</a></td><td></td><td>Boost.DateTime 可用于以灵活的格式处理、读入和写出日期及时间值。</td></tr>
<tr><td><a href="./errorhandling.html#errorhandling_exception">Boost.Exception</a></td><td></td><td>Boost.Exception 可以在抛出的异常中加入额外的数据，以便在 <code>catch</code>        处理中提供更多的信息。 这有助于更容易地调试，以及对异常情况更好地作出反应。</td></tr>
<tr><td><a href="./filesystem.html">Boost.Filesystem</a></td><td>TR2</td><td>Boost.Filesystem 提供了一个类来处理路径信息，还包含了几个访问文件和目录的函数。</td></tr>
<tr><td><a href="./stringhandling.html#stringhandling_format">Boost.Format</a></td><td></td><td>Boost.Format 以一个类型安全且可扩展的 <code>boost::format</code>        类替代了 <code>std::printf()</code> 函数。</td></tr>
<tr><td><a href="./functionobjects.html#functionobjects_function">Boost.Function</a></td><td>TR1</td><td>Boost.Function 简化了函数指针的定义。</td></tr>
<tr><td><a href="./interprocesscommunication.html">Boost.Interprocess</a></td><td></td><td>Boost.Interprocess 允许多个应用通过共享内存以快速、高效的方式进行通信。</td></tr>
<tr><td><a href="./functionobjects.html#functionobjects_lambda">Boost.Lambda</a></td><td></td><td>Boost.Lambda 可以定义匿名的函数。 代码被内联地声明和执行，避免了单独的函数调用。</td></tr>
<tr><td><a href="./containers.html#containers_multiindex">Boost.Multiindex</a></td><td></td><td>Boost.Multiindex 定义了一些新的容器，它们可以同时支持多个接口，如        <code>std::vector</code> 和 <code>std::map</code>        的接口。</td></tr>
<tr><td><a href="./castoperators.html#castoperators_numeric_conversion">Boost.NumericConversion</a></td><td></td><td>Boost.NumericConversion        提供了一个转型操作符，可以安全地在不同的数字类型间进行值转换，不会生成上溢出或下溢出的条件。</td></tr>
<tr><td><a href="./smartpointers.html#smartpointers_pointer_container">Boost.PointerContainer</a></td><td></td><td>Boost.PointerContainer 提供了专门为动态分配对象进行优化的容器。</td></tr>
<tr><td><a href="./functionobjects.html#functionobjects_ref">Boost.Ref</a></td><td>TR1</td><td>Boost.Ref 的适配器可以将不可复制对象的引用传给需要复制的函数。</td></tr>
<tr><td><a href="./stringhandling.html#stringhandling_regex">Boost.Regex</a></td><td>TR1</td><td>Boost.Regex 提供了通过正则表达式进行文本搜索的函数。</td></tr>
<tr><td><a href="./serialization.html">Boost.Serialization</a></td><td></td><td>通过 Boost.Serialization，对象可以被序列化，如保存在文件中，并在以后重新导入。</td></tr>
<tr><td><a href="./eventhandling.html">Boost.Signals</a></td><td></td><td>Boost.Signal 是一个事件处理的框架，基于所谓的 signal/slot 概念。        函数与信号相关联并在信号被触发时自动被调用。</td></tr>
<tr><td><a href="./smartpointers.html">Boost.SmartPoiners</a></td><td>TR1</td><td>Boost.SmartPoiners 提供了多个智能指针，简化了动态分配对象的管理。</td></tr>
<tr><td><a href="./parser.html">Boost.Spirit</a></td><td></td><td>Boost.Spirit 可以用类似于 EBNF (扩展巴科斯范式)的语法生成词法分析器。</td></tr>
<tr><td><a href="./stringhandling.html#stringhandling_stringalgorithms">Boost.StringAlgorithms</a></td><td></td><td>Boost.StringAlgorithms 提供了多个独立的函数，以方便处理字符串。</td></tr>
<tr><td><a href="./errorhandling.html#errorhandling_system">Boost.System</a></td><td>TR2</td><td>Boost.System 提供了一个处理系统相关或应用相关错误代码的框架。</td></tr>
<tr><td><a href="./multithreading.html">Boost.Thread</a></td><td>C++0x</td><td>Boost.Thread 可用于开发多线程应用。</td></tr>
<tr><td><a href="./stringhandling.html#stringhandling_tokenizer">Boost.Tokenizer</a></td><td></td><td>Boost.Tokenizer 可以对一个字符串的各个组件进行迭代。</td></tr>
<tr><td><a href="./datastructures.html#datastructures_tuple">Boost.Tuple</a></td><td>TR1</td><td>Boost.Tuple 提供了泛化版的        <code>std::pair</code>，可以将任意数量的数据组在一起。</td></tr>
<tr><td><a href="./containers.html#containers_unordered">Boost.Unordered</a></td><td>TR1</td><td>Boost.Unordered 扩展了 C++        标准的容器，增加了<code>boost::unordered_set</code> 和        <code>boost::unordered_map</code>.</td></tr>
<tr><td><a href="./datastructures.html#datastructures_variant">Boost.Variant</a></td><td></td><td>Boost.Variant 可以定义多个数据类型，类似于 <code>union</code>, 将多个数据类型组在一起。        Boost.Variant 比 <code>union</code> 优胜的地方在于它可以使用类。</td></tr>
</tbody></table>
<p>Technical Report 1 是在2003年发布的，有关 C++0x 标准和 Technical Report 2    的一些细节才能反映当前的状态。由于无论是下一个版本的 C++ 标准，还是 Technical Report 2    都尚未被批准，所以在往后的时间里，它们仍然可能会有改变。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-2-章-智能指针"><a class="header" href="#第-2-章-智能指针">第 2 章 智能指针</a></h1>
<h2 id="21-概述"><a class="header" href="#21-概述">2.1. 概述</a></h2>
<p>1998年修订的第一版C++标准只提供了一种智能指针： <code>std::auto_ptr</code> 。    它基本上就像是个普通的指针： 通过地址来访问一个动态分配的对象。 <code>std::auto_ptr</code>    之所以被看作是智能指针，是因为它会在析构的时候调用 <code>delete</code> 操作符来自动释放所包含的对象。    当然这要求在初始化的时候，传给它一个由 <code>new</code> 操作符返回的对象的地址。 既然    <code>std::auto_ptr</code> 的析构函数会调用 <code>delete</code>    操作符，它所包含的对象的内存会确保释放掉。 这是智能指针的一个优点。</p>
<p>当和异常联系起来时这就更加重要了：没有 <code>std::auto_ptr</code>    这样的智能指针，每一个动态分配内存的函数都需要捕捉所有可能的异常，以确保在异常传递给函数的调用者之前将内存释放掉。 Boost C++ 库    <a href="http://www.boost.org/libs/smart_ptr/">Smart     Pointers</a> 提供了许多可以用在各种场合的智能指针。</p>
<hr />
<h2 id="22-raii"><a class="header" href="#22-raii">2.2. RAII</a></h2>
<p>智能指针的原理基于一个常见的习语叫做 RAII ：资源申请即初始化。 智能指针只是这个习语的其中一例——当然是相当重要的一例。    智能指针确保在任何情况下，动态分配的内存都能得到正确释放，从而将开发人员从这项任务中解放了出来。    这包括程序因为异常而中断，原本用于释放内存的代码被跳过的场景。 用一个动态分配的对象的地址来初始化智能指针，在析构的时候释放内存，就确保了这一点。    因为析构函数总是会被执行的，这样所包含的内存也将总是会被释放。</p>
<p>无论何时，一定得有第二条指令来释放之前另一条指令所分配的资源时，RAII 都是适用的。 许多的 C++    应用程序都需要动态管理内存，因而智能指针是一种很重要的 RAII 类型。 不过 RAII 本身是适用于许多其它场景的。</p>
<pre><code class="language-c++">#include &lt;windows.h&gt; 

class windows_handle 
{ 
  public: 
    windows_handle(HANDLE h) 
      : handle_(h) 
    { 
    } 

    ~windows_handle() 
    { 
      CloseHandle(handle_); 
    } 

    HANDLE handle() const 
    { 
      return handle_; 
    } 

  private: 
    HANDLE handle_; 
}; 

int main() 
{ 
  windows_handle h(OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId())); 
  SetPriorityClass(h.handle(), HIGH_PRIORITY_CLASS); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子中定义了一个名为 <code>windows_handle</code> 的类，它的析构函数调用了    <code>CloseHandle()</code> 函数。 这是一个 Windows API 函数，因而这个程序只能在 Windows    上运行。 在 Windows 上，许多资源在使用之前都要求打开。 这暗示着一旦资源不再使用之后就应该关闭。    <code>windows_handle</code> 类的机制能确保这一点。</p>
<p><code>windows_handle</code> 类的实例以一个句柄来初始化。 Windows    使用句柄来唯一的标识资源。 比如说，<code>OpenProcess()</code> 函数返回一个    <code>HANDLE</code> 类型的句柄，通过该句柄可以访问当前系统中的进程。    在示例代码中，访问的是进程自己——换句话说就是应用程序本身。</p>
<p>我们通过这个返回的句柄提升了进程的优先级，这样它就能从调度器那里获得更多的 CPU 时间。 这里只是用于演示目的，并没什么实际的效应。    重要的一点是：通过 <code>OpenProcess()</code> 打开的资源不需要显示的调用    <code>CloseHandle()</code> 来关闭。 当然，应用程序终止时资源也会随之关闭。 然而，在更加复杂的应用程序里，    <code>windows_handle</code> 类确保当一个资源不再使用时就能正确的关闭。    某个资源一旦离开了它的作用域——上例中 h 的作用域在 <code>main()</code>    函数的末尾——它的析构函数会被自动的调用，相应的资源也就释放掉了。</p>
<hr />
<h2 id="23-作用域指针"><a class="header" href="#23-作用域指针">2.3. 作用域指针</a></h2>
<p>一个作用域指针独占一个动态分配的对象。 对应的类名为    <code>boost::scoped_ptr</code>，它的定义在 <code>boost/scoped_ptr.hpp</code> 中。 不像    <code>std::auto_ptr</code>，一个作用域指针不能传递它所包含的对象的所有权到另一个作用域指针。    一旦用一个地址来初始化，这个动态分配的对象将在析构阶段释放。</p>
<p>因为一个作用域指针只是简单保存和独占一个内存地址，所以 <code>boost::scoped_ptr</code>    的实现就要比 <code>std::auto_ptr</code> 简单。 在不需要所有权传递的时候应该优先使用    <code>boost::scoped_ptr</code> 。 在这些情况下，比起    <code>std::auto_ptr</code> 它是一个更好的选择，因为可以避免不经意间的所有权传递。</p>
<pre><code class="language-c++">#include &lt;boost/scoped_ptr.hpp&gt; 

int main() 
{ 
  boost::scoped_ptr&lt;int&gt; i(new int); 
  *i = 1; 
  *i.get() = 2; 
  i.reset(new int); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>一经初始化，智能指针 <code>boost::scoped_ptr</code>    所包含的对象，可以通过类似于普通指针的接口来访问。 这是因为重载了相关的操作符    <code>operator*()</code>，<code>operator-&gt;()</code>    和 <code>operator bool()</code> 。 此外，还有    <code>get()</code> 和 <code>reset()</code> 方法。    前者返回所含对象的地址，后者用一个新的对象来重新初始化智能指针。 在这种情况下，新创建的对象赋值之前会先自动释放所包含的对象。</p>
<p><code>boost::scoped_ptr</code> 的析构函数中使用    <code>delete</code> 操作符来释放所包含的对象。 这对    <code>boost::scoped_ptr</code> 所包含的类型加上了一条重要的限制。    <code>boost::scoped_ptr</code> 不能用动态分配的数组来做初始化，因为这需要调用    <code>delete[]</code> 来释放。 在这种情况下，可以使用下面将要介绍的    <code>boost:scoped_array</code> 类。</p>
<hr />
<h2 id="24-作用域数组"><a class="header" href="#24-作用域数组">2.4. 作用域数组</a></h2>
<p>作用域数组的使用方式与作用域指针相似。 关键不同在于，作用域数组的析构函数使用 <code>delete[]</code>    操作符来释放所包含的对象。 因为该操作符只能用于数组对象，所以作用域数组必须通过动态分配的数组来初始化。</p>
<p>对应的作用域数组类名为 <code>boost::scoped_array</code>，它的定义在    <code>boost/scoped_array.hpp</code> 里。</p>
<pre><code class="language-c++">#include &lt;boost/scoped_array.hpp&gt; 

int main() 
{ 
  boost::scoped_array&lt;int&gt; i(new int[2]); 
  *i.get() = 1; 
  i[1] = 2; 
  i.reset(new int[3]); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.4.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost:scoped_array</code> 类重载了操作符    <code>operator[]()</code> 和 <code>operator    bool()</code>。 可以通过 <code>operator[]()</code>    操作符访问数组中特定的元素，于是 <code>boost::scoped_array</code>    类型对象的行为就酷似它所含的数组。</p>
<p>正如 <code>boost::scoped_ptr</code> 那样,    <code>boost:scoped_array</code> 也提供了    <code>get()</code> 和 <code>reset()</code>    方法，用来返回和重新初始化所含对象的地址。</p>
<hr />
<h2 id="25-共享指针"><a class="header" href="#25-共享指针">2.5. 共享指针</a></h2>
<p>这是使用率最高的智能指针，但是 C++ 标准的第一版中缺少这种指针。 它已经作为技术报告1（TR 1）的一部分被添加到标准里了。    如果开发环境支持的话，可以使用 <code>memory</code> 中定义的    <code>std::shared_ptr</code>。 在 Boost C++ 库里，这个智能指针命名为    <code>boost::shared_ptr</code>，定义在 <code>boost/shared_ptr.hpp</code> 里。</p>
<p>智能指针 <code>boost::shared_ptr</code> 基本上类似于    <code>boost::scoped_ptr</code>。 关键不同之处在于    <code>boost::shared_ptr</code> 不一定要独占一个对象。 它可以和其他    <code>boost::shared_ptr</code> 类型的智能指针共享所有权。    在这种情况下，当引用对象的最后一个智能指针销毁后，对象才会被释放。</p>
<p>因为所有权可以在 <code>boost::shared_ptr</code>    之间共享，任何一个共享指针都可以被复制，这跟 <code>boost::scoped_ptr</code> 是不同的。    这样就可以在标准容器里存储智能指针了——你不能在标准容器中存储    <code>std::auto_ptr</code>，因为它们在拷贝的时候传递了所有权。</p>
<pre><code class="language-c++">#include &lt;boost/shared_ptr.hpp&gt; 
#include &lt;vector&gt; 

int main() 
{ 
  std::vector&lt;boost::shared_ptr&lt;int&gt; &gt; v; 
  v.push_back(boost::shared_ptr&lt;int&gt;(new int(1))); 
  v.push_back(boost::shared_ptr&lt;int&gt;(new int(2))); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.5.1/main.cpp">下载源代码</a></li>
</ul>
<p>多亏了有    <code>boost::shared_ptr</code>，我们才能像上例中展示的那样，在标准容器中安全的使用动态分配的对象。    因为 <code>boost::shared_ptr</code>    能够共享它所含对象的所有权，所以保存在容器中的拷贝（包括容器在需要时额外创建的拷贝）都是和原件相同的。如前所述，<code>std::auto_ptr</code>做不到这一点，所以绝对不应该在容器中保存它们。</p>
<p>类似于 <code>boost::scoped_ptr</code>，    <code>boost::shared_ptr</code>    类重载了以下这些操作符：<code>operator*()</code>，<code>operator-&gt;()</code>    和 <code>operator bool()</code>。另外还有 <code>get()</code>    和 <code>reset()</code> 函数来获取和重新初始化所包含的对象的地址。</p>
<pre><code class="language-c++">#include &lt;boost/shared_ptr.hpp&gt; 

int main() 
{ 
  boost::shared_ptr&lt;int&gt; i1(new int(1)); 
  boost::shared_ptr&lt;int&gt; i2(i1); 
  i1.reset(new int(2)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.5.2/main.cpp">下载源代码</a></li>
</ul>
<p>本例中定义了2个共享指针 i1 和 i2，它们都引用到同一个    <code>int</code> 类型的对象。i1 通过 <code>new</code>    操作符返回的地址显示的初始化，i2 通过 i1 拷贝构造而来。    i1 接着调用    <code>reset()</code>，它所包含的整数的地址被重新初始化。不过它之前所包含的对象并没有被释放，因为    i2 仍然引用着它。 智能指针    <code>boost::shared_ptr</code>    记录了有多少个共享指针在引用同一个对象，只有在最后一个共享指针销毁时才会释放这个对象。</p>
<p>默认情况下，<code>boost::shared_ptr</code> 使用    <code>delete</code> 操作符来销毁所含的对象。    然而，具体通过什么方法来销毁，是可以指定的，就像下面的例子里所展示的：</p>
<pre><code class="language-c++">#include &lt;boost/shared_ptr.hpp&gt; 
#include &lt;windows.h&gt; 

int main() 
{ 
  boost::shared_ptr&lt;void&gt; h(OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId()), CloseHandle); 
  SetPriorityClass(h.get(), HIGH_PRIORITY_CLASS); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.5.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::shared_ptr</code>    的构造函数的第二个参数是一个普通函数或者函数对象，该参数用来销毁所含的对象。 在本例中，这个参数是 Windows API 函数    <code>CloseHandle()</code>。 当变量 h    超出它的作用域时，调用的是这个函数而不是 <code>delete</code> 操作符来销毁所含的对象。 为了避免编译错误，该函数只能带一个    <code>HANDLE</code> 类型的参数， <code>CloseHandle()</code> 正好符合要求。</p>
<p>该例和本章稍早讲述 RAII 习语时所用的例子的运行是一样的。 然而，本例没有单独定义一个    <code>windows_handle</code> 类，而是利用了    <code>boost::shared_ptr</code>    的特性，给它的构造函数传递一个方法，这个方法会在共享指针超出它的作用域时自动调用。</p>
<hr />
<h2 id="26-共享数组"><a class="header" href="#26-共享数组">2.6. 共享数组</a></h2>
<p>共享数组的行为类似于共享指针。 关键不同在于共享数组在析构时，默认使用 <code>delete[]</code>    操作符来释放所含的对象。 因为这个操作符只能用于数组对象，共享数组必须通过动态分配的数组的地址来初始化。</p>
<p>共享数组对应的类型是 <code>boost::shared_array</code>，它的定义在    <code>boost/shared_array.hpp</code> 里。</p>
<pre><code class="language-c++">#include &lt;boost/shared_array.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::shared_array&lt;int&gt; i1(new int[2]); 
  boost::shared_array&lt;int&gt; i2(i1); 
  i1[0] = 1; 
  std::cout &lt;&lt; i2[0] &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.6.1/main.cpp">下载源代码</a></li>
</ul>
<p>就像共享指针那样，所含对象的所有权可以跟其他共享数组来共享。 这个例子中定义了2个变量 i1 和    i2，它们引用到同一个动态分配的数组。i1 通过    <code>operator[]()</code> 操作符保存了一个整数1——这个整数可以被    i2 引用，比如打印到标准输出。</p>
<p>和本章中所有的智能指针一样，<code>boost::shared_array</code> 也同样提供了    <code>get()</code> 和 <code>reset()</code> 方法。 另外还重载了    <code>operator bool()</code>。</p>
<hr />
<h2 id="27-弱指针"><a class="header" href="#27-弱指针">2.7. 弱指针</a></h2>
<p>到目前为止介绍的各种智能指针都能在不同的场合下独立使用。 相反，弱指针只有在配合共享指针一起使用时才有意义。 弱指针    <code>boost::weak_ptr</code> 的定义在 <code>boost/weak_ptr.hpp</code> 里。</p>
<pre><code class="language-c++">#include &lt;windows.h&gt; 
#include &lt;boost/shared_ptr.hpp&gt; 
#include &lt;boost/weak_ptr.hpp&gt; 
#include &lt;iostream&gt; 

DWORD WINAPI reset(LPVOID p) 
{ 
  boost::shared_ptr&lt;int&gt; *sh = static_cast&lt;boost::shared_ptr&lt;int&gt;*&gt;(p); 
  sh-&gt;reset(); 
  return 0; 
} 

DWORD WINAPI print(LPVOID p) 
{ 
  boost::weak_ptr&lt;int&gt; *w = static_cast&lt;boost::weak_ptr&lt;int&gt;*&gt;(p); 
  boost::shared_ptr&lt;int&gt; sh = w-&gt;lock(); 
  if (sh) 
    std::cout &lt;&lt; *sh &lt;&lt; std::endl; 
  return 0; 
} 

int main() 
{ 
  boost::shared_ptr&lt;int&gt; sh(new int(99)); 
  boost::weak_ptr&lt;int&gt; w(sh); 
  HANDLE threads[2]; 
  threads[0] = CreateThread(0, 0, reset, &amp;sh, 0, 0); 
  threads[1] = CreateThread(0, 0, print, &amp;w, 0, 0); 
  WaitForMultipleObjects(2, threads, TRUE, INFINITE); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.7.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::weak_ptr</code> 必定总是通过    <code>boost::shared_ptr</code> 来初始化的。一旦初始化之后，它基本上只提供一个有用的方法:    <code>lock()</code>。此方法返回的<code>boost::shared_ptr</code>    与用来初始化弱指针的共享指针共享所有权。 如果这个共享指针不含有任何对象，返回的共享指针也将是空的。</p>
<p>当函数需要一个由共享指针所管理的对象，而这个对象的生存期又不依赖于这个函数时，就可以使用弱指针。    只要程序中还有一个共享指针掌管着这个对象，函数就可以使用该对象。 如果共享指针复位了，就算函数里能得到一个共享指针，对象也不存在了。</p>
<p>上例的 <code>main()</code> 函数中，通过 Windows API 创建了2个线程。 于是乎，该例只能在    Windows 平台上编译运行。</p>
<p>第一个线程函数 <code>reset()</code> 的参数是一个共享指针的地址。 第二个线程函数    <code>print()</code> 的参数是一个弱指针的地址。 这个弱指针是之前通过共享指针初始化的。</p>
<p>一旦程序启动之后，<code>reset()</code> 和 <code>print()</code>    就都开始执行了。 不过执行顺序是不确定的。 这就导致了一个潜在的问题：<code>reset()</code>    线程在销毁对象的时候<code>print()</code> 线程可能正在访问它。</p>
<p>通过调用弱指针的 <code>lock()</code> 函数可以解决这个问题：如果对象存在，那么    <code>lock()</code>    函数返回的共享指针指向这个合法的对象。否则，返回的共享指针被设置为0，这等价于标准的null指针。</p>
<p>弱指针本身对于对象的生存期没有任何影响。 <code>lock()</code>    返回一个共享指针，<code>print()</code> 函数就可以安全的访问对象了。    这就保证了——即使另一个线程要释放对象——由于我们有返回的共享指针，对象依然存在。</p>
<hr />
<h2 id="28-介入式指针"><a class="header" href="#28-介入式指针">2.8. 介入式指针</a></h2>
<p>大体上，介入式指针的工作方式和共享指针完全一样。 <code>boost::shared_ptr</code>    在内部记录着引用到某个对象的共享指针的数量，可是对介入式指针来说，程序员就得自己来做记录。    对于框架对象来说这就特别有用，因为它们记录着自身被引用的次数。</p>
<p>介入式指针 <code>boost::intrusive_ptr</code> 定义在 <code>boost/intrusive_ptr.hpp</code> 里。</p>
<pre><code class="language-c++">#include &lt;boost/intrusive_ptr.hpp&gt; 
#include &lt;atlbase.h&gt; 
#include &lt;iostream&gt; 

void intrusive_ptr_add_ref(IDispatch *p) 
{ 
  p-&gt;AddRef(); 
} 

void intrusive_ptr_release(IDispatch *p) 
{ 
  p-&gt;Release(); 
} 

void check_windows_folder() 
{ 
  CLSID clsid; 
  CLSIDFromProgID(CComBSTR(&quot;Scripting.FileSystemObject&quot;), &amp;clsid); 
  void *p; 
  CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, __uuidof(IDispatch), &amp;p); 
  boost::intrusive_ptr&lt;IDispatch&gt; disp(static_cast&lt;IDispatch*&gt;(p)); 
  CComDispatchDriver dd(disp.get()); 
  CComVariant arg(&quot;C:\\Windows&quot;); 
  CComVariant ret(false); 
  dd.Invoke1(CComBSTR(&quot;FolderExists&quot;), &amp;arg, &amp;ret); 
  std::cout &lt;&lt; (ret.boolVal != 0) &lt;&lt; std::endl; 
} 

void main() 
{ 
  CoInitialize(0); 
  check_windows_folder(); 
  CoUninitialize(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.8.1/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子中使用了 COM（组件对象模型）提供的函数，于是乎只能在 Windows 平台上编译运行。 COM 对象是使用    <code>boost::intrusive_ptr</code> 的绝佳范例，因为 COM    对象需要记录当前有多少指针引用着它。 通过调用 <code>AddRef()</code> 和    <code>Release()</code> 函数，内部的引用计数分别增 1 或者减 1。当引用计数为 0 时，COM    对象自动销毁。</p>
<p>在 <code>intrusive_ptr_add_ref()</code> 和    <code>intrusive_ptr_release()</code> 内部调用    <code>AddRef()</code> 和 <code>Release()</code>    这两个函数，来增加或减少相应 COM 对象的引用计数。 这个例子中用到的 COM 对象名为 'FileSystemObject'，在 Windows    上它是默认可用的。通过这个对象可以访问底层的文件系统，比如检查一个给定的目录是否存在。 在上例中，我们检查 <code>C:\Windows</code> 目录是否存在。 具体它在内部是怎么实现的，跟    <code>boost::intrusive_ptr</code> 的功能无关，完全取决于 COM。 关键点在于一旦介入式指针    disp    离开了它的作用域——<code>check_windows_folder()</code> 函数的末尾，函数    <code>intrusive_ptr_release()</code> 将会被自动调用。 这将减少 COM 对象    'FileSystemObject' 的内部引用计数到0，于是该对象就销毁了。</p>
<hr />
<h2 id="29-指针容器"><a class="header" href="#29-指针容器">2.9. 指针容器</a></h2>
<p>在你见过 Boost C++    库的各种智能指针之后，应该能够编写安全的代码，来使用动态分配的对象和数组。多数时候，这些对象要存储在容器里——如上所述——使用    <code>boost::shared_ptr</code> 和    <code>boost::shared_array</code> 这就相当简单了。</p>
<pre><code class="language-c++">#include &lt;boost/shared_ptr.hpp&gt; 
#include &lt;vector&gt; 

int main() 
{ 
  std::vector&lt;boost::shared_ptr&lt;int&gt; &gt; v; 
  v.push_back(boost::shared_ptr&lt;int&gt;(new int(1))); 
  v.push_back(boost::shared_ptr&lt;int&gt;(new int(2))); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.9.1/main.cpp">下载源代码</a></li>
</ul>
<p>上面例子中的代码当然是正确的，智能指针确实可以这样用，然而因为某些原因，实际情况中并不这么用。 第一，反复声明    <code>boost::shared_ptr</code> 需要更多的输入。 其次，将    <code>boost::shared_ptr</code>    拷进，拷出，或者在容器内部做拷贝，需要频繁的增加或者减少内部引用计数，这肯定效率不高。 由于这些原因，Boost C++ 库提供了 <a href="http://www.boost.org/libs/ptr_container/"> 指针容器</a>    专门用来管理动态分配的对象。</p>
<pre><code class="language-c++">#include &lt;boost/ptr_container/ptr_vector.hpp&gt; 

int main() 
{ 
  boost::ptr_vector&lt;int&gt; v; 
  v.push_back(new int(1)); 
  v.push_back(new int(2)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.9.2/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::ptr_vector</code> 类的定义在 <code>boost/ptr_container/ptr_vector.hpp</code>    里，它跟前一个例子中用 <code>boost::shared_ptr</code> 模板参数来初始化的容器具有相同的工作方式。    <code>boost::ptr_vector</code> 专门用于动态分配的对象，它使用起来更容易也更高效。    <code>boost::ptr_vector</code> 独占它所包含的对象，因而容器之外的共享指针不能共享所有权，这跟    <code>std::vector&lt;boost::shared_ptr&lt;int&gt; &gt;</code> 相反。</p>
<p>除了 <code>boost::ptr_vector</code>    之外，专门用于管理动态分配对象的容器还包括：<code>boost::ptr_deque</code>，    <code>boost::ptr_list</code>，    <code>boost::ptr_set</code>，    <code>boost::ptr_map</code>，    <code>boost::ptr_unordered_set</code> 和    <code>boost::ptr_unordered_map</code>。这些容器等价于C++标准里提供的那些。最后两个容器对应于<code>std::unordered_set</code>    和 <code>std::unordered_map</code>，它们作为技术报告1的一部分加入 C++ 标准。 如果所使用的    C++ 标准实现不支持技术报告1的话，还可以使用 Boost C++ 库里实现的    <code>boost::unordered_set</code> 和    <code>boost::unordered_map</code>。</p>
<hr />
<h2 id="210-练习"><a class="header" href="#210-练习">2.10. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>
<p>使用适当的智能指针优化下面的程序：</p>
<pre><code class="language-c++">#include &lt;iostream&gt; 
#include &lt;cstring&gt; 

char *get(const char *s) 
{ 
  int size = std::strlen(s); 
  char *text = new char[size + 1]; 
  std::strncpy(text, s, size + 1); 
  return text; 
} 

void print(char *text) 
{ 
  std::cout &lt;&lt; text &lt;&lt; std::endl; 
} 

int main(int argc, char *argv[]) 
{ 
  if (argc &lt; 2) 
  { 
    std::cerr &lt;&lt; argv[0] &lt;&lt; &quot; &lt;data&gt;&quot; &lt;&lt; std::endl; 
    return 1; 
  } 

  char *text = get(argv[1]); 
  print(text); 
  delete[] text; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.10.1/main.cpp">下载源代码</a></li>
</ul>
</li>
<li>
<p>优化下面的程序：</p>
<pre><code class="language-c++">#include &lt;vector&gt; 

template &lt;typename T&gt; 
T *create() 
{ 
  return new T; 
} 

int main() 
{ 
  std::vector&lt;int*&gt; v; 
  v.push_back(create&lt;int&gt;()); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/2.10.2/main.cpp">下载源代码</a></li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-3-章-函数对象"><a class="header" href="#第-3-章-函数对象">第 3 章 函数对象</a></h1>
<h2 id="31-概述"><a class="header" href="#31-概述">3.1. 概述</a></h2>
<p>本章介绍的是函数对象，可能称为'高阶函数'更为适合。 它实际上是指那些可以被传入到其它函数或是从其它函数返回的一类函数。    在C++中高阶函数是被实现为函数对象的，所以这个标题还是有意义的。</p>
<p>在这整一章中，将会介绍几个用于处理函数对象的 Boost C++ 库。 其中，<a href="http://www.boost.org/libs/bind/">Boost.Bind</a>    可替换来自C++标准的著名的 <code>std::bind1st()</code> 和    <code>std::bind2nd()</code> 函数，而 <a href="http://www.boost.org/libs/function/">Boost.Function</a>    则提供了一个用于封装函数指针的类。 最后，<a href="http://www.boost.org/libs/lambda/">Boost.Lambda</a>    则引入了一种创建匿名函数的方法。</p>
<hr />
<h2 id="32-boostbind"><a class="header" href="#32-boostbind">3.2. Boost.Bind</a></h2>
<p>Boost.Bind 是这样的一个库，它简化了由C++标准中的 <code>std::bind1st()</code> 和    <code>std::bind2nd()</code>    模板函数所提供的一个机制：将这些函数与几乎不限数量的参数一起使用，就可以得到指定签名的函数。    这种情形的一个最好的例子就是在C++标准中定义的多个不同算法。</p>
<pre><code class="language-c++">#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

void print(int i) 
{ 
  std::cout &lt;&lt; i &lt;&lt; std::endl; 
} 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::for_each(v.begin(), v.end(), print); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>算法 <code>std::for_each()</code> 要求它的第三个参数是一个仅接受正好一个参数的函数或函数对象。    如果 <code>std::for_each()</code> 被执行，指定容器中的所有元素 - 在上例中，这些元素的类型为    <code>int</code> - 将按顺序被传入至 <code>print()</code> 函数。    但是，如果要使用一个具有不同签名的函数的话，事情就复杂了。 例如，如果要传入的是以下函数    <code>add()</code>，它要将一个常数值加至容器中的每个元素上，并显示结果。</p>
<pre><code class="language-c++">void add(int i, int j) 
{ 
  std::cout &lt;&lt; i + j &lt;&lt; std::endl; 
} 
</code></pre>
<p>由于 <code>std::for_each()</code> 要求的是仅接受一个参数的函数，所以不能直接传入    <code>add()</code> 函数。 源代码必须要修改。</p>
<pre><code class="language-c++">#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 
#include &lt;functional&gt; 

class add 
  : public std::binary_function&lt;int, int, void&gt; 
{ 
public: 
  void operator()(int i, int j) const 
  { 
    std::cout &lt;&lt; i + j &lt;&lt; std::endl; 
  } 
}; 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::for_each(v.begin(), v.end(), std::bind1st(add(), 10)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序将值10加至容器 v 的每个元素之上，并使用标准输出流显示结果。    源代码必须作出大幅的修改，以实现此功能：<code>add()</code> 函数已被转换为一个派生自    <code>std::binary_function</code> 的函数对象。</p>
<p>Boost.Bind 简化了不同函数之间的绑定。 它只包含一个 <code>boost::bind()</code>    模板函数，定义于 <code>boost/bind.hpp</code> 中。    使用这个函数，可以如下实现以上例子：</p>
<pre><code class="language-c++">#include &lt;boost/bind.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

void add(int i, int j) 
{ 
  std::cout &lt;&lt; i + j &lt;&lt; std::endl; 
} 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::for_each(v.begin(), v.end(), boost::bind(add, 10, _1)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>象 <code>add()</code> 这样的函数不再需要为了要用于    <code>std::for_each()</code> 而转换为函数对象。 使用    <code>boost::bind()</code>，这个函数可以忽略其第一个参数而使用。</p>
<p>因为 <code>add()</code> 函数要求两个参数，两个参数都必须传递给    <code>boost::bind()</code>。 第一个参数是常数值10，而第二个参数则是一个怪异的    _1。</p>
<p>_1 被称为占位符(placeholder)，定义于 Boost.Bind。 除了    _1，Boost.Bind 还定义了 _2 和    _3。 通过使用这些占位符，<code>boost::bind()</code>    可以变为一元、二元或三元的函数。 对于 _1,    <code>boost::bind()</code> 变成了一个一元函数 - 即只要求一个参数的函数。 这是必需的，因为    <code>std::for_each()</code> 正是要求一个一元函数作为其第三个参数。</p>
<p>当这个程序执行时，<code>std::for_each()</code> 对容器 v    中的第一个元素调用该一元函数。 元素的值通过占位符 _1 传入到一元函数中。 这个占位符和常数值被进一步传递到    <code>add()</code> 函数。 通过使用这种机制，<code>std::for_each()</code>    只看到了由 <code>boost::bind()</code> 所定义的一元函数。 而    <code>boost::bind()</code> 本身则只是调用了另一个函数，并将常数值或占位符作为参数传入给它。</p>
<p>下面这个例子通过 <code>boost::bind()</code> 定义了一个二元函数，用于    <code>std::sort()</code> 算法，该算法要求一个二元函数作为其第三个参数。</p>
<pre><code class="language-c++">#include &lt;boost/bind.hpp&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

bool compare(int i, int j) 
{ 
  return i &gt; j; 
} 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::sort(v.begin(), v.end(), boost::bind(compare, _1, _2)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>因为使用了两个占位符 _1 和 _2，所以    <code>boost::bind()</code> 定义了一个二元函数。 <code>std::sort()</code>    算法以容器 v 的两个元素来调用该函数，并根据返回值来对容器进行排序。 基于    <code>compare()</code> 函数的定义，容器将被按降序排列。</p>
<p>但是，由于 <code>compare()</code> 本身就是一个二元函数，所以使用    <code>boost::bind()</code> 确是多余的。</p>
<pre><code class="language-c++">#include &lt;boost/bind.hpp&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

bool compare(int i, int j) 
{ 
  return i &gt; j; 
} 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::sort(v.begin(), v.end(), compare); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>不过使用 <code>boost::bind()</code> 还是有意义的。例如，如果容器要按升序排列而又不能修改    <code>compare()</code> 函数的定义。</p>
<pre><code class="language-c++">#include &lt;boost/bind.hpp&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

bool compare(int i, int j) 
{ 
  return i &gt; j; 
} 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::sort(v.begin(), v.end(), boost::bind(compare, _2, _1)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.2.6/main.cpp">下载源代码</a></li>
</ul>
<p>该例子仅改变了占位符的顺序：_2 被作为第一参数传递，而    _1 则被作为第二参数传递至    <code>compare()</code>，这样即可改变排序的顺序。</p>
<hr />
<h2 id="33-boostref"><a class="header" href="#33-boostref">3.3. Boost.Ref</a></h2>
<p>本库 <a href="http://www.boost.org/doc/html/ref.html">Boost.Ref</a> 通常与    Boost.Bind 一起使用，所以我把它们挨着写。 它提供了两个函数 - <code>boost::ref()</code> 和    <code>boost::cref()</code> - 定义于 <code>boost/ref.hpp</code>.</p>
<p>当要用于 <code>boost::bind()</code> 的函数带有至少一个引用参数时，Boost.Ref    就很重要了。 由于 <code>boost::bind()</code> 会复制它的参数，所以引用必须特别处理。</p>
<pre><code class="language-c++">#include &lt;boost/bind.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

void add(int i, int j, std::ostream &amp;os) 
{ 
  os &lt;&lt; i + j &lt;&lt; std::endl; 
} 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::for_each(v.begin(), v.end(), boost::bind(add, 10, _1, boost::ref(std::cout))); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>以上例子使用了上一节中的 <code>add()</code> 函数。 不过这一次该函数需要一个流对象的引用来打印信息。    因为传给 <code>boost::bind()</code> 的参数是以值方式传递的，所以    std::cout 不能直接使用，否则该函数会试图创建它的一份拷贝。</p>
<p>通过使用模板函数 <code>boost::ref()</code>，象    std::cout 这样的流就可以被以引用方式传递，也就可以成功编译上面这个例子了。</p>
<p>要以引用方式传递常量对象，可以使用模板函数 <code>boost::cref()</code>。</p>
<hr />
<h2 id="34-boostfunction"><a class="header" href="#34-boostfunction">3.4. Boost.Function</a></h2>
<p>为了封装函数指针，<a href="http://www.boost.org/libs/function/">Boost.Function</a>    提供了一个名为 <code>boost::function</code> 的类。 它定义于 <code>boost/function.hpp</code>，用法如下：</p>
<pre><code class="language-c++">#include &lt;boost/function.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 

int main() 
{ 
  boost::function&lt;int (const char*)&gt; f = std::atoi; 
  std::cout &lt;&lt; f(&quot;1609&quot;) &lt;&lt; std::endl; 
  f = std::strlen; 
  std::cout &lt;&lt; f(&quot;1609&quot;) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.4.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::function</code> 可以定义一个指针，指向具有特定签名的函数。    以上例子定义了一个指针 f，它可以指向某个接受一个类型为 <code>const char*</code>    的参数且返回一个类型为 <code>int</code> 的值的函数。 定义完成后，匹配此签名的函数均可赋值给这个指针。 这个例程就是先将    <code>std::atoi()</code> 赋值给 f，然后再将它重赋值为    <code>std::strlen()</code>。</p>
<p>注意，给定的数据类型并不需要精确匹配：虽然 <code>std::strlen()</code> 是以    <code>std::size_t</code> 作为返回类型的，但是它也可以被赋值给 f。</p>
<p>因为 f 是一个函数指针，所以被赋值的函数可以通过重载的    <code>operator()()</code> 操作符来调用。 取决于当前被赋值的是哪一个函数，在以上例子中将调用    <code>std::atoi()</code> 或 <code>std::strlen()</code>。</p>
<p>如果 f 未赋予一个函数而被调用，则会抛出一个    <code>boost::bad_function_call</code> 异常。</p>
<pre><code class="language-c++">#include &lt;boost/function.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    boost::function&lt;int (const char*)&gt; f; 
    f(&quot;&quot;); 
  } 
  catch (boost::bad_function_call &amp;ex) 
  { 
    std::cout &lt;&lt; ex.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>注意，将值 0 赋给一个 <code>boost::function</code>    类型的函数指针，将会释放当前所赋的函数。 释放之后再调用它也会导致    <code>boost::bad_function_call</code> 异常被抛出。    要检查一个函数指针是否被赋值某个函数，可以使用 <code>empty()</code> 函数或    <code>operator bool()</code> 操作符。</p>
<p>通过使用 Boost.Function，类成员函数也可以被赋值给类型为    <code>boost::function</code> 的对象。</p>
<pre><code class="language-c++">#include &lt;boost/function.hpp&gt; 
#include &lt;iostream&gt; 

struct world 
{ 
  void hello(std::ostream &amp;os) 
  { 
    os &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
  } 
}; 

int main() 
{ 
  boost::function&lt;void (world*, std::ostream&amp;)&gt; f = &amp;world::hello; 
  world w; 
  f(&amp;w, boost::ref(std::cout)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.4.3/main.cpp">下载源代码</a></li>
</ul>
<p>在调用这样的一个函数时，传入的第一个参数表示了该函数被调用的那个特定对象。    因此，在模板定义中的左括号后的第一个参数必须是该特定类的指针。 接下来的参数才是表示相应的成员函数的签名。</p>
<p>这个程序还使用了来自 Boost.Ref 库的 <code>boost::ref()</code>，它提供了一个方便的机制向    Boost.Function 传递引用。</p>
<hr />
<h2 id="35-boostlambda"><a class="header" href="#35-boostlambda">3.5. Boost.Lambda</a></h2>
<p>匿名函数 - 又称为 lambda 函数 - 已经在多种编程语言中存在，但 C++ 除外。 不过在 <a href="http://www.boost.org/libs/lambda/">Boost.Lambda</a>    库的帮助下，现在在 C++ 应用中也可以使用它们了。</p>
<p>lambda 函数的目标是令源代码更为紧凑，从而也更容易理解。 以本章第一节中的代码例子为例。</p>
<pre><code class="language-c++">#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

void print(int i) 
{ 
  std::cout &lt;&lt; i &lt;&lt; std::endl; 
} 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::for_each(v.begin(), v.end(), print); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>这段程序接受容器 v 中的元素并使用 <code>print()</code>    函数将它们写出到标准输出流。 由于 <code>print()</code> 只是写出一个简单的    <code>int</code>，所以该函数的实现相当简单。 严格来说，它是如此地简单，以致于如果可以在    <code>std::for_each()</code> 算法里面直接定义它的话，会更为方便； 从而省去增加一个函数的需要。    另外一个好处是代码更为紧凑，使得算法与负责数据输出的函数不是局部性分离的。 Boost.Lambda 正好使之成为现实。</p>
<pre><code class="language-c++">#include &lt;boost/lambda/lambda.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::for_each(v.begin(), v.end(), std::cout &lt;&lt; boost::lambda::_1 &lt;&lt; &quot;\n&quot;); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.5.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.Lambda 提供了几个结构来定义匿名函数。    代码就被置于执行的地方，从而省去将它包装为一个函数再进行相应的函数调用的这些开销。 与原来的例子一样，这个程序将容器    v 的所有元素写出至标准输出流。</p>
<p>与 Boost.Bind 相类似，Boost.Lambda 也定义了三个占位符，名为 _1,    _2 和 _3。 但与 Boost.Bind    不同的是，这些占位符是定义在单独的名字空间的。 因此，该例中的第一个占位符是通过    boost::lambda::_1 来引用的。 为了满足编译器的要求，必须包含相应的头文件 <code>boost/lambda/lambda.hpp</code>。</p>
<p>虽然代码的位置位于 <code>std::for_each()</code> 的第三个参数处，看起来很怪异，但    Boost.Lambda 可以写出正常的 C++ 代码。 通过使用占位符，容器 v 的元素可以通过    <code>&lt;&lt;</code> 传给 std::cout 以将它们写出到标准输出流。</p>
<p>虽然 Boost.Lambda 非常强大，但也有一些缺点。 要在以上例子中插入换行的话，必须用 &quot;\n&quot; 来替代    <code>std::endl</code> 才能成功编译。 因为一元 <code>std::endl</code> 模板函数所要求的类型不同于    lambda 函数 <code>std::cout &lt;&lt; boost::lambda::_1</code>    的函数，所以在此不能使用它。</p>
<p>下一个版本的 C++ 标准很可能会将 lambda 函数作为 C++ 语言本身的组成部分加入，从而消除对单独的库的需要。    但是在下一个版本到来并被不同的编译器厂商所采用可能还需要好几年。 在此之前，Boost.Lambda    被证明是一个完美的替代品，从以下例子可以看出，这个例子只将大于1的元素写出到标准输出流。</p>
<pre><code class="language-c++">#include &lt;boost/lambda/lambda.hpp&gt; 
#include &lt;boost/lambda/if.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

int main() 
{ 
  std::vector&lt;int&gt; v; 
  v.push_back(1); 
  v.push_back(3); 
  v.push_back(2); 

  std::for_each(v.begin(), v.end(), 
    boost::lambda::if_then(boost::lambda::_1 &gt; 1, 
    std::cout &lt;&lt; boost::lambda::_1 &lt;&lt; &quot;\n&quot;)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.5.2/main.cpp">下载源代码</a></li>
</ul>
<p>头文件 <code>boost/lambda/if.hpp</code>    定义了几个结构，允许在 lambda 函数内部使用 <code>if</code> 语句。 最基本的结构是    <code>boost::lambda::if_then()</code> 模板函数，它要求两个参数：第一个参数对条件求值 -    如果为真，则执行第二个参数。 如例中所示，每个参数本身都可以是 lambda 函数。</p>
<p>除了 <code>boost::lambda::if_then()</code>, Boost.Lambda 还提供了    <code>boost::lambda::if_then_else()</code> 和    <code>boost::lambda::if_then_else_return()</code> 模板函数 - 它们都要求三个参数。    另外还提供了用于实现循环、转型操作符，甚至是 <code>throw</code> - 允许 lambda 函数抛出异常 -    的模板函数。</p>
<p>虽然可以用这些模板函数在 C++ 中构造出复杂的 lambda 函数，但是你必须要考虑其它方面，如可读性和可维护性。    因为别人需要学习并理解额外的函数，如用 <code>boost::lambda::if_then()</code> 来替代已知的 C++    关键字 <code>if</code> 和 <code>else</code>，lambda 函数的好处通常随着它的复杂性而降低。    多数情况下，更为合理的方法是用熟悉的 C++ 结构定义一个单独的函数。</p>
<hr />
<h2 id="36-练习"><a class="header" href="#36-练习">3.6. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>
<p>简化以下程序，将函数对象 <code>divide_by</code> 转换为一个函数，并将        <code>for</code> 循环替换为用一个标准的 C++ 算法来输出数据：</p>
<pre><code class="language-c++">#include &lt;algorithm&gt; 
#include &lt;functional&gt; 
#include &lt;vector&gt; 
#include &lt;iostream&gt; 

class divide_by 
  : public std::binary_function&lt;int, int, int&gt; 
{ 
public: 
  int operator()(int n, int div) const 
  { 
    return n / div; 
  } 
}; 

int main() 
{ 
  std::vector&lt;int&gt; numbers; 
  numbers.push_back(10); 
  numbers.push_back(20); 
  numbers.push_back(30); 

  std::transform(numbers.begin(), numbers.end(), numbers.begin(), std::bind2nd(divide_by(), 2)); 

  for (std::vector&lt;int&gt;::iterator it = numbers.begin(); it != numbers.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.6.1/main.cpp">下载源代码</a></li>
</ul>
</li>
<li>
<p>简化以下程序，将两个 <code>for</code> 循环都替换为标准的 C++ 算法：</p>
<pre><code class="language-c++">#include &lt;string&gt; 
#include &lt;vector&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::vector&lt;std::string&gt; strings; 
  strings.push_back(&quot;Boost&quot;); 
  strings.push_back(&quot;C++&quot;); 
  strings.push_back(&quot;Libraries&quot;); 

  std::vector&lt;int&gt; sizes; 

  for (std::vector&lt;std::string&gt;::iterator it = strings.begin(); it != strings.end(); ++it) 
    sizes.push_back(it-&gt;size()); 

  for (std::vector&lt;int&gt;::iterator it = sizes.begin(); it != sizes.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.6.2/main.cpp">下载源代码</a></li>
</ul>
</li>
<li>
<p>简化以下程序，修改变量 processors 的类型，并将        <code>for</code> 循环替换为标准的 C++ 算法：</p>
<pre><code class="language-c++">#include &lt;vector&gt; 
#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 

int main() 
{ 
  std::vector&lt;int(*)(const char*)&gt; processors; 
  processors.push_back(std::atoi); 
  processors.push_back(reinterpret_cast&lt;int(*)(const char*)&gt;(std::strlen)); 

  const char data[] = &quot;1.23&quot;; 

  for (std::vector&lt;int(*)(const char*)&gt;::iterator it = processors.begin(); it != processors.end(); ++it) 
    std::cout &lt;&lt; (*it)(data) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/3.6.3/main.cpp">下载源代码</a></li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-4-章-事件处理"><a class="header" href="#第-4-章-事件处理">第 4 章 事件处理</a></h1>
<h2 id="41-概述"><a class="header" href="#41-概述">4.1. 概述</a></h2>
<p>很多开发者在听到术语'事件处理'时就会想到GUI：点击一下某个按钮，相关联的功能就会被执行。    点击本身就是事件，而功能就是相对应的事件处理器。</p>
<p>这一模式的使用当然不仅限于GUI。 一般情况下，任意对象都可以调用基于特定事件的专门函数。 本章所介绍的 <a href="http://www.boost.org/libs/signals">Boost.Signals</a>    库提供了一个简单的方法在 C++ 中应用这一模式。</p>
<p>严格来说，Boost.Function 库也可以用于事件处理。 不过，Boost.Function 和 Boost.Signals    之间的一个主要区别在于，Boost.Signals 能够将一个以上的事件处理器关联至单个事件。 因此，Boost.Signals    可以更好地支持事件驱动的开发，当需要进行事件处理时，应作为第一选择。</p>
<hr />
<h2 id="42-信号-signals"><a class="header" href="#42-信号-signals">4.2. 信号 Signals</a></h2>
<p>虽然这个库的名字乍一看好象有点误导，但实际上并非如此。 Boost.Signals 所实现的模式被命名为 '信号至插槽' (signal    to slot)，它基于以下概念：当对应的信号被发出时，相关联的插槽即被执行。 原则上，你可以把单词 '信号' 和 '插槽' 分别替换为 '事件'    和 '事件处理器'。 不过，由于信号可以在任意给定的时间发出，所以这一概念放弃了 '事件' 的名字。</p>
<p>因此，Boost.Signals 没有提供任何类似于 '事件' 的类。 相反，它提供了一个名为    <code>boost::signal</code> 的类，定义于 <code>boost/signal.hpp</code>.    实际上，这个头文件是唯一一个需要知道的，因为它会自动包含其它相关的头文件。</p>
<p>Boost.Signals 定义了其它一些类，位于 boost::signals 名字空间中。    由于 <code>boost::signal</code> 是最常被用到的类，所以它是位于名字空间    boost 中的。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(func); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::signal</code>    实际上被实现为一个模板函数，具有被用作为事件处理器的函数的签名，该签名也是它的模板参数。 在这个例子中，只有签名为 <code>void    ()</code> 的函数可以被成功关联至信号 s。</p>
<p>函数 <code>func()</code> 被通过 <code>connect()</code>    方法关联至信号 s。 由于 <code>func()</code> 符合所要求的    <code>void ()</code> 签名，所以该关联成功建立。因此当信号 s    被触发时，<code>func()</code> 将被调用。</p>
<p>信号是通过调用 s 来触发的，就象普通的函数调用那样。    这个函数的签名对应于作为模板参数传入的签名：因为 <code>void ()</code> 不要求任何参数，所以括号内是空的。</p>
<p>调用 s 会引发一个触发器，进而执行相应的 <code>func()</code>    函数 - 之前用 <code>connect()</code> 关联了的。</p>
<p>同一例子也可以用 Boost.Function 来实现。</p>
<pre><code class="language-c++">#include &lt;boost/function.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::function&lt;void ()&gt; f; 
  f = func; 
  f(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>和前一个例子相类似，<code>func()</code> 被关联至 f。 当    f 被调用时，就会相应地执行 <code>func()</code>。    Boost.Function 仅限于这种情形下适用，而 Boost.Signals    则提供了多得多的方式，如关联多个函数至单个特定信号，示例如下。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func1() 
{ 
  std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; 
} 

void func2() 
{ 
  std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::signal</code> 可以通过反复调用    <code>connect()</code> 方法来把多个函数赋值给单个特定信号。 当该信号被触发时，这些函数被按照之前用    <code>connect()</code> 进行关联时的顺序来执行。</p>
<p>另外，执行的顺序也可通过 <code>connect()</code>    方法的另一个重载版本来明确指定，该重载版本要求以一个 <code>int</code> 类型的值作为额外的参数。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func1() 
{ 
  std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; 
} 

void func2() 
{ 
  std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(1, func2); 
  s.connect(0, func1); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>和前一个例子一样，<code>func1()</code> 在 <code>func2()</code>    之前执行。</p>
<p>要释放某个函数与给定信号的关联，可以用 <code>disconnect()</code> 方法。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func1() 
{ 
  std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; 
} 

void func2() 
{ 
  std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  s.disconnect(func2); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子仅输出 <code>Hello</code>，因为与    <code>func2()</code> 的关联在触发信号之前已经被释放。</p>
<p>除了 <code>connect()</code> 和    <code>disconnect()</code>    以外，<code>boost::signal</code> 还提供了几个方法。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func1() 
{ 
  std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; 
} 

void func2() 
{ 
  std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl; 
  if (!s.empty()) 
    s(); 
  s.disconnect_all_slots(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.6/main.cpp">下载源代码</a></li>
</ul>
<p><code>num_slots()</code> 返回已关联函数的数量。如果没有函数被关联，则    <code>num_slots()</code> 返回0。 在这种特定情况下，可以用    <code>empty()</code> 方法来替代。    <code>disconnect_all_slots()</code>    方法所做的实际上正是它的名字所表达的：释放所有已有的关联。</p>
<p>看完了函数如何被关联至信号，以及弄明白了信号被触发时会发生什么事之后，还有一个问题：这些函数的返回值去了哪里？    以下例子回答了这个问题。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

int func1() 
{ 
  return 1; 
} 

int func2() 
{ 
  return 2; 
} 

int main() 
{ 
  boost::signal&lt;int ()&gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  std::cout &lt;&lt; s() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.7/main.cpp">下载源代码</a></li>
</ul>
<p><code>func1()</code> 和 <code>func2()</code> 都具有    <code>int</code> 类型的返回值。 s 将处理两个返回值，并将它们都写出至标准输出流。    那么，到底会发生什么呢？</p>
<p>以上例子实际上会把 <code>2</code> 写出至标准输出流。 两个返回值都被    s 正确接收，但除了最后一个值，其它值都会被忽略。    缺省情况下，所有被关联函数中，实际上只有最后一个返回值被返回。</p>
<p>你可以定制一个信号，令每个返回值都被相应地处理。 为此，要把一个称为合成器(combiner)的东西作为第二个参数传递给    <code>boost::signal</code>。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;algorithm&gt; 

int func1() 
{ 
  return 1; 
} 

int func2() 
{ 
  return 2; 
} 

template &lt;typename T&gt; 
struct min_element 
{ 
  typedef T result_type; 

  template &lt;typename InputIterator&gt; 
  T operator()(InputIterator first, InputIterator last) const 
  { 
    return *std::min_element(first, last); 
  } 
}; 

int main() 
{ 
  boost::signal&lt;int (), min_element&lt;int&gt; &gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  std::cout &lt;&lt; s() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.8/main.cpp">下载源代码</a></li>
</ul>
<p>合成器是一个重载了 <code>operator()()</code>    操作符的类。这个操作符会被自动调用，传入两个迭代器，指向某个特定信号的所有返回值。 以上例子使用了标准 C++ 算法    <code>std::min_element()</code> 来确定并返回最小的值。</p>
<p>不幸的是，我们不可能把象 <code>std::min_element()</code> 这样的一个算法直接传给    <code>boost::signal</code> 作为一个模板参数。    <code>boost::signal</code> 要求这个合成器定义一个名为    <code>result_type</code> 的类型，用于说明 <code>operator()()</code>    操作符返回值的类型。 由于在标准 C++ 算法中缺少这个类型，所以在编译时会产生一个相应的错误。</p>
<p>除了对返回值进行分析以外，合成器也可以保存它们。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

int func1() 
{ 
  return 1; 
} 

int func2() 
{ 
  return 2; 
} 

template &lt;typename T&gt; 
struct min_element 
{ 
  typedef T result_type; 

  template &lt;typename InputIterator&gt; 
  T operator()(InputIterator first, InputIterator last) const 
  { 
    return T(first, last); 
  } 
}; 

int main() 
{ 
  boost::signal&lt;int (), min_element&lt;std::vector&lt;int&gt; &gt; &gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  std::vector&lt;int&gt; v = s(); 
  std::cout &lt;&lt; *std::min_element(v.begin(), v.end()) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.9/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子把所有返回值保存在一个 vector 中，再由 <code>s()</code> 返回。</p>
<hr />
<h2 id="43-连接-connections"><a class="header" href="#43-连接-connections">4.3. 连接 Connections</a></h2>
<p>函数可以通过由 <code>boost::signal</code> 所提供的    <code>connect()</code> 和 <code>disconnect()</code>    方法的帮助来进行管理。 由于 <code>connect()</code> 会返回一个类型为    <code>boost::signals::connection</code> 的值，它们可以通过其它方法来管理。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  boost::signals::connection c = s.connect(func); 
  s(); 
  c.disconnect(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::signal</code> 的    <code>disconnect()</code> 方法需要传入一个函数指针，而直接调用    <code>boost::signals::connection</code> 对象上的    <code>disconnect()</code> 方法则略去该参数。</p>
<p>除了 <code>disconnect()</code>    方法之外，<code>boost::signals::connection</code> 还提供了其它方法，如    <code>block()</code> 和 <code>unblock()</code>。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  boost::signals::connection c = s.connect(func); 
  c.block(); 
  s(); 
  c.unblock(); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序只会执行一次 <code>func()</code>。 虽然信号 s    被触发了两次，但是在第一次触发时 <code>func()</code> 不会被调用，因为连接 c    实际上已经被 <code>block()</code> 调用所阻塞。 由于在第二次触发之前调用了    <code>unblock()</code>，所以之后 <code>func()</code>    被正确地执行。</p>
<p>除了 <code>boost::signals::connection</code> 以外，还有一个名为    <code>boost::signals::scoped_connection</code>    的类，它会在析构时自动释放连接。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  { 
    boost::signals::scoped_connection c = s.connect(func); 
  } 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>因为连接对象 c 在信号触发之前被销毁，所以 <code>func()</code>    不会被调用。</p>
<p><code>boost::signals::scoped_connection</code> 实际上是派生自    <code>boost::signals::connection</code>    的，所以它提供了相同的方法。它们之间的区别仅在于，在析构    <code>boost::signals::scoped_connection</code> 时，连接会自动释放。</p>
<p>虽然 <code>boost::signals::scoped_connection</code>    的确令自动释放连接更为容易，但是该类型的对象仍需要管理。 如果在其它情形下连接也可以被自动释放，而且不需要管理这些对象的话，就更好了。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;boost/bind.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;memory&gt; 

class world 
{ 
  public: 
    void hello() const 
    { 
      std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
    } 
}; 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  { 
    std::auto_ptr&lt;world&gt; w(new world()); 
    s.connect(boost::bind(&amp;world::hello, w.get())); 
  } 
  std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl; 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.4/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序使用 Boost.Bind 将一个对象的方法关联至一个信号。 在信号触发之前，这个对象就被销毁了，这会产生问题。    我们不传递实际的对象 w，而只传递一个指针给    <code>boost::bind()</code>。 在 <code>s()</code>    被实际调用的时候，该指针所引向的对象已不再存在。</p>
<p>可以如下修改这个程序，使得一旦对象 w 被销毁，连接就会自动释放。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;boost/bind.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;memory&gt; 

class world : 
  public boost::signals::trackable 
{ 
  public: 
    void hello() const 
    { 
      std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
    } 
}; 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  { 
    std::auto_ptr&lt;world&gt; w(new world()); 
    s.connect(boost::bind(&amp;world::hello, w.get())); 
  } 
  std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl; 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>如果现在再执行，<code>num_slots()</code> 会返回    <code>0</code> 以确保不会试图调用已销毁对象之上的方法。 仅需的修改是让    <code>world</code> 类继承自    <code>boost::signals::trackable</code>。    当使用对象的指针而不是对象的副本来关联函数至信号时，<code>boost::signals::trackable</code>    可以显著简化连接的管理。</p>
<hr />
<h2 id="44-练习"><a class="header" href="#44-练习">4.4. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>
<p>编写一个程序，定义一个名为 <code>button</code> 的类，表示GUI中的一个可点击按钮。        为该类加入两个方法 <code>add_handler()</code> 和        <code>remove_handler()</code>，它们均要求一个函数名作为参数。 如果        <code>click()</code> 方法被调用，已登记的函数将被按顺序执行。</p>
<p>如下测试你的代码，创建一个 <code>button</code>        类的实例，从事件处理器内部向标准输出流写出一个信息。 调用 <code>click()</code>        函数模拟用鼠标点击该按钮。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-5-章-字符串处理"><a class="header" href="#第-5-章-字符串处理">第 5 章 字符串处理</a></h1>
<h2 id="51-前言"><a class="header" href="#51-前言">5.1. 前言</a></h2>
<p>在标准 C++ 中，用于处理字符串的是 <code> std::string</code>    类，它提供很多字符串操作，包括查找指定字符或子串的函数。 尽管 <code>std::string</code>    囊括了百余函数，是标准 C++ 中最为臃肿的类之一，然而却并不能满足很多开发者在日常工作中的需要。 例如， Java 和 .Net    提供了可以将字符串转换到大写字母的函数，而 <code>std::string</code> 就没有相应的功能。 Boost    C++ 库试图弥补这一缺憾。</p>
<hr />
<h2 id="52-区域设置"><a class="header" href="#52-区域设置">5.2. 区域设置</a></h2>
<p>在进入正题之前，有必要先审视下区域设置的问题，本章中提到的很多函数都需要一个附加的区域设置参数。</p>
<p>区域设置在标准 C++    中封装了文化习俗相关的内容，包括货币符号，日期时间格式，    分隔整数部分与分数部分的符号（基数符）以及多于三个数字时的分隔符（千位符）。</p>
<p>在字符串处理方面，区域设置和特定文化中对字符次序以及特殊字符的描述有关。    例如，字母表中是否含有变异元音字母以及其在字母表中的位置都由语言文化决定。</p>
<p>如果一个函数用于将字符串转换为大写形式，那么其实施步骤取决于具体的区域设置。 在德语中，字母 'ä' 显然要转换为 'Ä'，    然而在其他语言中并不一定。</p>
<p>使用类 <code>std::string</code> 时区域设置可以忽略， 因为它的函数均不依赖于特定语言。    然而在本章中为了使用 Boost C++ 库， 区域设置的知识是必不可少的。</p>
<p>C++ 标准中在 <code>locale</code> 文件中定义了类    <code>std::locale</code> 。 每个 C++ 程序自动拥有一个此类的实例， 即不能直接访问的全局区域设置。    如果要访问它，需要使用默认构造函数构造类 <code>std::locale</code>    的对象，并使用与全局区域设置相同的属性初始化。</p>
<pre><code class="language-c++">#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale loc; 
  std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序在标准输出流输出 <code>C</code> ，这是基本区域设置的名称，它包括了 C    语言编写的程序中默认使用的描述。</p>
<p>这也是每个 C++ 应用的默认全局区域设置，它包括了美式文化中使用的描述。    例如，货币符号使用美元符号，基字符为英文句号，日期中的月份用英语书写。</p>
<p>全局区域设置可以使用类 <code>std::locale</code> 中的静态函数    <code>global()</code> 改变。</p>
<pre><code class="language-c++">#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::locale loc; 
  std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>静态函数 <code>global()</code> 接受一个类型为    <code>std::locale</code> 的对象作为其唯一的参数。 此类的另一个版本的构造函数接受类型为    <code>const char*</code> 的字符串，可以为一个特别的文化创建区域设置对象。 然而，除了 C 区域设置相应地命名为 &quot;C&quot;    之外，其他区域设置的名字并没有标准化，所以这依赖于接受区域设置名字的 C++ 标准库。 在使用 Visual Studio 2008    的情况下，<a href="http://msdn.microsoft.com/en-us/library/39cwe7zf.aspx">语言字符串文档</a>    指出， 可以使用语言字符串 &quot;German&quot; 选择定义为德国文化。</p>
<p>执行程序，会输出 <code>German_Germany.1252</code> 。    指定语言字符串为 &quot;German&quot; 等于选择了德国文化作为主要语言和子语言，这里选择了字符映射 1252。</p>
<p>如果想指定与德国文化不同的子语言设置，例如瑞士语，需要使用不同的语言字符串。</p>
<pre><code class="language-c++">#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German_Switzerland&quot;)); 
  std::locale loc; 
  std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>现在程序会输出 <code>German_Switzerland.1252</code>    。</p>
<p>在初步理解了区域设置以及如何更改全局设置后， 下面的例子说明了区域设置如何影响字符串操作。</p>
<pre><code class="language-c++">#include &lt;locale&gt; 
#include &lt;iostream&gt; 
#include &lt;cstring&gt; 

int main() 
{ 
  std::cout &lt;&lt; std::strcoll(&quot;ä&quot;, &quot;z&quot;) &lt;&lt; std::endl; 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::cout &lt;&lt; std::strcoll(&quot;ä&quot;, &quot;z&quot;) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>本例使用了定义在文件 <code>cstring</code> 中的函数    <code>std::strcoll()</code> ，这个函数用于按照字典顺序比较第一个字符串是否小于第二个。    换言之，它会判断这两个字符串中哪一个在字典中靠前。</p>
<p>执行程序，得到结果为 <code>1</code> 和    <code>-1</code> 。 虽然函数的参数是一样的， 却得到了不同的结果。    原因很简单，在第一次调用函数 <code>std::strcoll()</code> 时，使用了全局 C 区域设置；    而在第二次调用时，全局区域设置更改为德国文化。 从输出中可以看出，在这两种区域设置中，字符 'ä' 和 'z' 的次序是不同的。</p>
<p>很多 C 函数以及 C++ 流都与区域设置有关。 尽管类 <code>std::string</code>    中的函数是与区域设置独立工作的， 但是以下各节中提到的函数并不是这样。 所以，在本章中还会多次提到区域设置的相关内容。</p>
<hr />
<h2 id="53-字符串算法库-booststringalgorithms"><a class="header" href="#53-字符串算法库-booststringalgorithms">5.3. 字符串算法库 Boost.StringAlgorithms</a></h2>
<p>Boost C++ 字符串算法库 <a href="http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo.html">Boost.StringAlgorithms</a>    提供了很多字符串操作函数。 字符串的类型可以是 <code>std::string</code>，    <code>std::wstring</code> 或任何其他模板类    <code>std::basic_string</code> 的实例。</p>
<p>这些函数分类别在不同的头文件定义。 例如，大小写转换函数定义在文件 <code>boost/algorithm/string/case_conv.hpp</code> 中。 因为    Boost.StringAlgorithms 类中包括超过20个类别和相同数目的头文件， 为了方便起见，头文件 <code>boost/algorithm/string.hpp</code> 包括了所有其他的头文件。    后面所有例子都会使用这个头文件。</p>
<p>正如上节提到的那样， Boost.StringAlgorithms 库中许多函数 都可以接受一个类型为    <code>std::locale</code> 的对象作为附加参数。    而此参数是可选的，如果不设置将使用默认全局区域设置。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 
#include &lt;clocale&gt; 

int main() 
{ 
  std::setlocale(LC_ALL, &quot;German&quot;); 
  std::string s = &quot;Boris Schäling&quot;; 
  std::cout &lt;&lt; boost::algorithm::to_upper_copy(s) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::to_upper_copy(s, std::locale(&quot;German&quot;)) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>函数 <code>boost::algorithm::to_upper_copy()</code> 用于    转换一个字符串为大写形式，自然也有提供相反功能的函数 ——    <code>boost::algorithm::to_lower_copy()</code> 把字符串转换为小写形式。    这两个函数都返回转换过的字符串作为结果。 如果作为参数传入的字符串自身需要被转换为大（小）写形式，可以使用函数    <code>boost::algorithm::to_upper()</code> 或    <code>boost::algorithm::to_lower ()</code>。</p>
<p>上面的例子使用函数 <code>boost::algorithm::to_upper_copy()</code> 把字符串    &quot;Boris Schäling&quot; 转换为大写形式。 第一次调用时使用的是默认全局区域设置， 第二次调用时则明确将区域设置为德国文化。</p>
<p>显然后者的转换是正确的， 因为小写字母 'ä' 对应的大写形式 'Ä' 是存在的。 而在 C 区域设置中， 'ä'    是一个未知字符所以不能转换。 为了能得到正确结果，必须明确传递正确的区域设置参数或者在调用    <code>boost::algorithm::to_upper_copy()</code> 之前改变全局区域设置。</p>
<p>可以注意到，程序使用了定义在头文件 <code>clocale</code>    中的函数 <code>std::setlocale()</code> 为 C 函数进行区域设置， 因为    std::cout 使用 C 函数在屏幕上显示信息。 在设置了正确的区域后，才可以正确显示 'ä' 和 'Ä'    等元音字母。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  std::cout &lt;&lt; boost::algorithm::to_upper_copy(s) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::to_upper_copy(s, std::locale(&quot;German&quot;)) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>上述程序将全局区域设置设为德国文化，这使得对函数    <code>boost::algorithm::to_upper_copy()</code> 的调用 可以将 'ä' 转换为 'Ä'    。</p>
<p>注意到本例并没有调用函数 <code>std::setlocale()</code> 。 使用函数    <code>std::locale::global()</code> 设置全局区域设置后， 也自动进行了 C 区域设置。 实际上，C++    程序几乎总是使用函数 <code>std::locale::global()</code> 进行全局区域设置，    而不是像前面的例子那样使用函数 <code>std::setlocale()</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  std::cout &lt;&lt; boost::algorithm::erase_first_copy(s, &quot;i&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::erase_nth_copy(s, &quot;i&quot;, 0) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::erase_last_copy(s, &quot;i&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::erase_all_copy(s, &quot;i&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::erase_head_copy(s, 5) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::erase_tail_copy(s, 8) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.StringAlgorithms 库提供了几个从字符串中删除单独字母的函数，    可以明确指定在哪里删除，如何删除。例如，可以使用函数    <code>boost::algorithm::erase_all_copy()</code> 从整个字符串中 删除特定的某个字符。    如果只在此字符首次出现时删除，可以使用函数    <code>boost::algorithm::erase_first_copy()</code> 。    如果要在字符串头部或尾部删除若干字符，可以使用函数    <code>boost::algorithm::erase_head_copy()</code> 和    <code>boost::algorithm::erase_tail_copy()</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  boost::iterator_range&lt;std::string::iterator&gt; r = boost::algorithm::find_first(s, &quot;Boris&quot;); 
  std::cout &lt;&lt; r &lt;&lt; std::endl; 
  r = boost::algorithm::find_first(s, &quot;xyz&quot;); 
  std::cout &lt;&lt; r &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.4/main.cpp">下载源代码</a></li>
</ul>
<p>以下各个不同函数 <code>boost::algorithm::find_first()</code>、    <code>boost::algorithm::find_last()</code>、    <code>boost::algorithm::find_nth()</code>、    <code>boost::algorithm::find_head()</code> 以及    <code>boost::algorithm::find_tail()</code> 可以用于在字符串中查找子串。</p>
<p>所有这些函数的共同点是均返回类型为 <code>boost::iterator_range</code> 类    的一对迭代器。 此类起源于 Boost C++ 的 <a href="http://www.boost.org/libs/range/">Boost.Range</a> 库，    它在迭代器的概念上定义了“范围”。 因为操作符 <code>&lt;&lt;</code> 由    <code>boost::iterator_range</code> 类重载而来， 单个搜索算法的结果可以直接写入标准输出流。    以上程序将 <code>Boris</code> 作为第一个结果输出而第二个结果为空字符串。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::vector&lt;std::string&gt; v; 
  v.push_back(&quot;Boris&quot;); 
  v.push_back(&quot;Schäling&quot;); 
  std::cout &lt;&lt; boost::algorithm::join(v, &quot; &quot;) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>函数 <code>boost::algorithm::join()</code> 接受一个字符串的容器 作为第一个参数，    根据第二个参数将这些字符串连接起来。 相应地这个例子会输出 <code>Boris    Schäling</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  std::cout &lt;&lt; boost::algorithm::replace_first_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::replace_nth_copy(s, &quot;B&quot;, 0, &quot;D&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::replace_last_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::replace_all_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::replace_head_copy(s, 5, &quot;Doris&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::replace_tail_copy(s, 8, &quot;Becker&quot;) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.6/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.StringAlgorithms 库不但提供了查找子串或删除字母的函数， 而且提供了使用字符串替代子串的函数，包括    <code>boost::algorithm::replace_first_copy()</code>，    <code>boost::algorithm::replace_nth_copy()</code>，    <code>boost::algorithm::replace_last_copy()</code>，    <code>boost::algorithm::replace_all_copy()</code>，    <code>boost::algorithm::replace_head_copy()</code> 以及    <code>boost::algorithm::replace_tail_copy()</code> 等等。    它们的使用方法同查找和删除函数是差不多一样的，所不同的是还需要 一个替代字符串作为附加参数。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;\t Boris Schäling \t&quot;; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.7/main.cpp">下载源代码</a></li>
</ul>
<p>可以使用修剪函数 <code>boost::algorithm::trim_left_copy()</code>，    <code>boost::algorithm::trim_right_copy()</code> 以及    <code>boost::algorithm::trim_copy()</code> 等自动去除字符串中的空格或者字符串的结束符。    什么字符是空格取决于全局区域设置。</p>
<p>Boost.StringAlgorithms 库的函数可以接受一个附加的谓词参数，以决定函数作用于字符串的哪些字符。    谓词版本的修剪函数相应地被命名为 <code>boost::algorithm::trim_left_copy_if()</code>，    <code>boost::algorithm::trim_right_copy_if()</code> 和    <code>boost::algorithm::trim_copy_if()</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;--Boris Schäling--&quot;; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.8/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序调用了一个辅助函数 <code>boost::algorithm::is_any_of()</code> ，    它用于生成谓词以验证作为参数传入的字符是否在给定的字符串中存在。使用函数 <code>boost::algorithm::is_any_of    后，正如例子中做的那样，修剪字符串的字符被指定为连字符。 ()</code></p>
<p>Boost.StringAlgorithms 类也提供了众多返回通用谓词的辅助函数。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;123456789Boris Schäling123456789&quot;; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
  std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.9/main.cpp">下载源代码</a></li>
</ul>
<p>函数 <code>boost::algorithm::is_digit()</code> 返回的谓词在字符为数字时返回布尔值    <code>true</code>。 检查字符是否为大写或小写的辅助函数分别是    <code>boost::algorithm::is_upper()</code> 和    <code>boost::algorithm::is_lower()</code> 。    所有这些函数都默认使用全局区域设置，除非在参数中指定其他区域设置。</p>
<p>除了检验单独字符的谓词之外， Boost.StringAlgorithms 库还提供了处理字符串的函数。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  std::cout &lt;&lt; boost::algorithm::starts_with(s, &quot;Boris&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::ends_with(s, &quot;Schäling&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::contains(s, &quot;is&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::algorithm::lexicographical_compare(s, &quot;Boris&quot;) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.10/main.cpp">下载源代码</a></li>
</ul>
<p>函数 <code>boost::algorithm::starts_with()</code>、    <code>boost::algorithm::ends_with()</code>、    <code>boost::algorithm::contains()</code> 和    <code>boost::algorithm::lexicographical_compare()</code>    均可以比较两个字符串。</p>
<p>以下介绍一个字符串切割函数。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  std::vector&lt;std::string&gt; v; 
  boost::algorithm::split(v, s, boost::algorithm::is_space()); 
  std::cout &lt;&lt; v.size() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.11/main.cpp">下载源代码</a></li>
</ul>
<p>在给定分界符后，使用函数 <code>boost::algorithm::split()</code>    可以将一个字符串拆分为一个字符串容器。 它需要给定一个谓词作为第三个参数以判断应该在字符串的哪个位置分割。 这个例子使用了辅助函数    <code>boost::algorithm::is_space()</code>    创建一个谓词，在每个空格字符处分割字符串。</p>
<p>本节中许多函数都有忽略字符串大小写的版本， 这些版本一般都有与原函数相似的名称，所相差的只是以 'i'.开头。 例如，与函数    <code>boost::algorithm::erase_all_copy()</code> 相对应的是函数    <code>boost::algorithm::ierase_all_copy()</code>。</p>
<p>最后，值得注意的是类 Boost.StringAlgorithms 中许多函数都支持正则表达式。 以下程序使用函数    <code>boost::algorithm::find_regex()</code> 搜索正则表达式。</p>
<pre><code class="language-c++">#include &lt;boost/algorithm/string.hpp&gt; 
#include &lt;boost/algorithm/string/regex.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  boost::iterator_range&lt;std::string::iterator&gt; r = boost::algorithm::find_regex(s, boost::regex(&quot;\\w\\s\\w&quot;)); 
  std::cout &lt;&lt; r &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.3.12/main.cpp">下载源代码</a></li>
</ul>
<p>为了使用正则表达式，此程序使用了Boost C++ 库中的 <code>boost::regex</code> ，    这将在下一节介绍。</p>
<hr />
<h2 id="54-正则表达式库-boostregex"><a class="header" href="#54-正则表达式库-boostregex">5.4. 正则表达式库 Boost.Regex</a></h2>
<p>Boost C++ 的正则表达式库 <a href="http://www.boost.org/libs/regex/">Boost.Regex</a>    可以应用正则表达式于 C++ 。 正则表达式大大减轻了搜索特定模式字符串的负担，在很多语言中都是强大的功能。 虽然现在 C++ 仍然需要以    Boost C++ 库的形式提供这一功能，但是在将来正则表达式将进入 C++ 标准库。 Boost.Regex 库有望包括在下一版的 C++    标准中。</p>
<p>Boost.Regex 库中两个最重要的类是 <code>boost::regex</code> 和    <code>boost::smatch</code>， 它们都在 <code>boost/regex.hpp</code> 文件中定义。    前者用于定义一个正则表达式，而后者可以保存搜索结果。</p>
<p>以下将要介绍 Boost.Regex 库中提供的三个搜索正则表达式的函数。</p>
<pre><code class="language-c++">#include &lt;boost/regex.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  boost::regex expr(&quot;\\w+\\s\\w+&quot;); 
  std::cout &lt;&lt; boost::regex_match(s, expr) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>函数 <code>boost::regex_match()</code> 用于字符串与正则表达式的比较。    在整个字符串匹配正则表达式时其返回值为 <code>true</code> 。</p>
<p>函数 <code>boost::regex_search()</code> 可用于在字符串中搜索正则表达式。</p>
<pre><code class="language-c++">#include &lt;boost/regex.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;); 
  boost::smatch what; 
  if (boost::regex_search(s, what, expr)) 
  { 
    std::cout &lt;&lt; what[0] &lt;&lt; std::endl; 
    std::cout &lt;&lt; what[1] &lt;&lt; &quot; &quot; &lt;&lt; what[2] &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>函数 <code>boost::regex_search()</code> 可以接受一个类型为    <code>boost::smatch</code> 的引用的参数用于储存结果。 函数    <code>boost::regex_search()</code> 只用于分类的搜索， 本例实际上返回了两个结果，    它们是基于正则表达式的分组。</p>
<p>存储结果的类 <code>boost::smatch</code> 事实上是持有类型为    <code>boost::sub_match</code> 的元素的容器， 可以通过与类    <code>std::vector</code> 相似的界面访问。 例如， 元素可以通过操作符    <code>operator[]()</code> 访问。</p>
<p>另一方面，类 <code>boost::sub_match</code> 将迭代器保存在对应于正则表达式分组的位置。    因为它继承自类 <code>std::pair</code> ，迭代器引用的子串可以使用    first 和 second    访问。如果像上面的例子那样，只把子串写入标准输出流， 那么通过重载操作符 <code>&lt;&lt;</code>    就可以直接做到这一点，那么并不需要访问迭代器。</p>
<p>请注意结果保存在迭代器中而 <code>boost::sub_match</code> 类并不复制它们，    这说明它们只是在被迭代器引用的相关字符串存在时才可以访问。</p>
<p>另外，还需要注意容器 <code>boost::smatch</code>    的第一个元素存储的引用是指向匹配正则表达式的整个字符串的，匹配第一组的第一个子串由索引 1 访问。</p>
<p>Boost.Regex 提供的第三个函数是    <code>boost::regex_replace()</code>。</p>
<pre><code class="language-c++">#include &lt;boost/regex.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot; Boris Schäling &quot;; 
  boost::regex expr(&quot;\\s&quot;); 
  std::string fmt(&quot;_&quot;); 
  std::cout &lt;&lt; boost::regex_replace(s, expr, fmt) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.4.3/main.cpp">下载源代码</a></li>
</ul>
<p>除了待搜索的字符串和正则表达式之外， <code>boost::regex_replace()</code>    函数还需要一个格式参数，它决定了子串、匹配正则表达式的分组如何被替换。如果正则表达式不包含任何分组，相关子串将被用给定的格式一个个地被替换。这样上面程序输出的结果为    <code>_Boris_Schäling_</code> 。 </p>
<p><code>boost::regex_replace()</code>    函数总是在整个字符串中搜索正则表达式，所以这个程序实际上将三处空格都替换为下划线。 </p>
<pre><code class="language-c++">#include &lt;boost/regex.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;); 
  std::string fmt(&quot;\\2 \\1&quot;); 
  std::cout &lt;&lt; boost::regex_replace(s, expr, fmt) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.4.4/main.cpp">下载源代码</a></li>
</ul>
<p>格式参数可以访问由正则表达式分组的子串，这个例子正是使用了这项技术，交换了姓、名的位置，于是结果显示为    <code>Schäling Boris</code> 。 </p>
<p>需要注意的是，对于正则表达式和格式有不同的标准。 这三个函数都可以接受一个额外的参数，用于选择具体的标准。    也可以指定是否以某一具体格式解释特殊字符或者替代匹配正则表达式的整个字符串。</p>
<pre><code class="language-c++">#include &lt;boost/regex.hpp&gt; 
#include &lt;locale&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string s = &quot;Boris Schäling&quot;; 
  boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;); 
  std::string fmt(&quot;\\2 \\1&quot;); 
  std::cout &lt;&lt; boost::regex_replace(s, expr, fmt, boost::regex_constants::format_literal) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.4.5/main.cpp">下载源代码</a></li>
</ul>
<p>此程序将 <code>boost::regex_constants::format_literal</code>    标志作为第四参数传递给函数 <code>boost::regex_replace()</code>    ，从而抑制了格式参数中对特殊字符的处理。 因为整个字符串匹配正则表达式，所以本例中经格式参数替换的到达的输出结果为    <code>\2 \1</code>。 </p>
<p>正如上一节末指出的那样，正则表达式可以和 Boost.StringAlgorithms 库结合使用。它通过 Boost.Regex    库提供函数如 <code>boost::algorithm::find_regex()</code> 、    <code>boost::algorithm::replace_regex()</code> 、    <code>boost::algorithm::erase_regex()</code> 以及    <code>boost::algorithm::split_regex()</code> 等等。由于 Boost.Regex    库很有可能成为即将到来的下一版 C++ 标准的一部分，脱离 Boost.StringAlgorithms 库，熟练地使用正则表达式是个明智的选择。</p>
<hr />
<h2 id="55-词汇分割器库-boosttokenizer"><a class="header" href="#55-词汇分割器库-boosttokenizer">5.5. 词汇分割器库 Boost.Tokenizer</a></h2>
<p><a href="http://www.boost.org/libs/tokenizer/">Boost.Tokenizer</a>    库可以在指定某个字符为分隔符后，遍历字符串的部分表达式。 </p>
<pre><code class="language-c++">#include &lt;boost/tokenizer.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer; 
  std::string s = &quot;Boost C++ libraries&quot;; 
  tokenizer tok(s); 
  for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.5.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.Tokenizer 库在 <code>boost/tokenizer.hpp</code> 文件中定义了模板类    <code>boost::tokenizer</code> ，其模板参数为支持相关表达式的类。 上面的例子中就使用了    <code>boost::char_separator</code>    类作为模板参数，它将空格和标点符号视为分隔符。</p>
<p>词汇分割器必须由类型为 <code>std::string</code> 的字符串初始化。通过使用    <code>begin()</code> 和 <code>end()</code>    方法，词汇分割器可以像容器一样访问。通过使用迭代器，可以得到前述字符串的部分表达式。模板参数的类型决定了如何达到部分表达式。</p>
<p>因为 <code>boost::char_separator</code>    类默认将空格和标点符号视为分隔符，所以本例显示的结果为 <code>Boost</code> 、    <code>C</code> 、 <code>+</code> 、    <code>+</code> 和    <code>libraries</code> 。 为了识别这些分隔符，    <code>boost::char_separator</code> 函数调用了    <code>std::isspace()</code> 函数和 <code>std::ispunct 函数。    ()</code>Boost.Tokenizer 库会区分要隐藏的分隔符和要显示的分隔符。    在默认的情况下，空格会隐藏而标点符号会显示出来，所以这个例子里显示了两个加号。 </p>
<p>如果不需要将标点符号作为分隔符，可以在传递给词汇分割器之前相应地初始化    <code>boost::char_separator</code> 对象。 以下例子正式这样做的。 </p>
<pre><code class="language-c++">#include &lt;boost/tokenizer.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer; 
  std::string s = &quot;Boost C++ libraries&quot;; 
  boost::char_separator&lt;char&gt; sep(&quot; &quot;); 
  tokenizer tok(s, sep); 
  for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.5.2/main.cpp">下载源代码</a></li>
</ul>
<p>类 <code>boost::char_separator</code> 的构造函数可以接受三个参数，    只有第一个是必须的，它描述了需要隐藏的分隔符。 在本例中， 空格仍然被视为分隔符。</p>
<p>第二个参数指定了需要显示的分隔符。 在不提供此参数的情况下，将不显示任何分隔符。 执行程序，会显示    <code>Boost</code> 、    <code>C++</code> 和    <code>libraries</code> 。 </p>
<p>如果将加号作为第二个参数，此例的结果将和上一个例子相同。 </p>
<pre><code class="language-c++">#include &lt;boost/tokenizer.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer; 
  std::string s = &quot;Boost C++ libraries&quot;; 
  boost::char_separator&lt;char&gt; sep(&quot; &quot;, &quot;+&quot;); 
  tokenizer tok(s, sep); 
  for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.5.3/main.cpp">下载源代码</a></li>
</ul>
<p>第三个参数决定了是否显示空的部分表达式。    如果连续找到两个分隔符，他们之间的部分表达式将为空。在默认情况下，这些空表达式是不会显示的。第三个参数可以改变默认的行为。</p>
<pre><code class="language-c++">#include &lt;boost/tokenizer.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer; 
  std::string s = &quot;Boost C++ libraries&quot;; 
  boost::char_separator&lt;char&gt; sep(&quot; &quot;, &quot;+&quot;, boost::keep_empty_tokens); 
  tokenizer tok(s, sep); 
  for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.5.4/main.cpp">下载源代码</a></li>
</ul>
<p>执行以上程序，会显示另外两个的空表达式。 其中第一个是在两个加号中间的而第二个是加号和之后的空格之间的。</p>
<p>词汇分割器也可用于不同的字符串类型。 </p>
<pre><code class="language-c++">#include &lt;boost/tokenizer.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tokenizer&lt;boost::char_separator&lt;wchar_t&gt;, std::wstring::const_iterator, std::wstring&gt; tokenizer; 
  std::wstring s = L&quot;Boost C++ libraries&quot;; 
  boost::char_separator&lt;wchar_t&gt; sep(L&quot; &quot;); 
  tokenizer tok(s, sep); 
  for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it) 
    std::wcout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.5.5/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子遍历了一个类型为 <code>std::wstring</code> 的字符串。    为了使用这个类型的字符串，必须使用另外的模板参数初始化词汇分割器，对    <code>boost::char_separator</code> 类也是如此，他们都需要参数    <code>wchar_t</code> 初始化。 </p>
<p>除了 <code>boost::char_separator</code> 类之外， Boost.Tokenizer    还提供了另外两个类以识别部分表达式。 </p>
<pre><code class="language-c++">#include &lt;boost/tokenizer.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tokenizer&lt;boost::escaped_list_separator&lt;char&gt; &gt; tokenizer; 
  std::string s = &quot;Boost,\&quot;C++ libraries\&quot;&quot;; 
  tokenizer tok(s); 
  for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.5.6/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::escaped_list_separator</code>    类用于读取由逗号分隔的多个值，这个格式的文件通常称为 CSV （comma separated    values，逗号分隔文件），它甚至还可以处理双引号以及转义序列。所以本例的输出为    <code>Boost</code> 和 <code>C++    libraries</code> 。 </p>
<p>另一个是 <code>boost::offset_separator</code> 类，必须用实例说明。    这个类的对象必须作为第二个参数传递给 <code>boost::tokenizer</code> 类的构造函数。 </p>
<pre><code class="language-c++">#include &lt;boost/tokenizer.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tokenizer&lt;boost::offset_separator&gt; tokenizer; 
  std::string s = &quot;Boost C++ libraries&quot;; 
  int offsets[] = { 5, 5, 9 }; 
  boost::offset_separator sep(offsets, offsets + 3); 
  tokenizer tok(s, sep); 
  for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.5.7/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::offset_separator</code>    指定了部分表达式应当在字符串中的哪个位置结束。 以上程序制定第一个部分表达式在 5 个字符后结束，第二个字符串在另 5    个字符后结束，第三个也就是最后一个字符串应当在之后的 9 个字符后结束。 输出的结果为    <code>Boost</code> 、    <code>C++</code> 和    <code>libraries</code> 。 </p>
<hr />
<h2 id="56-格式化输出库-boostformat"><a class="header" href="#56-格式化输出库-boostformat">5.6. 格式化输出库 Boost.Format</a></h2>
<p><a href="http://www.boost.org/libs/format/">Boost.Format</a>    库可以作为定义在文件 <code>cstdio</code> 中的函数    <code>std::printf()</code> 的替代。 <code>std::printf()</code>    函数最初出现在 C 标准中，提供格式化数据输出功能， 但是它既不是类型安全的有不能扩展。 因此在 C++ 应用中， Boost.Format    库通常是数据格式化输出的上佳之选。</p>
<p>Boost.Format 库在文件 <code>boost/format.hpp</code> 中定义了类    <code>boost::format</code> 。 与函数 <code>std::printf    相似的是，传递给()</code> <code>boost::format</code>    的构造函数的参数也是一个字符串，它由控制格式的特殊字符组成。 实际数据通过操作符 % 相连，在输出中替代特殊字符，如下例所示。</p>
<pre><code class="language-c++">#include &lt;boost/format.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::format(&quot;%1%.%2%.%3%&quot;) % 16 % 9 % 2008 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.6.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.Format 类使用置于两个百分号之间的数字作为占位符，占位符稍后通过 % 操作符与实际数据连接。 以上程序使用数字16、9    和 2009 组成一个日期字符串，以 <code>16.9.2008</code>的格式输出。    如果要月份出现在日期之前，即美式表示，只需交换占位符即可。</p>
<pre><code class="language-c++">#include &lt;boost/format.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::format(&quot;%2%/%1%/%3%&quot;) % 16 % 9 % 2008 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.6.2/main.cpp">下载源代码</a></li>
</ul>
<p>现在程序显示的结果变成 <code>9/16/2008</code> 。</p>
<p>如果要使用C++ 操作器格式化数据，Boost.Format 库提供了函数    <code>boost::io::group()</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/format.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::format(&quot;%1% %2% %1%&quot;) % boost::io::group(std::showpos, 99) % 100 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.6.3/main.cpp">下载源代码</a></li>
</ul>
<p>本例的结果显示为 <code>+99 100 +99</code> 。 因为操作器    <code>std::showpos()</code> 通过 <code>boost::io::group()</code>    与数字 99 连接，所以只要显示 99 ， 在它前面就会自动加上加号。</p>
<p>如果需要加号仅在 99 第一次输出时显示， 则需要改造格式化占位符。</p>
<pre><code class="language-c++">#include &lt;boost/format.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::format(&quot;%|1$+| %2% %1%&quot;) % 99 % 100 &lt;&lt; std::endl; 
} 
</code></pre>
<p>为了将输出格式改为 <code>+99 100 99</code> ，不但需要将数据的引用符号由    1$ 变为 1% ，还需要在其两侧各添加一个附加的管道符号，即将占位符 %1% 替换为 %|1$+|。</p>
<p>请注意，虽然一般对数据的引用不是必须的，但是所有占位符一定要同时设置为指定货非指定。    以下例子在执行时会出现错误，因为它给第二个和第三个占位符设置了引用但是却忽略了第一个。</p>
<pre><code class="language-c++">#include &lt;boost/format.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    std::cout &lt;&lt; boost::format(&quot;%|+| %2% %1%&quot;) % 99 % 100 &lt;&lt; std::endl; 
  } 
  catch (boost::io::format_error &amp;ex) 
  { 
    std::cout &lt;&lt; ex.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.6.5/main.cpp">下载源代码</a></li>
</ul>
<p>此程序抛出了类型为 <code>boost::io::format_error</code>    的异常。 严格地说，Boost.Format 库抛出的异常为    <code>boost::io::bad_format_string</code>。    但是由于所有的异常类都继承自 <code>boost::io::format_error</code>    类，捕捉此类型的异常会轻松一些。</p>
<p>以下例子演示了不引用数据的方法。</p>
<pre><code class="language-c++">#include &lt;boost/format.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::format(&quot;%|+| %|| %||&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.6.6/main.cpp">下载源代码</a></li>
</ul>
<p>第二、第三个占位符的管道符号可以被安全地省略，因为在这种情况下，他们并不指定格式。这样的语法看起来很像    <code>std::printf ()</code>的那种。</p>
<pre><code class="language-c++">#include &lt;boost/format.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::format(&quot;%+d %d %d&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.6.7/main.cpp">下载源代码</a></li>
</ul>
<p>虽然这看起来就像 <code>std::printf()</code> ，但是 Boost.Format    库有类型安全的优点。 格式化字符串中字母 'd' 的使用并不表示输出数字，而是表示    <code>boost::format</code> 类所使用的内部流对象上的    <code>std::dec()</code> 操作器，它可以使用某些对    <code>std::printf()</code> 函数无意义的格式字符串，如果使用    <code>std::printf()</code> 会导致程序在运行时崩溃。</p>
<pre><code class="language-c++">#include &lt;boost/format.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::format(&quot;%+s %s %s&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/5.6.8/main.cpp">下载源代码</a></li>
</ul>
<p>尽管在 <code>std::printf()</code> 函数中，字母 's' 只用于表示类型为 <code>const    char*</code> 的字符串，然而以上程序却能正常运行。 因为在 Boost.Format    库中，这并不代表强制为字符串，它会结合适当的操作器，调整内部流的操作模式。 所以即使在这种情况下， 在内部流中加入数字也是没问题的。</p>
<hr />
<h2 id="57-练习"><a class="header" href="#57-练习">5.7. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>
<p>编写程序，从以下 XML 流中提取并显示数据，包括姓名、生日以及账户余额。        <strong><code>&lt;person&gt;&lt;name&gt;Karl-Heinz        Huber&lt;/name&gt;&lt;dob&gt;1970-9-30&lt;/dob&gt;&lt;account&gt;2,900.64        USD&lt;/account&gt;&lt;/person&gt;</code></strong>。</p>
<p>姓、名要分开显示，生日使用 “日.月.年” 的格式，账户余额忽略小数位。 使用其他 XML        流测试你的程序，如包含多余空白、其他名字、账户余额为负数等等的 XML 流。</p>
</li>
<li>
<p>编写程序，使得格式与显示的数据记录如下：输入 <strong><code>Munich Hamburg 92.12 8:25        9:45</code></strong>， 这条记录表示从 Munich 到 Hamburg 的航班票价为 92.12 欧元，上午 8:25 起飞        9:45 到达目的地。要得到以下输出 <code>Munich  -&gt; Hamburg   92.12        EUR (08:25-09:45)</code>。</p>
<p>具体地说，城市名称长度为10并且左对齐而票价长度为7并且右对齐，货币在价格后显示。        起飞与降落时间一起显示在圆括号中，以连字符分隔，不留空格。对早于10点（上午或下午）的时间，必须在前面补0。        用不同的数据记录测试你的程序，例如使用长度大于10的城市名。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-6-章-多线程"><a class="header" href="#第-6-章-多线程">第 6 章 多线程</a></h1>
<h2 id="61-概述"><a class="header" href="#61-概述">6.1. 概述</a></h2>
<p>线程就是，在同一程序同一时间内允许执行不同函数的离散处理队列。    这使得一个长时间去进行某种特殊运算的函数在执行时不阻碍其他的函数变得十分重要。    线程实际上允许同时执行两种函数，而这两个函数不必相互等待。</p>
<p>一旦一个应用程序启动，它仅包含一个默认线程。 此线程执行 <code>main()</code> 函数。 在    <code>main()</code>中被调用的函数则按这个线程的上下文顺序地执行。 这样的程序称为单线程程序。</p>
<p>反之，那些创建新的线程的程序就是多线程程序。 他们不仅可以在同一时间执行多个函数，而且这在如今多核盛行的时代显得尤为重要。    既然多核允许同时执行多个函数，这就使得对开发人员相应地使用这种处理能力提出了要求。    然而线程一直被用来当并发地执行多个函数，开发人员现在不得不仔细地构建应用来支持这种并发。    多线程编程知识也因此在多核系统时代变得越来越重要。</p>
<p>本章将介绍C++ Boost库 <a href="http://www.boost.org/libs/thread/">Boost.Thread</a>，它可以开发独立于平台的多线程应用程序。</p>
<hr />
<h2 id="62-线程管理"><a class="header" href="#62-线程管理">6.2. 线程管理</a></h2>
<p>在这个库最重要的一个类就是 <code>boost::thread</code>，它是在 <code>boost/thread.hpp</code>    里定义的，用来创建一个新线程。下面的示例来说明如何运用它。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
  boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
  for (int i = 0; i &lt; 5; ++i) 
  { 
    wait(1); 
    std::cout &lt;&lt; i &lt;&lt; std::endl; 
  } 
} 

int main() 
{ 
  boost::thread t(thread); 
  t.join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>新建线程里执行的那个函数的名称被传递到 <code>boost::thread</code> 的构造函数。    一旦上述示例中的变量 t 被创建，该 <code>thread()</code>    函数就在其所在线程中被立即执行。 同时在 <code>main()</code> 里也并发地执行该    <code>thread()</code> 。</p>
<p>为了防止程序终止，就需要对新建线程调用 <code>join()</code> 方法。    <code>join()</code> 方法是一个阻塞调用：它可以暂停当前线程，直到调用    <code>join()</code> 的线程运行结束。 这就使得 <code>main()</code>    函数一直会等待到 <code>thread()</code> 运行结束。</p>
<p>正如在上面的例子中看到，一个特定的线程可以通过诸如 t 的变量访问，通过这个变量等待着它的使用    <code>join()</code> 方法终止。 但是，即使 t    越界或者析构了，该线程也将继续执行。 一个线程总是在一开始就绑定到一个类型为    <code>boost::thread</code> 的变量，但是一旦创建，就不在取决于它。 甚至还存在着一个叫    <code>detach()</code> 的方法，允许类型为    <code>boost::thread</code> 的变量从它对应的线程里分离。 当然了，像    <code>join()</code> 的方法之后也就不能被调用，因为这个变量不再是一个有效的线程。</p>
<p>任何一个函数内可以做的事情也可以在一个线程内完成。 归根结底，一个线程只不过是一个函数，除了它是同时执行的。    在上述例子中，使用一个循环把5个数字写入标准输出流。 为了减缓输出，每一个循环中调用 <code>wait()</code>    函数让执行延迟了一秒。 <code>wait()</code> 可以调用一个名为 <code>sleep()</code>    的函数，这个函数也来自于 Boost.Thread，位于 <code>boost::this_thread</code> 名空间内。</p>
<p><code>sleep()</code> 要么在预计的一段时间或一个特定的时间点后时才让线程继续执行。 通过传递一个类型为    <code>boost::posix_time::seconds</code> 的对象，在这个例子里我们指定了一段时间。    <code>boost::posix_time::seconds</code> 来自于 Boost.DateTime 库，它被    Boost.Thread 用来管理和处理时间的数据。</p>
<p>虽然前面的例子说明了如何等待一个不同的线程，但下面的例子演示了如何通过所谓的中断点让一个线程中断。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
  boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
  try 
  { 
    for (int i = 0; i &lt; 5; ++i) 
    { 
      wait(1); 
      std::cout &lt;&lt; i &lt;&lt; std::endl; 
    } 
  } 
  catch (boost::thread_interrupted&amp;) 
  { 
  } 
} 

int main() 
{ 
  boost::thread t(thread); 
  wait(3); 
  t.interrupt(); 
  t.join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>在一个线程对象上调用 <code>interrupt()</code> 会中断相应的线程。    在这方面，中断意味着一个类型为 <code>boost::thread_interrupted</code>    的异常，它会在这个线程中抛出。 然后这只有在线程达到中断点时才会发生。</p>
<p>如果给定的线程不包含任何中断点，简单调用 <code>interrupt()</code> 就不会起作用。    每当一个线程中断点，它就会检查 <code>interrupt()</code> 是否被调用过。 只有被调用过了，    <code>boost::thread_interrupted</code> 异常才会相应地抛出。</p>
<p>Boost.Thread定义了一系列的中断点，例如 <code>sleep()</code> 函数。 由于    <code>sleep()</code> 在这个例子里被调用了五次，该线程就检查了五次它是否应该被中断。 然而    <code>sleep()</code> 之间的调用，却不能使线程中断。</p>
<p>一旦该程序被执行，它只会打印三个数字到标准输出流。 这是由于在main里3秒后调用    <code>interrupt()</code>方法。 因此，相应的线程被中断，并抛出一个    <code>boost::thread_interrupted</code> 异常。 这个异常在线程内也被正确地捕获，    <code>catch</code> 处理虽然是空的。 由于 <code>thread()</code>    函数在处理程序后返回，线程也被终止。 这反过来也将终止整个程序，因为 <code>main()</code>    等待该线程使用join（）终止该线程。</p>
<p>Boost.Thread定义包括上述 <code>sleep()</code>函数十个中断。    有了这些中断点，线程可以很容易及时中断。 然而，他们并不总是最佳的选择，因为中断点必须事前读入以检查    <code>boost::thread_interrupted</code> 异常。</p>
<p>为了提供一个对 Boost.Thread 里提供的多种函数的整体概述，下面的例子将会再介绍两个。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::thread::hardware_concurrency() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>使用 <code>boost::this_thread</code>命名空间，能提供独立的函数应用于当前线程，比如前面出现的    <code>sleep()</code> 。 另一个是    <code>get_id()</code>：它会返回一个当前线程的ID号。 它也是由    <code>boost::thread</code> 提供的。</p>
<p><code>boost::thread</code> 类提供了一个静态方法    <code>hardware_concurrency()</code>    ，它能够返回基于CPU数目或者CPU内核数目的刻在同时在物理机器上运行的线程数。 在常用的双核机器上调用这个方法，返回值为2。    这样的话就可以确定在一个多核程序可以同时运行的理论最大线程数。</p>
<hr />
<h2 id="63-同步"><a class="header" href="#63-同步">6.3. 同步</a></h2>
<p>虽然多线程的使用可以提高应用程序的性能，但也增加了复杂性。 如果使用线程在同一时间执行几个函数，访问共享资源时必须相应地同步。    一旦应用达到了一定规模，这涉及相当一些工作。 本段介绍了Boost.Thread提供同步线程的类。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
  boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

boost::mutex mutex; 

void thread() 
{ 
  for (int i = 0; i &lt; 5; ++i) 
  { 
    wait(1); 
    mutex.lock(); 
    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; 
    mutex.unlock(); 
  } 
} 

int main() 
{ 
  boost::thread t1(thread); 
  boost::thread t2(thread); 
  t1.join(); 
  t2.join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>多线程程序使用所谓的互斥对象来同步。    Boost.Thread提供多个的互斥类，<code>boost::mutex</code>是最简单的一个。    互斥的基本原则是当一个特定的线程拥有资源的时候防止其他线程夺取其所有权。 一旦释放，其他的线程可以取得所有权。    这将导致线程等待至另一个线程完成处理一些操作，从而相应地释放互斥对象的所有权。</p>
<p>上面的示例使用一个类型为 <code>boost::mutex</code> 的    mutex 全局互斥对象。 <code>thread()</code> 函数获取此对象的所有权才在    <code>for</code> 循环内使用 <code>lock()</code> 方法写入到标准输出流的。    一旦信息被写入，使用 <code>unlock()</code> 方法释放所有权。</p>
<p><code>main()</code> 创建两个线程，同时执行 <code>thread    ()</code>函数。 利用<code> for</code> 循环，每个线程数到5，用一个迭代器写一条消息到标准输出流。    不幸的是，标准输出流是一个全局性的被所有线程共享的对象。 该标准不提供任何保证 std::cout    可以安全地从多个线程访问。 因此，访问标准输出流必须同步：在任何时候，只有一个线程可以访问    std::cout。</p>
<p>由于两个线程试图在写入标准输出流前获得互斥体，实际上只能保证一次只有一个线程访问    std::cout。 不管哪个线程成功调用 <code>lock()</code>    方法，其他所有线程必须等待，直到 <code>unlock()</code> 被调用。</p>
<p>获取和释放互斥体是一个典型的模式，是由Boost.Thread通过不同的数据类型支持。 例如，不直接地调用    <code>lock()</code> 和 <code>unlock()</code>，使用    <code>boost::lock_guard</code> 类也是可以的。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
  boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

boost::mutex mutex; 

void thread() 
{ 
  for (int i = 0; i &lt; 5; ++i) 
  { 
    wait(1); 
    boost::lock_guard&lt;boost::mutex&gt; lock(mutex); 
    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; 
  } 
} 

int main() 
{ 
  boost::thread t1(thread); 
  boost::thread t2(thread); 
  t1.join(); 
  t2.join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.3.2/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::lock_guard</code> 在其内部构造和析构函数分别自动调用    <code>lock()</code> 和 <code>unlock()</code> 。    访问共享资源是需要同步的，因为它显示地被两个方法调用。 <code>boost::lock_guard</code>    类是另一个出现在 <a href="./smartpointers.html">第 2 章 <em>智能指针</em></a> 的RAII用语。</p>
<p>除了<code>boost::mutex</code> 和    <code>boost::lock_guard</code> 之外，Boost.Thread也提供其他的类支持各种同步。    其中一个重要的就是 <code>boost::unique_lock</code> ，相比较<code>   boost::lock_guard</code>而言，它提供许多有用的方法。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
  boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

boost::timed_mutex mutex; 

void thread() 
{ 
  for (int i = 0; i &lt; 5; ++i) 
  { 
    wait(1); 
    boost::unique_lock&lt;boost::timed_mutex&gt; lock(mutex, boost::try_to_lock); 
    if (!lock.owns_lock()) 
      lock.timed_lock(boost::get_system_time() + boost::posix_time::seconds(1)); 
    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; 
    boost::timed_mutex *m = lock.release(); 
    m-&gt;unlock(); 
  } 
} 

int main() 
{ 
  boost::thread t1(thread); 
  boost::thread t2(thread); 
  t1.join(); 
  t2.join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子用不同的方法来演示 <code>boost::unique_lock</code> 的功能。    当然了，这些功能的用法对给定的情景不一定适用；<code>boost::lock_guard</code>    在上个例子的用法还是挺合理的。 这个例子就是为了演示 <code>boost::unique_lock</code>    提供的功能。</p>
<p><code>boost::unique_lock</code> 通过多个构造函数来提供不同的方式获得互斥体。    这个期望获得互斥体的函数简单地调用了 <code>lock()</code> 方法，一直等到获得这个互斥体。 所以它的行为跟    <code>boost::lock_guard</code> 的那个是一样的。</p>
<p>如果第二个参数传入一个 <code>boost::try_to_lock</code> 类型的值，对应的构造函数就会调用    <code>try_lock()</code> 方法。 这个方法返回 <code>bool</code>    型的值：如果能够获得互斥体则返回<code>true</code>，否则返回 <code>false</code> 。 相比    <code>lock()</code> 函数，<code>try_lock()</code>    会立即返回，而且在获得互斥体之前不会被阻塞。</p>
<p>上面的程序向 <code>boost::unique_lock</code>    的构造函数的第二个参数传入boost::try_to_lock。 然后通过    <code>owns_lock()</code> 可以检查是否可获得互斥体。 如果不能，    <code>owns_lock()</code> 返回 <code>false</code>。 这也用到    <code>boost::unique_lock</code> 提供的另外一个函数：    <code>timed_lock()</code> 等待一定的时间以获得互斥体。    给定的程序等待长达1秒，应较足够的时间来获取更多的互斥。</p>
<p>其实这个例子显示了三个方法获取一个互斥体：<code>lock()</code> 会一直等待，直到获得一个互斥体。    <code>try_lock()</code> 则不会等待，但如果它只会在互斥体可用的时候才能获得，否则返回    <code>false</code> 。 最后，<code>timed_lock()</code>    试图获得在一定的时间内获取互斥体。 和 <code>try_lock()</code>    一样，返回<code>bool</code> 类型的值意味着成功是否。</p>
<p>虽然 <code>boost::mutex</code> 提供了    <code>lock()</code> 和 <code>try_lock()</code> 两个方法，但是    <code>boost::timed_mutex</code> 只支持    <code>timed_lock()</code> ，这就是上面示例那么使用的原因。 如果不用    <code>timed_lock()</code> 的话，也可以像以前的例子那样用    <code>boost::mutex</code>。</p>
<p>就像 <code>boost::lock_guard</code> 一样，    <code>boost::unique_lock</code> 的析构函数也会相应地释放互斥量。此外，可以手动地用    <code>unlock()</code> 释放互斥量。也可以像上面的例子那样，通过调用    <code>release()</code>    解除<code>boost::unique_lock</code> 和互斥量之间的关联。然而在这种情况下，必须显式地调用    <code>unlock()</code> 方法来释放互斥量，因为    <code>boost::unique_lock</code> 的析构函数不再做这件事情。</p>
<p><code>boost::unique_lock</code>    这个所谓的独占锁意味着一个互斥量同时只能被一个线程获取。 其他线程必须等待，直到互斥体再次被释放。 除了独占锁，还有非独占锁。    Boost.Thread里有个<code> boost::shared_lock</code> 的类提供了非独占锁。    正如下面的例子，这个类必须和 <code>boost::shared_mutex</code>    型的互斥量一起使用。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;cstdlib&gt; 
#include &lt;ctime&gt; 

void wait(int seconds) 
{ 
  boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

boost::shared_mutex mutex; 
std::vector&lt;int&gt; random_numbers; 

void fill() 
{ 
  std::srand(static_cast&lt;unsigned int&gt;(std::time(0))); 
  for (int i = 0; i &lt; 3; ++i) 
  { 
    boost::unique_lock&lt;boost::shared_mutex&gt; lock(mutex); 
    random_numbers.push_back(std::rand()); 
    lock.unlock(); 
    wait(1); 
  } 
} 

void print() 
{ 
  for (int i = 0; i &lt; 3; ++i) 
  { 
    wait(1); 
    boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex); 
    std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl; 
  } 
} 

int sum = 0; 

void count() 
{ 
  for (int i = 0; i &lt; 3; ++i) 
  { 
    wait(1); 
    boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex); 
    sum += random_numbers.back(); 
  } 
} 

int main() 
{ 
  boost::thread t1(fill); 
  boost::thread t2(print); 
  boost::thread t3(count); 
  t1.join(); 
  t2.join(); 
  t3.join(); 
  std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.3.4/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::shared_lock</code>    类型的非独占锁可以在线程只对某个资源读访问的情况下使用。 一个线程修改的资源需要写访问，因此需要一个独占锁。    这样做也很明显：只需要读访问的线程不需要知道同一时间其他线程是否访问。 因此非独占锁可以共享一个互斥体。</p>
<p>在给定的例子， <code>print()</code> 和 <code>count()</code>    都可以只读访问 random_numbers 。 虽然 <code>print()</code>    函数把 random_numbers    里的最后一个数写到标准输出，<code>count()</code> 函数把它统计到 sum    变量。 由于没有函数修改 random_numbers，所有的都可以在同一时间用    <code>boost::shared_lock</code> 类型的非独占锁访问它。</p>
<p>在 <code>fill()</code> 函数里，需要用一个    <code>boost::unique_lock</code> 类型的非独占锁，因为它插入了一个新的随机数到    random_numbers。 在 <code>unlock()</code> 显式地调用    <code>unlock()</code> 来释放互斥量之后， <code>fill()</code> 等待了一秒。    相比于之前的那个样子， 在 <code>for</code> 循环的尾部调用 <code>wait()</code>    以保证容器里至少存在一个随机数，可以被<code>print()</code> 或者    <code>count()</code> 访问。 对应地，这两个函数在 <code>for</code> 循环的开始调用了    <code>wait()</code> 。</p>
<p>考虑到在不同的地方每个单独地调用 <code>wait()</code>    ，一个潜在的问题变得很明显:函数调用的顺序直接受CPU执行每个独立进程的顺序决定。    利用所谓的条件变量，可以同步哪些独立的线程，使数组的每个元素都被不同的线程立即添加到    random_numbers 。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;cstdlib&gt; 
#include &lt;ctime&gt; 

boost::mutex mutex; 
boost::condition_variable_any cond; 
std::vector&lt;int&gt; random_numbers; 

void fill() 
{ 
  std::srand(static_cast&lt;unsigned int&gt;(std::time(0))); 
  for (int i = 0; i &lt; 3; ++i) 
  { 
    boost::unique_lock&lt;boost::mutex&gt; lock(mutex); 
    random_numbers.push_back(std::rand()); 
    cond.notify_all(); 
    cond.wait(mutex); 
  } 
} 

void print() 
{ 
  std::size_t next_size = 1; 
  for (int i = 0; i &lt; 3; ++i) 
  { 
    boost::unique_lock&lt;boost::mutex&gt; lock(mutex); 
    while (random_numbers.size() != next_size) 
      cond.wait(mutex); 
    std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl; 
    ++next_size; 
    cond.notify_all(); 
  } 
} 

int main() 
{ 
  boost::thread t1(fill); 
  boost::thread t2(print); 
  t1.join(); 
  t2.join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子的程序删除了 <code>wait()</code> 和 <code>count()</code>    。线程不用在每个循环迭代中等待一秒，而是尽可能快地执行。此外，没有计算总额；数字完全写入标准输出流。</p>
<p>为确保正确地处理随机数，需要一个允许检查多个线程之间特定条件的条件变量来同步不每个独立的线程。</p>
<p>正如上面所说， <code>fill()</code> 函数用在每个迭代产生一个随机数，然后放在    random_numbers 容器中。 为了防止其他线程同时访问这个容器，就要相应得使用一个排它锁。    不是等待一秒，实际上这个例子却用了一个条件变量。 调用 <code>notify_all()</code>    会唤醒每个哪些正在分别通过调用<code>wait()</code> 等待此通知的线程。</p>
<p>通过查看 <code>print()</code> 函数里的 <code>for</code>    循环，可以看到相同的条件变量被 <code>wait()</code> 函数调用了。 如果这个线程被    <code>notify_all()</code> 唤醒，它就会试图这个互斥量，但只有在    <code>fill()</code> 函数完全释放之后才能成功。</p>
<p>这里的窍门就是调用 <code>wait()</code> 会释放相应的被参数传入的互斥量。 在调用    <code>notify_all()</code>后， <code>fill()</code> 函数会通过    <code>wait()</code> 相应地释放线程。 然后它会阻止和等待其他的线程调用    <code>notify_all()</code> ，一旦随机数已写入标准输出流，这就会在    <code>print()</code> 里发生。</p>
<p>注意到在 <code>print()</code> 函数里调用 <code>wait()</code>    事实上发生在一个单独 <code>while</code> 循环里。 这样做的目的是为了处理在 <code>print()</code>    函数里第一次调用 <code>wait()</code> 函数之前随机数已经放到容器里。 通过比较    random_numbers 里元素的数目与预期值，发现这成功地处理了把随机数写入到标准输出流。</p>
<hr />
<h2 id="64-线程本地存储"><a class="header" href="#64-线程本地存储">6.4. 线程本地存储</a></h2>
<p>线程本地存储（TLS）是一个只能由一个线程访问的专门的存储区域。    TLS的变量可以被看作是一个只对某个特定线程而非整个程序可见的全局变量。 下面的例子显示了这些变量的好处。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;ctime&gt; 

void init_number_generator() 
{ 
  static bool done = false; 
  if (!done) 
  { 
    done = true; 
    std::srand(static_cast&lt;unsigned int&gt;(std::time(0))); 
  } 
} 

boost::mutex mutex; 

void random_number_generator() 
{ 
  init_number_generator(); 
  int i = std::rand(); 
  boost::lock_guard&lt;boost::mutex&gt; lock(mutex); 
  std::cout &lt;&lt; i &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::thread t[3]; 

  for (int i = 0; i &lt; 3; ++i) 
    t[i] = boost::thread(random_number_generator); 

  for (int i = 0; i &lt; 3; ++i) 
    t[i].join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>该示例创建三个线程，每个线程写一个随机数到标准输出流。    <code>random_number_generator()</code> 函数将会利用在C++标准里定义的    <code>std::rand()</code> 函数创建一个随机数。 但是用于    <code>std::rand()</code> 的随机数产生器必须先用 <code>std::srand()</code>    正确地初始化。 如果没做，程序始终打印同一个随机数。</p>
<p>随机数产生器，通过 <code>std::time()</code> 返回当前时间， 在    <code>init_number_generator()</code> 函数里完成初始化。    由于这个值每次都不同，可以保证产生器总是用不同的值初始化，从而产生不同的随机数。 因为产生器只要初始化一次，    <code>init_number_generator()</code> 用了一个静态变量    done 作为条件量。</p>
<p>如果程序运行了多次，写入的三分之二的随机数显然就会相同。    事实上这个程序有个缺陷：<code>std::rand()</code> 所用的产生器必须被各个线程初始化。 因此    <code>init_number_generator()</code> 的实现实际上是不对的，因为它只调用了一次    <code>std::srand()</code> 。使用TLS，这一缺陷可以得到纠正。</p>
<pre><code class="language-c++">#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;ctime&gt; 

void init_number_generator() 
{ 
  static boost::thread_specific_ptr&lt;bool&gt; tls; 
  if (!tls.get()) 
    tls.reset(new bool(false)); 
  if (!*tls) 
  { 
    *tls = true; 
    std::srand(static_cast&lt;unsigned int&gt;(std::time(0))); 
  } 
} 

boost::mutex mutex; 

void random_number_generator() 
{ 
  init_number_generator(); 
  int i = std::rand(); 
  boost::lock_guard&lt;boost::mutex&gt; lock(mutex); 
  std::cout &lt;&lt; i &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::thread t[3]; 

  for (int i = 0; i &lt; 3; ++i) 
    t[i] = boost::thread(random_number_generator); 

  for (int i = 0; i &lt; 3; ++i) 
    t[i].join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>用一个TLS变量 tls 代替静态变量 done，是基于用    <code>bool</code> 类型实例化的 <code>boost::thread_specific_ptr</code>    。 原则上， tls 工作起来就像 done    ：它可以作为一个条件指明随机数发生器是否被初始化。 但是关键的区别，就是 tls    存储的值只对相应的线程可见和可用。</p>
<p>一旦一个 <code>boost::thread_specific_ptr</code>    型的变量被创建，它可以相应地设置。 不过，它期望得到一个 <code>bool</code> 型变量的地址，而非它本身。使用    <code>reset()</code> 方法，可以把它的地址保存到 tls 里面。    在给出的例子中，会动态地分配一个 <code>bool</code> 型的变量，由 <code>new</code> 返回它的地址，并保存到    tls 里。 为了避免每次调用    <code>init_number_generator()</code> 都设置 tls    ，它会通过 <code>get()</code> 函数检查是否已经保存了一个地址。</p>
<p>由于 <code>boost::thread_specific_ptr</code>    保存了一个地址，它的行为就像一个普通的指针。 因此，<code>operator*()</code> 和    <code>operator-&gt;()</code> 都被被重载以方便使用。 这个例子用 <code>*tls</code>    检查这个条件当前是 <code>true</code> 还是 <code>false</code>。    再根据当前的条件，随机数生成器决定是否初始化。</p>
<p>正如所见， <code>boost::thread_specific_ptr</code>    允许为当前进程保存一个对象的地址，然后只允许当前进程获得这个地址。 然而，当一个线程已经成功保存这个地址，其他的线程就会可能就失败。</p>
<p>如果程序正在执行时，它可能会令人感到奇怪：尽管有了TLS的变量，生成的随机数仍然相等。    这是因为，三个线程在同一时间被创建，从而造成随机数生成器在同一时间初始化。    如果该程序执行了几次，随机数就会改变，这就表明生成器初始化正确了。</p>
<hr />
<h2 id="65-练习"><a class="header" href="#65-练习">6.5. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>
<p>重构下面的程序用两个线程来计算总和。由于现在许多处理器有两个内核，应利用线程减少执行时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;boost/cstdint.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime start = boost::posix_time::microsec_clock::local_time(); 

  boost::uint64_t sum = 0; 
  for (int i = 0; i &lt; 1000000000; ++i) 
    sum += i; 

  boost::posix_time::ptime end = boost::posix_time::microsec_clock::local_time(); 
  std::cout &lt;&lt; end - start &lt;&lt; std::endl; 

  std::cout &lt;&lt; sum &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.5.1/main.cpp">下载源代码</a></li>
</ul>
</li>
<li>
<p>通过利用处理器尽可能同时执行多的线程，把例1一般化。 例如，如果处理器有四个内核，就应该利用四个线程。</p>
</li>
<li>
<p>修改下面的程序，在 <code>main()</code>中自己的线程中执行        <code>thread()</code> 。 程序应该能够计算总和，然后把结果输入到标准输出两次。 但可以更改        <code>calculate()</code>，<code>print()</code> 和        <code>thread()</code> 的实现，每个函数的接口仍需保持一致。        也就是说每个函数应该仍然没有任何参数，也不需要返回一个值。</p>
<pre><code class="language-c++">#include &lt;iostream&gt; 

int sum = 0; 

void calculate() 
{ 
  for (int i = 0; i &lt; 1000; ++i) 
    sum += i; 
} 

void print() 
{ 
  std::cout &lt;&lt; sum &lt;&lt; std::endl; 
} 

void thread() 
{ 
  calculate(); 
  print(); 
} 

int main() 
{ 
  thread(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/6.5.2/main.cpp">下载源代码</a></li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-7-章-异步输入输出"><a class="header" href="#第-7-章-异步输入输出">第 7 章 异步输入输出</a></h1>
<h2 id="71-概述"><a class="header" href="#71-概述">7.1. 概述</a></h2>
<p>本章介绍了 Boost C++ 库 <a href="http://www.boost.org/libs/asio/">Asio</a>，它是异步输入输出的核心。    名字本身就说明了一切：Asio 意即异步输入/输出。 该库可以让 C++ 异步地处理数据，且平台独立。    异步数据处理就是指，任务触发后不需要等待它们完成。 相反，Boost.Asio 会在任务完成时触发一个应用。    异步任务的主要优点在于，在等待任务完成时不需要阻塞应用程序，可以去执行其它任务。</p>
<p>异步任务的典型例子是网络应用。 如果数据被发送出去了，比如发送至 Internet，通常需要知道数据是否发送成功。 如果没有一个象    Boost.Asio 这样的库，就必须对函数的返回值进行求值。 但是，这样就要求待至所有数据发送完毕，并得到一个确认或是错误代码。 而使用    Boost.Asio，这个过程被分为两个单独的步骤：第一步是作为一个异步任务开始数据传输。    一旦传输完成，不论成功或是错误，应用程序都会在第二步中得到关于相应的结果通知。    主要的区别在于，应用程序无需阻塞至传输完成，而可以在这段时间里执行其它操作。</p>
<hr />
<h2 id="72-io-服务与-io-对象"><a class="header" href="#72-io-服务与-io-对象">7.2. I/O 服务与 I/O 对象</a></h2>
<p>使用 Boost.Asio 进行异步数据处理的应用程序基于两个概念：I/O 服务和 I/O 对象。 I/O    服务抽象了操作系统的接口，允许第一时间进行异步数据处理，而 I/O 对象则用于初始化特定的操作。 鉴于 Boost.Asio 只提供了一个名为    <code>boost::asio::io_service</code> 的类作为 I/O    服务，它针对所支持的每一个操作系统都分别实现了优化的类，另外库中还包含了针对不同 I/O 对象的几个类。 其中，类    <code>boost::asio::ip::tcp::socket</code> 用于通过网络发送和接收数据，而类    <code>boost::asio::deadline_timer</code>    则提供了一个计时器，用于测量某个固定时间点到来或是一段指定的时长过去了。 以下第一个例子中就使用了计时器，因为与 Asio 所提供的其它 I/O    对象相比较而言，它不需要任何有关于网络编程的知识。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 

void handler(const boost::system::error_code &amp;ec) 
{ 
  std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::asio::io_service io_service; 
  boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5)); 
  timer.async_wait(handler); 
  io_service.run(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>函数 <code>main()</code> 首先定义了一个 I/O 服务    io_service，用于初始化 I/O 对象 timer。 就象    <code>boost::asio::deadline_timer</code> 那样，所有 I/O 对象通常都需要一个 I/O    服务作为它们的构造函数的第一个参数。 由于 timer 的作用类似于一个闹钟，所以    <code>boost::asio::deadline_timer</code>    的构造函数可以传入第二个参数，用于表示在某个时间点或是在某段时长之后闹钟停止。 以上例子指定了五秒的时长，该闹钟在    timer 被定义之后立即开始计时。</p>
<p>虽然我们可以调用一个在五秒后返回的函数，但是通过调用方法 <code>async_wait()</code> 并传入    <code>handler()</code> 函数的名字作为唯一参数，可以让 Asio 启动一个异步操作。 请留意，我们只是传入了    <code>handler()</code> 函数的名字，而该函数本身并没有被调用。</p>
<p><code>async_wait()</code> 的好处是，该函数调用会立即返回，而不是等待五秒钟。    一旦闹钟时间到，作为参数所提供的函数就会被相应调用。 因此，应用程序可以在调用了    <code>async_wait()</code> 之后执行其它操作，而不是阻塞在这里。</p>
<p>象 <code>async_wait()</code> 这样的方法被称为是非阻塞式的。 I/O    对象通常还提供了阻塞式的方法，可以让执行流在特定操作完成之前保持阻塞。 例如，可以调用阻塞式的    <code>wait()</code> 方法，取代    <code>boost::asio::deadline_timer</code> 的调用。    由于它会阻塞调用，所以它不需要传入一个函数名，而是在指定时间点或指定时长之后返回。</p>
<p>再看看上面的源代码，可以留意到在调用 <code>async_wait()</code> 之后，又在 I/O    服务之上调用了一个名为 <code>run()</code>    的方法。这是必须的，因为控制权必须被操作系统接管，才能在五秒之后调用 <code>handler()</code> 函数。</p>
<p><code>async_wait()</code> 会启动一个异步操作并立即返回，而    <code>run()</code> 则是阻塞的。因此调用 <code>run()</code>    后程序执行会停止。 具有讽刺意味的是，许多操作系统只是通过阻塞函数来支持异步操作。 以下例子显示了为什么这个限制通常不会成为问题。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 

void handler1(const boost::system::error_code &amp;ec) 
{ 
  std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; 
} 

void handler2(const boost::system::error_code &amp;ec) 
{ 
  std::cout &lt;&lt; &quot;10 s.&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::asio::io_service io_service; 
  boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(5)); 
  timer1.async_wait(handler1); 
  boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(10)); 
  timer2.async_wait(handler2); 
  io_service.run(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>上面的程序用了两个 <code>boost::asio::deadline_timer</code> 类型的 I/O    对象。 第一个 I/O 对象表示一个五秒后触发的闹钟，而第二个则表示一个十秒后触发的闹钟。 每一段指定时长过去后，都会相应地调用函数    <code>handler1()</code> 和 <code>handler2()</code>。</p>
<p>在 <code>main()</code> 的最后，再次在唯一的 I/O 服务之上调用了    <code>run()</code> 方法。 如前所述，这个函数将阻塞执行，把控制权交给操作系统以接管异步处理。    在操作系统的帮助下，<code>handler1()</code> 函数会在五秒后被调用，而    <code>handler2()</code> 函数则在十秒后被调用。</p>
<p>乍一看，你可能会觉得有些奇怪，为什么异步处理还要调用阻塞式的 <code>run()</code> 方法。    然而，由于应用程序必须防止被中止执行，所以这样做实际上不会有任何问题。 如果 <code>run()</code>    不是阻塞的，<code>main()</code> 就会结束从而中止该应用程序。    如果应用程序不应被阻塞，那么就应该在一个新的线程内部调用    <code>run()</code>，它自然就会仅仅阻塞那个线程。</p>
<p>一旦特定的 I/O 服务的所有异步操作都完成了，控制权就会返回给 <code>run()</code>    方法，然后它就会返回。 以上两个例子中，应用程序都会在闹钟到时间后马上结束。</p>
<hr />
<h2 id="73-可扩展性与多线程"><a class="header" href="#73-可扩展性与多线程">7.3. 可扩展性与多线程</a></h2>
<p>用 Boost.Asio 这样的库来开发应用程序，与一般的 C++ 风格不同。    那些可能需要较长时间才返回的函数不再是以顺序的方式来调用。 不再是调用阻塞式的函数，Boost.Asio 是启动一个异步操作。    而那些需要在操作结束后调用的函数则实现为相应的句柄。    这种方法的缺点是，本来顺序执行的功能变得在物理上分割开来了，从而令相应的代码更难理解。</p>
<p>象 Boost.Asio 这样的库通常是为了令应用程序具有更高的效率。    应用程序不需要等待特定的函数执行完成，而可以在期间执行其它任务，如开始另一个需要较长时间的操作。</p>
<p>可扩展性是指，一个应用程序从新增资源有效地获得好处的能力。 如果那些执行时间较长的操作不应该阻塞其它操作的话，那么建议使用    Boost.Asio. 由于现今的PC机通常都具有多核处理器，所以线程的应用可以进一步提高一个基于 Boost.Asio    的应用程序的可扩展性。</p>
<p>如果在某个 <code>boost::asio::io_service</code> 类型的对象之上调用    <code>run()</code> 方法，则相关联的句柄也会在同一个线程内被执行。 通过使用多线程，应用程序可以同时调用多个    <code>run()</code> 方法。 一旦某个异步操作结束，相应的 I/O 服务就将在这些线程中的某一个之中执行句柄。    如果第二个操作在第一个操作之后很快也结束了，则 I/O 服务可以在另一个线程中执行句柄，而无需等待第一个句柄终止。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void handler1(const boost::system::error_code &amp;ec) 
{ 
  std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; 
} 

void handler2(const boost::system::error_code &amp;ec) 
{ 
  std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; 
} 

boost::asio::io_service io_service; 

void run() 
{ 
  io_service.run(); 
} 

int main() 
{ 
  boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(5)); 
  timer1.async_wait(handler1); 
  boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(5)); 
  timer2.async_wait(handler2); 
  boost::thread thread1(run); 
  boost::thread thread2(run); 
  thread1.join(); 
  thread2.join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>上一节中的例子现在变成了一个多线程的应用。 通过使用在 <code>boost/thread.hpp</code> 中定义的    <code>boost::thread</code> 类，它来自于 Boost C++ 库 Thread，我们在    <code>main()</code> 中创建了两个线程。 这两个线程均针对同一个 I/O 服务调用了    <code>run()</code> 方法。 这样当异步操作完成时，这个 I/O    服务就可以使用两个线程去执行句柄函数。</p>
<p>这个例子中的两个计时数均被设为在五秒后触发。 由于有两个线程，所以 <code>handler1()</code> 和    <code>handler2()</code> 可以同时执行。    如果第二个计时器触发时第一个仍在执行，则第二个句柄就会在第二个线程中执行。 如果第一个计时器的句柄已经终止，则 I/O    服务可以自由选择任一线程。</p>
<p>线程可以提高应用程序的性能。 因为线程是在处理器内核上执行的，所以创建比内核数更多的线程是没有意义的。    这样可以确保每个线程在其自己的内核上执行，而没有同一内核上的其它线程与之竞争。</p>
<p>要注意，使用线程并不总是值得的。    以上例子的运行会导致不同信息在标准输出流上混合输出，因为这两个句柄可能会并行运行，访问同一个共享资源：标准输出流    std::cout。    这种访问必须被同步，以保证每一条信息在另一个线程可以向标准输出流写出另一条信息之前被完全写出。    在这种情形下使用线程并不能提供多少好处，如果各个独立句柄不能独立地并行运行。</p>
<p>多次调用同一个 I/O 服务的 <code>run()</code> 方法，是为基于 Boost.Asio    的应用程序增加可扩展性的推荐方法。 另外还有一个不同的方法：不要绑定多个线程到单个 I/O 服务，而是创建多个 I/O 服务。 然后每一个 I/O    服务使用一个线程。 如果 I/O 服务的数量与系统的处理器内核数量相匹配，则异步操作都可以在各自的内核上执行。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void handler1(const boost::system::error_code &amp;ec) 
{ 
  std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; 
} 

void handler2(const boost::system::error_code &amp;ec) 
{ 
  std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; 
} 

boost::asio::io_service io_service1; 
boost::asio::io_service io_service2; 

void run1() 
{ 
  io_service1.run(); 
} 

void run2() 
{ 
  io_service2.run(); 
} 

int main() 
{ 
  boost::asio::deadline_timer timer1(io_service1, boost::posix_time::seconds(5)); 
  timer1.async_wait(handler1); 
  boost::asio::deadline_timer timer2(io_service2, boost::posix_time::seconds(5)); 
  timer2.async_wait(handler2); 
  boost::thread thread1(run1); 
  boost::thread thread2(run2); 
  thread1.join(); 
  thread2.join(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>前面的那个使用两个计时器的例子被重写为使用两个 I/O 服务。 这个应用程序仍然基于两个线程；但是现在每个线程被绑定至不同的 I/O    服务。 此外，两个 I/O 对象 timer1 和 timer2    现在也被绑定至不同的 I/O 服务。</p>
<p>这个应用程序的功能与前一个相同。 在一定条件下使用多个 I/O 服务是有好处的，每个 I/O    服务有自己的线程，最好是运行在各自的处理器内核上，这样每一个异步操作连同它们的句柄就可以局部化执行。 如果没有远端的数据或函数需要访问，那么每一个    I/O 服务就象一个小的自主应用。 这里的局部和远端是指象高速缓存、内存页这样的资源。    由于在确定优化策略之前需要对底层硬件、操作系统、编译器以及潜在的瓶颈有专门的了解，所以应该仅在清楚这些好处的情况下使用多个 I/O    服务。</p>
<hr />
<h2 id="74-网络编程"><a class="header" href="#74-网络编程">7.4. 网络编程</a></h2>
<p>虽然 Boost.Asio 是一个可以异步处理任何种类数据的库，但是它主要被用于网络编程。 这是由于，事实上 Boost.Asio    在加入其它 I/O 对象之前很久就已经支持网络功能了。    网络功能是异步处理的一个很好的例子，因为通过网络进行数据传输可能会需要较长时间，从而不能直接获得确认或错误条件。</p>
<p>Boost.Asio 提供了多个 I/O 对象以开发网络应用。 以下例子使用了    <code>boost::asio::ip::tcp::socket</code> 类来建立与中另一台PC的连接，并下载    'Highscore' 主页；就象一个浏览器在指向 <a href="http://www.highscore.de/">www.highscore.de</a>    时所要做的。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;boost/array.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

boost::asio::io_service io_service; 
boost::asio::ip::tcp::resolver resolver(io_service); 
boost::asio::ip::tcp::socket sock(io_service); 
boost::array&lt;char, 4096&gt; buffer; 

void read_handler(const boost::system::error_code &amp;ec, std::size_t bytes_transferred) 
{ 
  if (!ec) 
  { 
    std::cout &lt;&lt; std::string(buffer.data(), bytes_transferred) &lt;&lt; std::endl; 
    sock.async_read_some(boost::asio::buffer(buffer), read_handler); 
  } 
} 

void connect_handler(const boost::system::error_code &amp;ec) 
{ 
  if (!ec) 
  { 
    boost::asio::write(sock, boost::asio::buffer(&quot;GET / HTTP 1.1\r\nHost: highscore.de\r\n\r\n&quot;)); 
    sock.async_read_some(boost::asio::buffer(buffer), read_handler); 
  } 
} 

void resolve_handler(const boost::system::error_code &amp;ec, boost::asio::ip::tcp::resolver::iterator it) 
{ 
  if (!ec) 
  { 
    sock.async_connect(*it, connect_handler); 
  } 
} 

int main() 
{ 
  boost::asio::ip::tcp::resolver::query query(&quot;www.highscore.de&quot;, &quot;80&quot;); 
  resolver.async_resolve(query, resolve_handler); 
  io_service.run(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>这个程序最明显的部分是三个句柄的使用：<code>connect_handler()</code> 和    <code>read_handler()</code> 函数会分别在连接被建立后以及接收到数据后被调用。 那么为什么需要    <code>resolve_handler()</code> 函数呢？</p>
<p>互联网使用了所谓的IP地址来标识每台PC。 IP地址实际上只是一长串数字，难以记住。 而记住象 www.highscore.de    这样的名字就容易得多。 为了在互联网上使用类似的名字，需要通过一个叫作域名解析的过程将它们翻译成相应的IP地址。    这个过程由所谓的域名解析器来完成，对应的 I/O    对象是：<code>boost::asio::ip::tcp::resolver</code>。</p>
<p>域名解析也是一个需要连接到互联网的过程。 有些专门的PC，被称为DNS服务器，其作用就象是电话本，它知晓哪个IP地址被赋给了哪台PC。    由于这个过程本身的透明的，只要明白其背后的概念以及为何需要    <code>boost::asio::ip::tcp::resolver</code> I/O 对象就可以了。    由于域名解析不是发生在本地的，所以它也被实现为一个异步操作。    一旦域名解析成功或被某个错误中断，<code>resolve_handler()</code> 函数就会被调用。</p>
<p>因为接收数据需要一个成功的连接，进而需要一次成功的域名解析，所以这三个不同的异步操作要以三个不同的句柄来启动。    <code>resolve_handler()</code> 访问 I/O 对象    sock，用由迭代器 it 所提供的解析后地址创建一个连接。 而    sock 也在 <code>connect_handler()</code> 的内部被使用，发送    HTTP 请求并启动数据的接收。 因为所有这些操作都是异步的，各个句柄的名字被作为参数传递。    取决于各个句柄，需要相应的其它参数，如指向解析后地址的迭代器 it 或用于保存接收到的数据的缓冲区    buffer。</p>
<p>开始执行后，该应用将创建一个类型为    <code>boost::asio::ip::tcp::resolver::query</code> 的对象    query，表示一个查询，其中含有名字 www.highscore.de 以及互联网常用的端口80。    这个查询被传递给 <code>async_resolve()</code> 方法以解析该名字。    最后，<code>main()</code> 只要调用 I/O 服务的 <code>run()</code>    方法，将控制交给操作系统进行异步操作即可。</p>
<p>当域名解析的过程完成后，<code>resolve_handler()</code> 被调用，检查域名是否能被解析。    如果解析成功，则存有错误条件的对象 ec 被设为0。 只有在这种情况下，才会相应地访问 socket    以创建连接。 服务器的地址是通过类型为    <code>boost::asio::ip::tcp::resolver::iterator</code>    的第二个参数来提供的。</p>
<p>调用了 <code>async_connect()</code>    方法之后，<code>connect_handler()</code> 会被自动调用。 在该句柄的内部，会访问    ec 对象以检查连接是否已建立。 如果连接是有效的，则对相应的 socket 调用    <code>async_read_some()</code> 方法，启动读数据操作。    为了保存接收到的数据，要提供一个缓冲区作为第一个参数。 在以上例子中，缓冲区的类型是    <code>boost::array</code>，它来自 Boost C++ 库 Array，定义于 <code>boost/array.hpp</code>.</p>
<p>每当有一个或多个字节被接收并保存至缓冲区时，<code>read_handler()</code> 函数就会被调用。    准确的字节数通过 <code>std::size_t</code> 类型的参数    bytes_transferred 给出。 同样的规则，该句柄应该首先看看参数    ec 以检查有没有接收错误。 如果是成功接收，则将数据写出至标准输出流。</p>
<p>请留意，<code>read_handler()</code> 在将数据写出至    std::cout 之后，会再次调用    <code>async_read_some()</code> 方法。    这是必需的，因为无法保证仅在一次异步操作中就可以接收到整个网页。 <code>async_read_some()</code>    和 <code>read_handler()</code> 的交替调用只有当连接被破坏时才中止，如当 web    服务器已经传送完整个网页时。 这种情况下，在 <code>read_handler()</code>    内部将报告一个错误，以防止进一步将数据输出至标准输出流，以及进一步对该 socket 调用    <code>async_read()</code> 方法。 这时该例程将停止，因为没有更多的异步操作了。</p>
<p>上个例子是用来取出 www.highscore.de 的网页的，而下一个例子则示范了一个简单的 web 服务器。    其主要差别在于，这个应用不会连接至其它PC，而是等待连接。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;string&gt; 

boost::asio::io_service io_service; 
boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 80); 
boost::asio::ip::tcp::acceptor acceptor(io_service, endpoint); 
boost::asio::ip::tcp::socket sock(io_service); 
std::string data = &quot;HTTP/1.1 200 OK\r\nContent-Length: 13\r\n\r\nHello, world!&quot;; 

void write_handler(const boost::system::error_code &amp;ec, std::size_t bytes_transferred) 
{ 
} 

void accept_handler(const boost::system::error_code &amp;ec) 
{ 
  if (!ec) 
  { 
    boost::asio::async_write(sock, boost::asio::buffer(data), write_handler); 
  } 
} 

int main() 
{ 
  acceptor.listen(); 
  acceptor.async_accept(sock, accept_handler); 
  io_service.run(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>类型为 <code>boost::asio::ip::tcp::acceptor</code> 的 I/O 对象    acceptor - 被初始化为指定的协议和端口号 - 用于等待从其它PC传入的连接。 初始化工作是通过    endpoint 对象完成的，该对象的类型为    <code>boost::asio::ip::tcp::endpoint</code>，将本例子中的接收器配置为使用端口80来等待    IP v4 的传入连接，这是 WWW 通常所使用的端口和协议。</p>
<p>接收器初始化完成后，<code>main()</code> 首先调用    <code>listen()</code> 方法将接收器置于接收状态，然后再用    <code>async_accept()</code> 方法等待初始连接。 用于发送和接收数据的 socket    被作为第一个参数传递。</p>
<p>当一个PC试图建立一个连接时，<code>accept_handler()</code> 被自动调用。    如果该连接请求成功，就执行自由函数 <code>boost::asio::async_write()</code> 来通过 socket    发送保存在 data 中的信息。    <code>boost::asio::ip::tcp::socket</code> 还有一个名为    <code>async_write_some()</code>    的方法也可以发送数据；不过它会在发送了至少一个字节之后调用相关联的句柄。 该句柄需要计算还剩余多少字节，并反复调用    <code>async_write_some()</code> 直至所有字节发送完毕。 而使用    <code>boost::asio::async_write()</code>    可以避免这些，因为这个异步操作仅在缓冲区的所有字节都被发送后才结束。</p>
<p>在这个例子中，当所有数据发送完毕，空函数 <code>write_handler()</code> 将被调用。    由于所有异步操作都已完成，所以应用程序终止。 与其它PC的连接也被相应关闭。</p>
<hr />
<h2 id="75-开发-boostasio-扩展"><a class="header" href="#75-开发-boostasio-扩展">7.5. 开发 Boost.Asio 扩展</a></h2>
<p>虽然 Boost.Asio 主要是支持网络功能的，但是加入其它 I/O 对象以执行其它的异步操作也非常容易。 本节将介绍    Boost.Asio 扩展的一个总体布局。 虽然这不是必须的，但它为其它扩展提供了一个可行的框架作为起点。</p>
<p>要向 Boost.Asio 中增加新的异步操作，需要实现以下三个类：</p>
<ul>
<li>一个派生自 <code>boost::asio::basic_io_object</code>        的类，以表示新的 I/O 对象。使用这个新的 Boost.Asio 扩展的开发者将只会看到这个 I/O 对象。</li>
<li>一个派生自 <code>boost::asio::io_service::service</code>        的类，表示一个服务，它被注册为 I/O 服务，可以从 I/O 对象访问它。 服务与 I/O        对象之间的区别是很重要的，因为在任意给定的时间点，每个 I/O 服务只能有一个服务实例，而一个服务可以被多个 I/O        对象访问。</li>
<li>一个不派生自任何其它类的类，表示该服务的具体实现。 由于在任意给定的时间点每个 I/O 服务只能有一个服务实例，所以服务会为每个        I/O 对象创建一个其具体实现的实例。 该实例管理与相应 I/O 对象有关的内部数据。</li>
</ul>
<p>本节中开发的 Boost.Asio 扩展并不仅仅提供一个框架，而是模拟一个可用的    <code>boost::asio::deadline_timer</code> 对象。 它与原来的    <code>boost::asio::deadline_timer</code> 的区别在于，计时器的时长是作为参数传递给    <code>wait()</code> 或 <code>async_wait()</code>    方法的，而不是传给构造函数。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;cstddef&gt; 

template &lt;typename Service&gt; 
class basic_timer 
  : public boost::asio::basic_io_object&lt;Service&gt; 
{ 
  public: 
    explicit basic_timer(boost::asio::io_service &amp;io_service) 
      : boost::asio::basic_io_object&lt;Service&gt;(io_service) 
    { 
    } 

    void wait(std::size_t seconds) 
    { 
      return this-&gt;service.wait(this-&gt;implementation, seconds); 
    } 

    template &lt;typename Handler&gt; 
    void async_wait(std::size_t seconds, Handler handler) 
    { 
      this-&gt;service.async_wait(this-&gt;implementation, seconds, handler); 
    } 
}; 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.5.1/basic_timer.hpp">下载源代码</a></li>
</ul>
<p>每个 I/O 对象通常被实现为一个模板类，要求以一个服务来实例化 - 通常就是那个特定为此 I/O 对象开发的服务。 当一个 I/O    对象被实例化时，该服务会通过父类 <code>boost::asio::basic_io_object</code> 自动注册为    I/O 服务，除非它之前已经注册。 这样可确保任何 I/O 对象所使用的服务只会每个 I/O 服务只注册一次。</p>
<p>在 I/O 对象的内部，可以通过 service    引用来访问相应的服务，通常的访问就是将方法调用前转至该服务。 由于服务需要为每一个 I/O 对象保存数据，所以要为每一个使用该服务的 I/O    对象自动创建一个实例。 这还是在父类 <code>boost::asio::basic_io_object</code>    的帮助下实现的。 实际的服务实现被作为一个参数传递给任一方法调用，使得服务可以知道是哪个 I/O 对象启动了这次调用。 服务的具体实现是通过    implementation 属性来访问的。</p>
<p>一般一上谕，I/O 对象是相对简单的：服务的安装以及服务实现的创建都是由父类    <code>boost::asio::basic_io_object</code> 来完成的，方法调用则只是前转至相应的服务；以    I/O 对象的实际服务实现作为参数即可。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;boost/thread.hpp&gt; 
#include &lt;boost/bind.hpp&gt; 
#include &lt;boost/scoped_ptr.hpp&gt; 
#include &lt;boost/shared_ptr.hpp&gt; 
#include &lt;boost/weak_ptr.hpp&gt; 
#include &lt;boost/system/error_code.hpp&gt; 

template &lt;typename TimerImplementation = timer_impl&gt; 
class basic_timer_service 
  : public boost::asio::io_service::service 
{ 
  public: 
    static boost::asio::io_service::id id; 

    explicit basic_timer_service(boost::asio::io_service &amp;io_service) 
      : boost::asio::io_service::service(io_service), 
      async_work_(new boost::asio::io_service::work(async_io_service_)), 
      async_thread_(boost::bind(&amp;boost::asio::io_service::run, &amp;async_io_service_)) 
    { 
    } 

    ~basic_timer_service() 
    { 
      async_work_.reset(); 
      async_io_service_.stop(); 
      async_thread_.join(); 
    } 

    typedef boost::shared_ptr&lt;TimerImplementation&gt; implementation_type; 

    void construct(implementation_type &amp;impl) 
    { 
      impl.reset(new TimerImplementation()); 
    } 

    void destroy(implementation_type &amp;impl) 
    { 
      impl-&gt;destroy(); 
      impl.reset(); 
    } 

    void wait(implementation_type &amp;impl, std::size_t seconds) 
    { 
      boost::system::error_code ec; 
      impl-&gt;wait(seconds, ec); 
      boost::asio::detail::throw_error(ec); 
    } 

    template &lt;typename Handler&gt; 
    class wait_operation 
    { 
      public: 
        wait_operation(implementation_type &amp;impl, boost::asio::io_service &amp;io_service, std::size_t seconds, Handler handler) 
          : impl_(impl), 
          io_service_(io_service), 
          work_(io_service), 
          seconds_(seconds), 
          handler_(handler) 
        { 
        } 

        void operator()() const 
        { 
          implementation_type impl = impl_.lock(); 
          if (impl) 
          { 
              boost::system::error_code ec; 
              impl-&gt;wait(seconds_, ec); 
              this-&gt;io_service_.post(boost::asio::detail::bind_handler(handler_, ec)); 
          } 
          else 
          { 
              this-&gt;io_service_.post(boost::asio::detail::bind_handler(handler_, boost::asio::error::operation_aborted)); 
          } 
      } 

      private: 
        boost::weak_ptr&lt;TimerImplementation&gt; impl_; 
        boost::asio::io_service &amp;io_service_; 
        boost::asio::io_service::work work_; 
        std::size_t seconds_; 
        Handler handler_; 
    }; 

    template &lt;typename Handler&gt; 
    void async_wait(implementation_type &amp;impl, std::size_t seconds, Handler handler) 
    { 
      this-&gt;async_io_service_.post(wait_operation&lt;Handler&gt;(impl, this-&gt;get_io_service(), seconds, handler)); 
    } 

  private: 
    void shutdown_service() 
    { 
    } 

    boost::asio::io_service async_io_service_; 
    boost::scoped_ptr&lt;boost::asio::io_service::work&gt; async_work_; 
    boost::thread async_thread_; 
}; 

template &lt;typename TimerImplementation&gt; 
boost::asio::io_service::id basic_timer_service&lt;TimerImplementation&gt;::id; 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.5.1/basic_timer_service.hpp">下载源代码</a></li>
</ul>
<p>为了与 Boost.Asio 集成，一个服务必须符合几个要求：</p>
<ul>
<li>它必须派生自 <code>boost::asio::io_service::service</code>。        构造函数必须接受一个指向 I/O 服务的引用，该 I/O 服务会被相应地传给        <code>boost::asio::io_service::service</code> 的构造函数。</li>
<li>任何服务都必须包含一个类型为        <code>boost::asio::io_service::id</code> 的静态公有属性        id。在 I/O 服务的内部是用该属性来识别服务的。</li>
<li>必须定义两个名为 <code>construct()</code> 和        <code>destruct()</code> 的公有方法，均要求一个类型为        <code>implementation_type</code> 的参数。 <code>implementation_type</code>        通常是该服务的具体实现的类型定义。 正如上面例子所示，在 <code>construct()</code>        中可以很容易地使用一个 <code>boost::shared_ptr</code> 对象来初始化一个服务实现，以及在        <code>destruct()</code> 中相应地析构它。 由于这两个方法都会在一个 I/O        对象被创建或销毁时自动被调用，所以一个服务可以分别使用 <code>construct()</code> 和        <code>destruct()</code> 为每个 I/O 对象创建和销毁服务实现。</li>
<li>必须定义一个名为 <code>shutdown_service()</code>        的方法；不过它可以是私有的。 对于一般的 Boost.Asio 扩展来说，它通常是一个空方法。 只有与 Boost.Asio        集成得非常紧密的服务才会使用它。 但是这个方法必须要有，这样扩展才能编译成功。</li>
</ul>
<p>为了将方法调用前转至相应的服务，必须为相应的 I/O 对象定义要前转的方法。 这些方法通常具有与 I/O    对象中的方法相似的名字，如上例中的 <code>wait()</code> 和    <code>async_wait()</code>。 同步方法，如    <code>wait()</code>，只是访问该服务的具体实现去调用一个阻塞式的方法，而异步方法，如    <code>async_wait()</code>，则是在一个线程中调用这个阻塞式方法。</p>
<p>在线程的协助下使用异步操作，通常是通过访问一个新的 I/O 服务来完成的。 上述例子中包含了一个名为    async_io_service_ 的属性，其类型为    <code>boost::asio::io_service</code>。 这个 I/O 服务的    <code>run()</code> 方法是在它自己的线程中启动的，而它的线程是在该服务的构造函数内部由类型为    <code>boost::thread</code> 的 async_thread_    创建的。 第三个属性 async_work_ 的类型为    <code>boost::scoped_ptr&lt;boost::asio::io_service::work&gt;</code>，用于避免    <code>run()</code> 方法立即返回。 否则，这可能会发生，因为已没有其它的异步操作在创建。 创建一个类型为    <code>boost::asio::io_service::work</code> 的对象并将它绑定至该 I/O    服务，这个动作也是发生在该服务的构造函数中，可以防止 <code>run()</code> 方法立即返回。</p>
<p>一个服务也可以无需访问它自身的 I/O 服务来实现 - 单线程就足够的。 为新增的线程使用一个新的 I/O 服务的原因是，这样更简单：    线程间可以用 I/O 服务来非常容易地相互通信。 在这个例子中，<code>async_wait()</code>    创建了一个类型为 <code>wait_operation</code> 的函数对象，并通过    <code>post()</code> 方法将它传递给内部的 I/O 服务。 然后，在用于执行这个内部 I/O 服务的    <code>run()</code> 方法的线程内，调用该函数对象的重载    <code>operator()()</code>。 <code>post()</code>    提供了一个简单的方法，在另一个线程中执行一个函数对象。</p>
<p><code>wait_operation</code> 的重载    <code>operator()()</code> 操作符基本上就是执行了和    <code>wait()</code> 方法相同的工作：调用服务实现中的阻塞式    <code>wait()</code> 方法。 但是，有可能这个 I/O 对象以及它的服务实现在这个线程执行    <code>operator()()</code> 操作符期间被销毁。 如果服务实现是在    <code>destruct()</code> 中销毁的，则    <code>operator()()</code> 操作符将不能再访问它。    这种情形是通过使用一个弱指针来防止的，从第一章中我们知道：如果在调用 <code>lock()</code>    时服务实现仍然存在，则弱指针 impl_ 返回它的一个共享指针，否则它将返回0。    在这种情况下，<code>operator()()</code> 不会访问这个服务实现，而是以一个    <code>boost::asio::error::operation_aborted</code> 错误来调用句柄。</p>
<pre><code class="language-c++">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;cstddef&gt; 
#include &lt;windows.h&gt; 

class timer_impl 
{ 
  public: 
    timer_impl() 
      : handle_(CreateEvent(NULL, FALSE, FALSE, NULL)) 
    { 
    } 

    ~timer_impl() 
    { 
      CloseHandle(handle_); 
    } 

    void destroy() 
    { 
      SetEvent(handle_); 
    } 

    void wait(std::size_t seconds, boost::system::error_code &amp;ec) 
    { 
      DWORD res = WaitForSingleObject(handle_, seconds * 1000); 
      if (res == WAIT_OBJECT_0) 
        ec = boost::asio::error::operation_aborted; 
      else 
        ec = boost::system::error_code(); 
    } 

private: 
    HANDLE handle_; 
}; 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.5.1/timer_impl.hpp">下载源代码</a></li>
</ul>
<p>服务实现 <code>timer_impl</code> 使用了 Windows API 函数，只能在    Windows 中编译和使用。 这个例子的目的只是为了说明一种潜在的实现。</p>
<p><code>timer_impl</code>    提供两个基本方法：<code>wait()</code> 用于等待数秒。    <code>destroy()</code>    则用于取消一个等待操作，这是必须要有的，因为对于异步操作来说，<code>wait()</code>    方法是在其自身的线程中调用的。 如果 I/O 对象及其服务实现被销毁，那么阻塞式的 <code>wait()</code>    方法就要尽使用 <code>destroy()</code> 来取消。</p>
<p>这个 Boost.Asio 扩展可以如下使用。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 
#include &quot;basic_timer.hpp&quot; 
#include &quot;timer_impl.hpp&quot; 
#include &quot;basic_timer_service.hpp&quot; 

void wait_handler(const boost::system::error_code &amp;ec) 
{ 
  std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; 
} 

typedef basic_timer&lt;basic_timer_service&lt;&gt; &gt; timer; 

int main() 
{ 
  boost::asio::io_service io_service; 
  timer t(io_service); 
  t.async_wait(5, wait_handler); 
  io_service.run(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/7.5.1/main.cpp">下载源代码</a></li>
</ul>
<p>与本章开始的例子相比，这个 Boost.Asio 扩展的用法类似于    <code>boost::asio::deadline_timer</code>。 在实践上，应该优先使用    <code>boost::asio::deadline_timer</code>，因为它已经集成在 Boost.Asio 中了。    这个扩展的唯一目的就是示范一下 Boost.Asio 是如何扩展新的异步操作的。</p>
<p><a href="http://www.highscore.de/boost/dir_monitor.zip">目录监视器(Directory     Monitor)</a> 是现实中的一个 Boost.Asio 扩展，它提供了一个可以监视目录的 I/O 对象。    如果被监视目录中的某个文件被创建、修改或是删除，就会相应地调用一个句柄。 当前的版本支持 Windows 和 Linux (内核版本 2.6.13    或以上)。</p>
<hr />
<h2 id="76-练习"><a class="header" href="#76-练习">7.6. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>修改 <a href="./asio.html#asio_networkprogramming">第 7.4 节 “网络编程”</a>        中的服务器程序，不在一次请求后即终止，而是可以处理任意多次请求。</li>
<li>扩展 <a href="./asio.html#asio_networkprogramming">第 7.4 节 “网络编程”</a>        中的客户端程序，即时在所接收到的HTML代码中分析某个URL。 如果找到，则同时下载相应的资源。 对于本练习，只使用第一个URL。        理想情况下，网站及其资源应被保存在两个文件中而不是同时写出至标准输出流。</li>
<li>创建一个客户端/服务器应用，在两台PC间传送文件。 当服务器端启动后，它应该显示所有本地接口的IP地址并等待客户端连接。        客户端则应将服务器端的某一个IP地址以及某个本地文件的文件名作为命令行参数。 客户端应将该文件传送给服务器，后者则相应地保存它。        在传送过程中，客户端应向用户提供一些进度的可视显示。</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-8-章-进程间通讯"><a class="header" href="#第-8-章-进程间通讯">第 8 章 进程间通讯</a></h1>
<h2 id="81-概述"><a class="header" href="#81-概述">8.1. 概述</a></h2>
<p>进程间通讯描述的是同一台计算机的不同应用程序之间的数据交换机制。 但不包括网络通讯方式。    如果需要经由网络，在彼此运行在不同计算机上的应用程序之间交换数据，请看<a href="./asio.html">第 7 章 <em>异步输入输出</em></a>，该章讲述了    Boost.Asio 库。</p>
<p>本章展示了 <a href="http://www.boost.org/libs/interprocess/">Boost.Interprocess</a>    库，它包括众多的类，这些类提供了操作系统相关的进程间通讯接口的抽象层。 虽然不同操作系统的进程间通讯概念非常相近，但接口的变化却很大。    Boost.Interprocess 库使通过C++使用这些功能成为可能。</p>
<p>虽然 Boost.Asio 也可以用来在同一台计算机的应用程序间交换数据，但是使用 Boost.Interprocess    库通常性能更好。 Boost.Interprocess    库实际上是使用操作系统的功能优化了同一台计算机的应用程序之间数据交换，所以它应该是任何不需要网络时应用程序间数据交换的首选。</p>
<hr />
<h2 id="82-共享内存"><a class="header" href="#82-共享内存">8.2. 共享内存</a></h2>
<p>共享内存通常是进程间通讯最快的形式。 它提供一块在应用程序间共享的内存区域。 一个应用能够在另一个应用读取数据时写数据。</p>
<p>这样一块内存区用 Boost.Interprocess 的    <code>boost::interprocess::shared_memory_object</code> 类表示。    为使用这个类，需要包含 <code>boost/interprocess/shared_memory_object.hpp</code>    头文件。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/shared_memory_object.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write); 
  shdmem.truncate(1024); 
  std::cout &lt;&lt; shdmem.get_name() &lt;&lt; std::endl; 
  boost::interprocess::offset_t size; 
  if (shdmem.get_size(size)) 
    std::cout &lt;&lt; size &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.2.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::interprocess::shared_memory_object</code>    的构造函数需要三个参数。 第一个参数指定共享内存是要创建或打开。 上面的例子实际上是指定了两种方式：用    <code>boost::interprocess::open_or_create</code>    作为参数，共享内存如果存在就将其打开，否则创建之。</p>
<p>假设之前已经创建了共享内存，现打开前面已经创建的共享内存。 为了唯一标识一块共享内存，需要为其指定一个名称，传递给    <code>boost::interprocess::shared_memory_object</code>    构造函数的第二个参数指定了这个名称。</p>
<p>第三个，也就是最后一个参数指示应用程序如何访问共享内存。 例子应用程序能够读写共享内存，这是因为最后的一个参数是    <code>boost::interprocess::read_write</code>。</p>
<p>在创建一个    <code>boost::interprocess::shared_memory_object</code>    类型的对象后，相应的共享内存就在操作系统中建立了。 可是此共享内存区域的大小被初始化为0.为了使用这块区域，需要调用    <code>truncate()</code> 函数，以字节为单位传递请求的共享内存的大小。    对于上面的例子，共享内存提供了1,024字节的空间。</p>
<p>请注意，<code>truncate()</code> 函数只能在共享内存以    <code>boost::interprocess::read_write</code> 方式打开时调用。 如果不是以此方式打开，将抛出    <code>boost::interprocess::interprocess_exception</code>    异常。</p>
<p>为了调整共享内存的大小，<code>truncate()</code> 函数可以被重复调用。</p>
<p>在创建共享内存后，<code>get_name()</code> 和    <code>get_size()</code> 函数可以分别用来查询共享内存的名称和大小。</p>
<p>由于共享内存被用于应用程序之间交换数据，所以每个应用程序需要映射共享内存到自己的地址空间上，这是通过    <code>boost::interprocess::mapped_region</code> 类实现的。</p>
<p>你也许有些奇怪，为了访问共享内存，要使用两个类。    是的，<code>boost::interprocess::mapped_region</code>    还能映射不同的对象到具体应用的地址空间。 如 Boost.Interprocess 提供    <code>boost::interprocess::file_mapping</code> 类实际上代表特定文件的共享内存。    所以 <code>boost::interprocess::file_mapping</code> 类型的对象对应一个文件。    向这个对象写入的数据将自动保存关联的物理文件上。 由于    <code>boost::interprocess::file_mapping</code> 不必加载整个文件，但却可以使用    <code>boost::interprocess::mapped_region</code>    将任意部分映射到地址空间，所以就能处理几个GB的文件，而这个文件在32位系统上是不能全部加载到内存上的。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/shared_memory_object.hpp&gt; 
#include &lt;boost/interprocess/mapped_region.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write); 
  shdmem.truncate(1024); 
  boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write); 
  std::cout &lt;&lt; std::hex &lt;&lt; &quot;0x&quot; &lt;&lt; region.get_address() &lt;&lt; std::endl; 
  std::cout &lt;&lt; std::dec &lt;&lt; region.get_size() &lt;&lt; std::endl; 
  boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only); 
  std::cout &lt;&lt; std::hex &lt;&lt; &quot;0x&quot; &lt;&lt; region2.get_address() &lt;&lt; std::endl; 
  std::cout &lt;&lt; std::dec &lt;&lt; region2.get_size() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>为了使用 <code>boost::interprocess::mapped_region</code>    类，需要包含 <code>boost/interprocess/mapped_region.hpp</code> 头文件。    <code>boost::interprocess::mapped_region</code> 的构造函数的第一个参数必须是    <code>boost::interprocess::shared_memory_object</code> 类型的对象。    第二个参数指示此内存区域对应用程序来说，是只读或是可写的。</p>
<p>上面的例子创建了两个 <code>boost::interprocess::mapped_region</code>    类型的对象。 名为&quot;Highscore&quot;的共享内存，被映射到进程的地址空间两次。 通过    <code>get_address()</code> 和 <code>get_size()</code>    这两个函数获得共享内存的地址和大小写到标准标准输出流中。 在这两种情况下，<code>get_size()</code>    的返回值都是<code>1024</code>，而    <code>get_address()</code> 的返回值是不同的。</p>
<p>下面的例子使用共享内存写入并读取一个数字。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/shared_memory_object.hpp&gt; 
#include &lt;boost/interprocess/mapped_region.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write); 
  shdmem.truncate(1024); 
  boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write); 
  int *i1 = static_cast&lt;int*&gt;(region.get_address()); 
  *i1 = 99; 
  boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only); 
  int *i2 = static_cast&lt;int*&gt;(region2.get_address()); 
  std::cout &lt;&lt; *i2 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>通过变量 region, 数值 99 被写到共享内存的开始处。 然后变量    region2 访问共享内存的同一个位置，并将数值写入到标准输出流中。 正如前面例子的    <code>get_address()</code> 函数的返回值所见，虽然变量    region 和 region2    表示的是该进程内不同的内存区域，但由于两个内存区域底层实际访问的是同一块共享内存，所以程序打印出<code>99</code>。</p>
<p>通常，不会在同一个应用程序内使用多个    <code>boost::interprocess::mapped_region</code> 访问同一块共享内存。    实际上在同一个应用程序内将同一个共享内存映射到不同的内存区域上没有多大的意义，上面的例子只用于说明的目的。</p>
<p>为了删除指定的共享内存，<code>boost::interprocess::shared_memory_object</code>    对象提供了静态的 <code>remove()</code> 函数，此函数带有一个要被删除的共享内存名称的参数。</p>
<p>Boost.Interprocess 类的RAII概念支持，明显来自关于智能指针的章节，并使用了另外的一个类名称    <code>boost::interprocess::remove_shared_memory_on_destroy</code>。    它的构造函数需要一个已经存在的共享内存的名称。 如果这个类的对象被销毁了，那么在析构函数中会自动删除共享内存的容器。</p>
<p>请注意构造函数并不创建或打开共享内存，所以，这个类并不是典型RAII概念的代表。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/shared_memory_object.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  bool removed = boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;); 
  std::cout &lt;&lt; removed &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>如果 <code>remove()</code> 没有被调用,    那么，即使进程终止，共享内存还会一直存在，而不论共享内存的删除是否依赖底层操作系统。    多数Unix操作系统，包括Linux，一旦系统重新启动，都会自动删除共享内存，在 Windows 或 Mac OS    X上，<code>remove()</code>    必须调用，这两种系统实际上将共享内存存储在持久化的文件上，此文件在系统重启后还是存在的。</p>
<p>Windows 提供了一种特别的共享内存，它可以在最后一个使用它的应用程序终止后自动删除。 为了使用它，提供了    <code>boost::interprocess::windows_shared_memory</code> 类，定义在    <code>boost/interprocess/windows_shared_memory.hpp</code>    文件中。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/windows_shared_memory.hpp&gt; 
#include &lt;boost/interprocess/mapped_region.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::windows_shared_memory shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write, 1024); 
  boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write); 
  int *i1 = static_cast&lt;int*&gt;(region.get_address()); 
  *i1 = 99; 
  boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only); 
  int *i2 = static_cast&lt;int*&gt;(region2.get_address()); 
  std::cout &lt;&lt; *i2 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>请注意，<code>boost::interprocess::windows_shared_memory</code>    类没有提供 <code>truncate()</code> 函数，而是在构造函数的第四个参数传递共享内存的大小。</p>
<p>即使 <code>boost::interprocess::windows_shared_memory</code>    类是不可移植的，且只能用于Windows系统，但使用这种特别的共享内存在不同应用之间交换数据，它还是非常有用的。</p>
<hr />
<h2 id="83-托管共享内存"><a class="header" href="#83-托管共享内存">8.3. 托管共享内存</a></h2>
<p>上一节介绍了用来创建和管理共享的    <code>boost::interprocess::shared_memory_object</code> 类。    实际上，由于这个类需要按单个字节的方式读写共享内存，所以这个类几乎不用。    概念上来讲，C++改善了类对象的创建并隐藏了它们存储在内存中哪里，是怎们存储的这些细节。</p>
<p>Boost.Interprocess 提供了一个名为“托管共享内存”的概念，通过定义在 <code>boost/interprocess/managed_shared_memory.hpp</code>    文件中的 <code>boost::interprocess::managed_shared_memory</code>    类提供。    这个类的目的是，对于需要分配到共享内存上的对象，它能够以内存申请的方式初始化，并使其自动为使用同一个共享内存的其他应用程序可用。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;); 
  boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024); 
  int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)(99); 
  std::cout &lt;&lt; *i &lt;&lt; std::endl; 
  std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;); 
  if (p.first) 
    std::cout &lt;&lt; *p.first &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子打开名为 &quot;Highscore&quot; 大小为1,024 字节的共享内存，如果它不存在，它会被自动地创建。</p>
<p>在常规的共享内存中，为了读写数据，单个字节被直接访问，托管共享内存使用诸如    <code>construct()</code> 函数，此函数要求一个数据类型作为模板参数，此例中声明的是    <code>int</code> 类型，函数缺省要求一个名称来表示在共享内存中创建的对象。 此例中使用的名称是 &quot;Integer&quot;。</p>
<p>由于 <code>construct()</code>    函数返回一个代理对象，为了初始化创建的对象，可以传递参数给此函数。 语法看上去像调用一个构造函数。    这就确保了对象不仅能在共享内存上创建，还能够按需要的方式初始化它。</p>
<p>为了访问托管共享内存上的一个特定对象，用 <code>find()</code> 函数。    通过传递要查找对象的名称，返回或者是一个指向这个特定对象的指针，或者是0表示给定名称的对象没有找到。</p>
<p>正如前面例子中所见，<code>find()</code> 实际返回的是    <code>std::pair</code> 类型的对象，first    属性提供的是指向对象的指针，那么 second 属性提供的是什么呢？</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;); 
  boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024); 
  int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)[10](99); 
  std::cout &lt;&lt; *i &lt;&lt; std::endl; 
  std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;); 
  if (p.first) 
  { 
    std::cout &lt;&lt; *p.first &lt;&lt; std::endl; 
    std::cout &lt;&lt; p.second &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>这次，通过在 <code>construct()</code>    函数后面给以用方括号括住的数字10，创建了一个10个元素的 <code>int</code> 类型的数组。 将    second    属性写到标准输出流，同样是这个数字<code>10</code>。    使用这个属性，<code>find()</code> 函数返回的对象能够区分是单个对象还是数组对象。    对于前者，second 的值是1，而对于后者，它的值是数组元素的个数。</p>
<p>请注意数组中的所有元素被初始化为数值99。 不可能每个元素初始化为不同的值。</p>
<p>如果给定名称的对象已经在托管的共享内存中存在，那么 <code>construct()</code> 将会失败。    在这种情况下，<code>construct()</code> 返回值是0。    如果存在的对象即使存在也可以被重用，<code>find_or_construct()</code>    函数可以调用，此函数返回一个指向它找到的对象的指针。 此时没有初始化动作发生。</p>
<p>其他可以导致 <code>construct()</code> 失败的情况如下例所示。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;); 
    boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024); 
    int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)[4096](99); 
  } 
  catch (boost::interprocess::bad_alloc &amp;ex) 
  { 
    std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>应用程序尝试创建一个 <code>int</code> 类型的，包含4,096个元素的数组。 然而，共享内存只有1,024    字节，于是由于共享内存不能提供请求的内存，而抛出    <code>boost::interprocess::bad_alloc</code> 类型的异常。</p>
<p>一旦对象已经在共享内存中创建，它们可以用 <code>destroy()</code> 函数删除。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;); 
  boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024); 
  int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(99); 
  std::cout &lt;&lt; *i &lt;&lt; std::endl; 
  managed_shm.destroy&lt;int&gt;(&quot;Integer&quot;); 
  std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;); 
  std::cout &lt;&lt; p.first &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.3.4/main.cpp">下载源代码</a></li>
</ul>
<p>由于它是一个参数的，要被删除对象的名称传递给 <code>destroy()</code> 函数。    如果需要，可以检查此函数的 <code>bool</code> 类型的返回值，以确定是否给定的对象被找到并成功删除。    由于对象如果被找到总是被删除，所以返回值 <code>false</code> 表示给定名称的对象没有找到。</p>
<p>除了 <code>destroy()</code> 函数，还提供了另外一个函数    <code>destroy_ptr()</code>，它能够传递一个托管共享内存中的对象的指针，它也能用来删除数组。</p>
<p>由于托管内存很容易用来存储在不同应用程序之间共享的对象，那么很自然就会使用到来自C++标准模板库的容器了。 这些容器需要用    <code>new</code> 这种方式来分配各自需要的内存。    为了在托管共享内存上使用这些容器，这就需要更加仔细地在共享内存上分配内存。</p>
<p>可惜的是，许多C++标准模板库的实现并不太灵活，不能够提供 Boost.Interprocess 使用    <code>std::string</code> 或 <code>std::list</code> 的容器。    移植到 Microsoft Visual Studio 2008 的标准模板库实现就是一个例子。</p>
<p>为了允许开发人员可以使用这些有名的来自C++标准的容器，Boost.Interprocess 在命名空间    <code>boost::interprocess</code> 下，提供了它们的更灵活的实现方式。    如，<code>boost::interprocess::string</code> 的行为实际上对应的是    <code>std::string</code>，优点是它的对象能够安全地存储在托管共享内存上。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;boost/interprocess/allocators/allocator.hpp&gt; 
#include &lt;boost/interprocess/containers/string.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;); 
  boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024); 
  typedef boost::interprocess::allocator&lt;char, boost::interprocess::managed_shared_memory::segment_manager&gt; CharAllocator; 
  typedef boost::interprocess::basic_string&lt;char, std::char_traits&lt;char&gt;, CharAllocator&gt; string; 
  string *s = managed_shm.find_or_construct&lt;string&gt;(&quot;String&quot;)(&quot;Hello!&quot;, managed_shm.get_segment_manager()); 
  s-&gt;insert(5, &quot;, world&quot;); 
  std::cout &lt;&lt; *s &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>为了创建在托管共享内存上申请内存的字符串，必须为 Boost.Interprocess    提供的另外一个分配器定义对应的数据类型，而不是使用C++标准提供的缺省分配器。</p>
<p>为了这个目的，Boost.Interprocess 在 <code>boost/interprocess/allocators/allocator.hpp</code>    文件中提供了 <code>boost::interprocess::allocator</code> 类的定义。    使用这个类，可以创建一个分配器，此分配器的内部使用的是“托管共享内存段管理器”。 段管理器负责管理位于托管共享内存之内的内存。 使用新建的分配器，与    string 相应的数据类型被定义了。 如上面所示，它使用    <code>boost::interprocess::basic_string</code> 而不是    <code>std::basic_string</code>。 上面例子中的新数据类型简单地命名为    <code>string</code>，它是基于    <code>boost::interprocess::basic_string</code> 并经过分配器访问段管理器。    为了让通过 <code>find_or_construct()</code> 创建的    <code>string</code>    特定实例，知道哪个段管理器应该被访问，相应的段管理器的指针传递给构造函数的第二个参数。</p>
<p>与 <code>boost::interprocess::string</code> 一起,    Boost.Interprocess 还提供了许多其他C++标准中已知的容器。 如,    <code>boost::interprocess::vector</code> 和    <code>boost::interprocess::map</code>，分别定义在 <code>boost/interprocess/containers/vector.hpp</code> 和    <code>boost/interprocess/containers/map.hpp</code>文件中</p>
<p>无论何时同一个托管共享内存被不同的应用程序访问，诸如创建，查找和销毁对象的操作是自动同步的。    如果两个应用程序尝试在托管共享内存上创建不同名称的对象，访问相应地被串行化了。 为了立刻执行多个操作而不被其他应用程序的操作打断，可以使用    <code>atomic_func()</code> 函数。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;boost/bind.hpp&gt; 
#include &lt;iostream&gt; 

void construct_objects(boost::interprocess::managed_shared_memory &amp;managed_shm) 
{ 
  managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)(99); 
  managed_shm.construct&lt;float&gt;(&quot;Float&quot;)(3.14); 
} 

int main() 
{ 
  boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;); 
  boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024); 
  managed_shm.atomic_func(boost::bind(construct_objects, boost::ref(managed_shm))); 
  std::cout &lt;&lt; *managed_shm.find&lt;int&gt;(&quot;Integer&quot;).first &lt;&lt; std::endl; 
  std::cout &lt;&lt; *managed_shm.find&lt;float&gt;(&quot;Float&quot;).first &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.3.6/main.cpp">下载源代码</a></li>
</ul>
<p><code>atomic_func()</code> 需要一个无参数，无返回值的函数作为它的参数。    被传递的函数将以以一种确保排他访问托管共享内存的方式被调用，但仅限于对象的创建，查找和销毁操作。    如果另一个应用程序有一个指向托管内存中对象的指针，它还是可以使用这个指针修改该对象的。</p>
<p>Boost.Interprocess 也可以用来同步对象的访问。 由于 Boost.Interprocess    不知道在任意一个时间点谁可以访问某个对象，所以同步需要明确的状态标志，下一节介绍这些类提供的同步方式。</p>
<hr />
<h2 id="84-同步"><a class="header" href="#84-同步">8.4. 同步</a></h2>
<p>Boost.Interprocess 允许多个应用程序并发使用共享内存。 由于共享内存被定义为在应用程序之间“共享”，所以    Boost.Interprocess 需要支持一些同步方式。</p>
<p>当考虑到同步的时候，Boost.Thread 当然浮现在脑海里。 正如在 <a href="./multithreading.html">第 6 章 <em>多线程</em></a> 所见，Boost.Thread 确实提供了各种概念，如互斥对象和条件变量来同步线程。    可惜的是，这些类只能用来同步同一个应用程序内的线程，它们不支持同步不同的应用程序。 由于二者面临的问题相同，所以在概念上没有什么差别。</p>
<p>当诸如互斥对象和条件变量等同步对象位于一个多线程的应用程序的同一地址空间内时，当然它们对于所有线程都是可以访问的，而在共享内存方面的问题是不同的应用程序需要在彼此之间正确地共享这些对象。    例如，如果一个应用程序创建一个互斥对象，它有时候需要从另外一个应用程序访问此对象。</p>
<p>Boost.Interprocess 提供了两种同步对象，匿名对象被直接存储在共享内存上，这使得他们自动对所有应用程序可用。    命名对象由操作系统管理，所以它们不存储在共享内存上，它们可以被应用程序通过名称访问。</p>
<p>接下来的例子通过 <code>boost::interprocess::named_mutex</code>    创建并使用一个命名互斥对象，此类定义在 <code>boost/interprocess/sync/named_mutex.hpp</code>    文件中。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;boost/interprocess/sync/named_mutex.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024); 
  int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(); 
  boost::interprocess::named_mutex named_mtx(boost::interprocess::open_or_create, &quot;mtx&quot;); 
  named_mtx.lock(); 
  ++(*i); 
  std::cout &lt;&lt; *i &lt;&lt; std::endl; 
  named_mtx.unlock(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>除了一个参数用来指定互斥对象是被创建或者打开之外，<code>boost::interprocess::named_mutex</code>    的构造函数还需要一个名称参数。 每个知道此名称的应用程序能够访问这同一个对象。 为了获得对位于共享内存中数据的访问，应用程序需要通过调用    <code>lock()</code> 函数获得互斥对象的拥有关系。    由于互斥对象在任意时刻只能被一个应用程序拥有，其他应用程序需要等待，直到互斥对象被第一个应用程序使用    <code>lock()</code> 函数释放。 一旦应用程序获得互斥对象的所有权，它可以获得互斥对象保护的资源的排他访问。    在上面例子中，资源是<code>int</code>类的变量被递增并写到标准输出流中。</p>
<p>如果应用程序被启动多次，每个实例都会打印出和前一个值比较递增1的值。    感谢互斥对象，访问共享内存和变量本身在多个应用程序之间是同步的。</p>
<p>接下来的应用程序使用了定义在 <code>boost/interprocess/sync/interprocess_mutex.hpp</code>    文件中的 <code>boost::interprocess::interprocess_mutex</code>    类的匿名对象。 为了可以被所有应用程序访问，它存储在共享内存中。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024); 
  int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(); 
  boost::interprocess::interprocess_mutex *mtx = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_mutex&gt;(&quot;mtx&quot;)(); 
  mtx-&gt;lock(); 
  ++(*i); 
  std::cout &lt;&lt; *i &lt;&lt; std::endl; 
  mtx-&gt;unlock(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>这个应用程序的行为确实和前一个有点像。 唯一的不同是这次互斥对象通过用    <code>boost::interprocess::managed_shared_memory</code> 类的    <code>construct()</code> 或    <code>find_or_construct()</code> 函数被直接存储在共享内存中。</p>
<p>除了 <code>lock()</code>    函数，<code>boost::interprocess::named_mutex</code> 和    <code>boost::interprocess::interprocess_mutex</code> 还提供了    <code>try_lock()</code> 和 <code>timed_lock()</code>    函数。 它们的行为和Boost.Thread提供的互斥对象相对应。</p>
<p>在需要递归互斥对象的时候，Boost.Interprocess 提供    <code>boost::interprocess::named_recursive_mutex</code> 和    <code>boost::interprocess::interprocess_mutex</code>    两个对象可供使用。</p>
<p>在互斥对象保证共享资源的排他访问的时候，条件变量控制了在什么时候，谁必须具有排他访问权。 一般来讲，Boost.Interprocess    和 Boost.Thread 提供的条件变量工作方式相同。 它们有非常相似的接口，使熟悉 Boost.Thread 的用户在使用    Boost.Interprocess 的这些条件变量时立刻有一种自在的感觉。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;boost/interprocess/sync/named_mutex.hpp&gt; 
#include &lt;boost/interprocess/sync/named_condition.hpp&gt; 
#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024); 
  int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(0); 
  boost::interprocess::named_mutex named_mtx(boost::interprocess::open_or_create, &quot;mtx&quot;); 
  boost::interprocess::named_condition named_cnd(boost::interprocess::open_or_create, &quot;cnd&quot;); 
  boost::interprocess::scoped_lock&lt;boost::interprocess::named_mutex&gt; lock(named_mtx); 
  while (*i &lt; 10) 
  { 
    if (*i % 2 == 0) 
    { 
      ++(*i); 
      named_cnd.notify_all(); 
      named_cnd.wait(lock); 
    } 
    else 
    { 
      std::cout &lt;&lt; *i &lt;&lt; std::endl; 
      ++(*i); 
      named_cnd.notify_all(); 
      named_cnd.wait(lock); 
    } 
  } 
  named_cnd.notify_all(); 
  boost::interprocess::shared_memory_object::remove(&quot;shm&quot;); 
  boost::interprocess::named_mutex::remove(&quot;mtx&quot;); 
  boost::interprocess::named_condition::remove(&quot;cnd&quot;); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.4.3/main.cpp">下载源代码</a></li>
</ul>
<p>例子中使用的条件变量的类型    <code>boost::interprocess::named_condition</code>，定义在 <code>boost/interprocess/sync/named_condition.hpp</code>    文件中。 由于它是命名变量，所以它不需要存储在共享内存。</p>
<p>应用程序使用 <code>while</code> 循环递增一个存储在共享内存中的 <code>int</code>    类型变量而变量是在每个循环内重复递增，而它只在每两个循环时写出到标准输出中：写出的只能是奇数。</p>
<p>每次，在变量递增1之后，条件变量 named_cnd 的 <code>wait    ()</code>函数被调用。 一个称作锁，在此例中是变量 lock 被传递给此函数。 这个锁和    Boost.Thread 中的锁含义相同：基于RAII概念的在构造函数中获得互斥对象的所有权,并在析构函数中释放它。</p>
<p>在 <code>while</code> 之前创建的锁因而在整个应用程序执行期间拥有互斥对象的所有权。 可是，如果作为一个参数传递给    <code>wait()</code> 函数，它会被自动释放。</p>
<p>条件变量常常用来等待一个信号，此信号会指示等待现在到了。 同步是通过 <code>wait()</code> 和    <code>notify_all()</code> 函数控制的。 如果一个应用程序调用    <code>wait()</code> 函数，一直到对应的条件变量的    <code>notify_all()</code> 函数被调用，相应的互斥对象的所有权才会被被释放。</p>
<p>如果启动此程序，它看上去什么也没做：而只是变量在 <code>while</code> 循环内从0递增到1，然后应用程序使用    <code>wait()</code> 等待信号。 为了提供这个信号，应用程序需要再启动第二个实例。</p>
<p>应用程序的第二个实例将会在进入 <code>while</code> 循环之前，尝试获得同一个互斥对象的所有权。    这肯定是成功的，由于应用程序的第一个实例通过调用 <code>wait()</code> 释放了互斥对象的所有权。    因为变量已经递增了一次，第二个实例现在会执行 <code>if</code> 表达式的 <code>else</code>    分支，这使得在递增1之前将当前值写到标准输出流。</p>
<p>现在，第二个实例也调用了 <code>wait()</code> 函数，可是，在调用之前,它调用了    <code>notify_all()</code> 函数，这对于两个实例正确协作是非常重要的顺序。    第一个实例被通知并再次尝试获得互斥对象的所有权，虽然现在它还被第二个实例所拥有。 由于第二个实例在调用    <code>notify_all()</code> 之后调用了    <code>wait()</code>，这自动释放了所有权，第一个实例此时能够获得所有权。</p>
<p>两个实例交替地递增共享内存中的变量。 仅有一个实例将变量值写到标准输出流。 只要变量值到达10，<code>while</code>    循环结束。 为了让其他实例不必永远等待信号， <code>notify_all()</code> 函数在循环之后又被调用了一次。    在终止之前，共享内存，互斥对象和条件变量都被销毁。</p>
<p>就像有两种互斥对象，即必须存储在共享内存中匿名类型和命名类型，也存在两种类型的条件变量。    现在用匿名条件变量重写上面的例子。</p>
<pre><code class="language-c++">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; 
#include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt; 
#include &lt;boost/interprocess/sync/interprocess_condition.hpp&gt; 
#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024); 
    int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(0); 
    boost::interprocess::interprocess_mutex *mtx = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_mutex&gt;(&quot;mtx&quot;)(); 
    boost::interprocess::interprocess_condition *cnd = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_condition&gt;(&quot;cnd&quot;)(); 
    boost::interprocess::scoped_lock&lt;boost::interprocess::interprocess_mutex&gt; lock(*mtx); 
    while (*i &lt; 10) 
    { 
      if (*i % 2 == 0) 
      { 
        ++(*i); 
        cnd-&gt;notify_all(); 
        cnd-&gt;wait(lock); 
      } 
      else 
      { 
        std::cout &lt;&lt; *i &lt;&lt; std::endl; 
        ++(*i); 
        cnd-&gt;notify_all(); 
        cnd-&gt;wait(lock); 
      } 
    } 
    cnd-&gt;notify_all(); 
  } 
  catch (...) 
  { 
  } 
  boost::interprocess::shared_memory_object::remove(&quot;shm&quot;); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/8.4.4/main.cpp">下载源代码</a></li>
</ul>
<p>这个应用程序的工作完全和前一个例子一样，为了递增变量10次，因而也需要启动两个实例。 两个例子之间的差别很小。    与是否使用匿名或命名条件变量根本没有什么关系。</p>
<p>处理互斥对象和条件变量，Boost.Interprocess 还提供了叫做信号量和文件锁。    信号量的行为和条件变量相似，除了它不能区别两种状态，但它确是基于计数器的。    文件锁有些像互斥对象，虽然它们不是关于内存的对象，但它们确是文件系统上关于文件的对象。</p>
<p>就像 Boost.Thread 能够区分不同的互斥对象和锁，Boost.Interprocess 也提供了几个互斥对象和锁。    例如，互斥对象不仅能被排他地拥有，也可以不排他地所有。 这在多个应用程序需要同时读而排他写的时候非常有用。    对于不同的互斥对象，可以使用不同的具有RAII概念的锁类。</p>
<p>请注意如果不使用匿名同步对象，那么名称应该是唯一的。 虽然互斥对象和条件变量是基于不同类的对象，但也不必总是认为操作系统独立的接口是由    Boost.Interprocess 区别对待的。 在Windows系统上，互斥对象和条件变量使用同样的系统函数。    如果这两种对象使用相同的名称，那么应用程序在Windows上将不会正确地址执行。</p>
<hr />
<h2 id="85-练习"><a class="header" href="#85-练习">8.5. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>创建一个通过共享内存通讯的客户端/服务器应用程序。 文件名称应该作为命令行参数传递给客户端应用程序。        这个文件存储在服务器端应用程序启动的目录下，这个文件应经由共享内存发送给服务器端应用程序。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-9-章-文件系统"><a class="header" href="#第-9-章-文件系统">第 9 章 文件系统</a></h1>
<h2 id="91-概述"><a class="header" href="#91-概述">9.1. 概述</a></h2>
<p>库 <a href="http://www.boost.org/libs/filesystem/">Boost.Filesystem</a>    简化了处理文件和目录的工作。 它提供了一个名为 <code>boost::filesystem::path</code>    的类，可以对路径进行处理。 另外，还有多个函数用于创建目录或验证某个给定文件的有效性。</p>
<hr />
<h2 id="92-路径"><a class="header" href="#92-路径">9.2. 路径</a></h2>
<p><code>boost::filesystem::path</code> 是 Boost.Filesystem    中的核心类，它表示路径的信息，并提供了处理路径的方法。</p>
<p>实际上，<code>boost::filesystem::path</code> 是    <code>boost::filesystem::basic_path&lt;std::string&gt;</code> 的一个    <code>typedef</code>。 此外还有一个    <code>boost::filesystem::wpath</code> 是    <code>boost::filesystem::basic_path&lt;std::wstring&gt;</code> 的    <code>typedef</code>。</p>
<p>所有定义均位于 boost::filesystem 名字空间，定义于 <code>boost/filesystem.hpp</code> 中。</p>
<p>可以通过传入一个字符串至 <code>boost::filesystem::path</code>    类来构建一个路径。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 

int main() 
{ 
  boost::filesystem::path p1(&quot;C:\\&quot;); 
  boost::filesystem::path p2(&quot;C:\\Windows&quot;); 
  boost::filesystem::path p3(&quot;C:\\Program Files&quot;); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>没有一个 <code>boost::filesystem::path</code>    的构造函数会实际验证所提供路径的有效性，或检查给定的文件或目录是否存在。    因此，<code>boost::filesystem::path</code> 甚至可以用无意义的路径来初始化。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 

int main() 
{ 
  boost::filesystem::path p1(&quot;...&quot;); 
  boost::filesystem::path p2(&quot;\\&quot;); 
  boost::filesystem::path p3(&quot;@:&quot;); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序可以执行的原因是，路径其实只是字符串而已。    <code>boost::filesystem::path</code>    只是处理字符串罢了；文件系统没有被访问到。</p>
<p><code>boost::filesystem::path</code>    特别提供了一些方法来以字符串方式获取一个路径。 有趣的是，有三种不同的方法。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\Windows\\System&quot;); 
  std::cout &lt;&lt; p.string() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.file_string() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.directory_string() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.2.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>string()</code> 方法返回一个所谓的可移植路径。 换句话说，就是    Boost.Filesystem 用它自己预定义的规则来正规化给定的字符串。    在以上例子中，<code>string()</code> 返回    <code>C:/Windows/System</code>。 如你所见，Boost.Filesystem    内部使用斜杠符 <code>/</code> 作为文件名与目录名的分隔符。</p>
<p>可移植路径的目的是在不同的平台，如 Windows 或 Linux 之间，唯一地标识文件和目录。    因此就不再需要使用预处理器宏来根据底层的操作系统进行路径的编码。 构建可移植路径的规则大多符合POSIX标准，在 <a href="http://www.boost.org/libs/filesystem/doc/reference.html">Boost.Filesystem     参考手册</a> 给出。</p>
<p>请注意，<code>boost::filesystem::path</code>    的构造函数同时支持可移植路径和平台相关路径。 在上面例子中所使用的路径 &quot;C:\Windows\System&quot; 就不是可移植路径，而是    Windows 专用的。 它可以被 Boost.Filesystem 正确识别，但仅当该程序是在 Windows 操作系统下运行的时候！    当程序运行于一个 POSIX 兼容的操作系统，如 Linux 时，<code>string()</code> 将返回    <code>C:\Windows\System</code>。 因为在 Linux 中，反斜杠符    <code>\</code> 并不被用作分隔符，无论是可移植格式或原生格式，Boost.Filesystem    都不会认为它是文件和目录的分隔符。</p>
<p>很多时候，都不能避免使用平台相关路径作为字符串。 一个例子就是，使用操作系统函数时必须要用平台相关的编码。 方法    <code>file_string()</code> 和    <code>directory_string()</code> 正是为此目的而提供的。</p>
<p>在上例中，这两个方法都会返回 <code>C:\Windows\System</code> -    与底层操作系统无关。 在 Windows 上这个字符串是有效路径，而在一个 Linux    系统上则既不是可移植路径也不是平台相关路径，会象前面所说那样被解析。</p>
<p>以下例子使用一个可移植路径来初始化    <code>boost::filesystem::path</code>。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;/&quot;); 
  std::cout &lt;&lt; p.string() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.file_string() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.directory_string() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>由于 <code>string()</code> 返回的是一个可移植路径，所以它与用于初始化    <code>boost::filesystem::path</code>    的字符串相同：<code>/</code>。 但是    <code>file_string()</code> 和    <code>directory_string()</code> 方法则会因底层平台而返回不同的结果。 在 Windows    中，它们都返回 <code>\</code>，而在 Linux 中则都返回    <code>/</code>。</p>
<p>你可能会奇怪为什么会有两个不同的方法用来返回平台相关路径。    到目前为止，在所看到的例子中，<code>file_string()</code> 和    <code>directory_string()</code> 都是返回相同的值。 但是，有些操作系统可能会返回不同的结果。    因为 Boost.Filesystem 的目标是支持尽可能多的操作系统，所以它提供了两个方法来适应这种情况。 即使你可能更为熟悉 Windows 或    POSIX 系统如 Linux，但还是建议使用 <code>file_string()</code>    来取出文件的路径信息，且使用 <code>directory_string()</code> 取出目录的路径信息。    这无疑会增加代码的可移植性。</p>
<p><code>boost::filesystem::path</code>    提供了几个方法来访问一个路径中的特定组件。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\Windows\\System&quot;); 
  std::cout &lt;&lt; p.root_name() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.root_directory() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.root_path() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.relative_path() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.parent_path() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.filename() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>如果在是一个 Windows 操作系统上执行，则字符串 &quot;C:\Windows\System&quot; 被解释为一个平台相关的路径信息。    因此，<code>root_name()</code> 返回    <code>C:</code>,    <code>root_directory()</code> 返回    <code>/</code>, <code>root_path()</code> 返回    <code>C:/</code>,    <code>relative_path()</code> 返回    <code>Windows/System</code>,    <code>parent_path()</code> 返回    <code>C:/Windows</code>, 而    <code>filename()</code> 返回    <code>System</code>。</p>
<p>如你所见，没有平台相关的路径信息被返回。 没有一个返回值包含反斜杠 <code>\</code>，只有斜杠    <code>/</code>。 如果需要平台相关信息，则要使用 <code>file_string()</code> 或    <code>directory_string()</code>。 为了使用这些路径中的单独组件，必须创建一个类型为    <code>boost::filesystem::path</code> 的新对象并相应的进行初始化。</p>
<p>如果以上程序在 Linux 操作系统中执行，则返回值有所不同。 多数方法会返回一个空字符串，除了    <code>relative_path()</code> 和 <code>filename()</code>    会返回 <code>C:\Windows\System</code>。 字符串    &quot;C:\Windows\System&quot; 在 Linux 中被解释为一个文件名，这个字符串既不是某个路径的可移植编码，也不是一个被 Linux    支持的平台相关编码。 因此，Boost.Filesystem 没有其它选择，只能将整个字符串解释为一个文件名。</p>
<p>Boost.Filesystem 还提供了其它方法来检查一个路径中是否包含某个特定子串。    这些方法是：<code>has_root_name()</code>,    <code>has_root_directory()</code>,    <code>has_root_path()</code>,    <code>has_relative_path()</code>,    <code>has_parent_path()</code> 和    <code>has_filename()</code>。 各个方法都是返回一个 <code>bool</code>    类型的值。</p>
<p>还有两个方法用于将一个文件名拆分为各个组件。 它们应当仅在 <code>has_filename()</code>    返回 <code>true</code> 时使用。 否则只会返回一个空字符串，因为如果没有文件名就没什么可拆分了。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;photo.jpg&quot;); 
  std::cout &lt;&lt; p.stem() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.extension() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.2.6/main.cpp">下载源代码</a></li>
</ul>
<p>这个程序分别返回 <code>photo</code> 给    <code>stem()</code>，以及 <code>.jpg</code> 给    <code>extension()</code>。</p>
<p>除了使用各个方法调用来访问路径的各个组件以外，你还可以对组件本身进行迭代。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\Windows\\System&quot;); 
  for (boost::filesystem::path::iterator it = p.begin(); it != p.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.2.7/main.cpp">下载源代码</a></li>
</ul>
<p>如果是在 Windows 上执行，则该程序将相继输出 <code>C:</code>,    <code>/</code>,    <code>Windows</code> 和    <code>System</code>。 在其它的操作系统如 Linux 上，输出结果则是    <code>C:\Windows\System</code>。</p>
<p>前面的例子示范了不同的方法来访问路径中的各个组件，以下例子则示范了修改路径信息的方法。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\&quot;); 
  p /= &quot;Windows\\System&quot;; 
  std::cout &lt;&lt; p.string() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.2.8/main.cpp">下载源代码</a></li>
</ul>
<p>通过使用重载的 <code>operator/=()</code> 操作符，这个例子将一个路径添加到另一个之上。 在    Windows 中，该程序将输出 <code>C:\Windows\System</code>。 在    Linux 中，输出将会是 <code>C:\/Windows\System</code>，因为斜杠符    <code>/</code> 是文件与目录的分隔符。 这也是重载 <code>operator/=()</code>    操作符的原因：毕竟，斜杠是这个方法名的一个部分。</p>
<p>除了 <code>operator/=()</code>，Boost.Filesystem 只提供了    <code>remove_filename()</code> 和    <code>replace_extension()</code> 方法来修改路径信息。</p>
<hr />
<h2 id="93-文件与目录"><a class="header" href="#93-文件与目录">9.3. 文件与目录</a></h2>
<p><code>boost::filesystem::path</code> 的各个方法内部其实只是对字符串进行处理。    它们可以用来访问一个路径的各个组件、相互添加路径等等。</p>
<p>为了处理硬盘上的物理文件和目录，提供了几个独立的函数。 这些函数需要一个或多个    <code>boost::filesystem::path</code>    类型的参数，并且在其内部会调用操作系统功能来处理这些文件或目录。</p>
<p>在介绍各个函数之前，很重要的一点是要弄明白出现错误时会发生什么。 所有要在内部访问操作系统功能的函数都有可能失败。    在失败的情况下，将抛出一个类型为    <code>boost::filesystem::filesystem_error</code> 的异常。    这个类是派生自 <code>boost::system::system_error</code> 的，因此适用于    Boost.System 框架。</p>
<p>除了继承自父类 <code>boost::system::system_error</code> 的    <code>what()</code> 和 <code>code()</code>    方法以外，还有另外两个方法：<code>path1()</code> 和    <code>path2()</code>。 它们均返回一个类型为    <code>boost::filesystem::path</code> 的对象，因此在发生错误时可以很容易地确定路径信息 -    即使是对那些需要两个 <code>boost::filesystem::path</code> 参数的函数。</p>
<p>多数函数存在两个变体：在失败时，一个会抛出类型为    <code>boost::filesystem::filesystem_error</code>    的异常，而另一个则返回类型为 <code>boost::system::error_code</code> 的对象。    对于后者，需要对返回值进行明确的检查以确定是否出错。</p>
<p>以下例子介绍了一个函数，它可以查询一个文件或目录的状态。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\&quot;); 
  try 
  { 
    boost::filesystem::file_status s = boost::filesystem::status(p); 
    std::cout &lt;&lt; boost::filesystem::is_directory(s) &lt;&lt; std::endl; 
  } 
  catch (boost::filesystem::filesystem_error &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.3.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::filesystem::status()</code> 返回一个    <code>boost::filesystem::file_status</code>    类型的对象，该对象可以被传递给其它辅助函数来评估。 例如，如果查询的是一个目录的状态，则    <code>boost::filesystem::is_directory()</code> 将返回    <code>true</code>。 除了    <code>boost::filesystem::is_directory()</code>，还有其它函数，如    <code>boost::filesystem::is_regular_file()</code>,    <code>boost::filesystem::is_symlink()</code> 和    <code>boost::filesystem::exists()</code>，它们都会返回一个 <code>bool</code>    类型的值。</p>
<p>除了 <code>boost::filesystem::status()</code>，另一个名为    <code>boost::filesystem::symlink_status()</code> 的函数可用于查询一个符号链接的状态。    在此情况下，实际上查询的是符号链接所指向的文件的状态。在 Windows 中，符号链接以 <code>lnk</code> 文件扩展名识别。</p>
<p>另有一组函数可用于查询文件和目录的属性。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\Windows\\win.ini&quot;); 
  try 
  { 
    std::cout &lt;&lt; boost::filesystem::file_size(p) &lt;&lt; std::endl; 
  } 
  catch (boost::filesystem::filesystem_error &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>函数 <code>boost::filesystem::file_size()</code>    以字节数返回一个文件的大小。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;ctime&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\Windows\\win.ini&quot;); 
  try 
  { 
    std::time_t t = boost::filesystem::last_write_time(p); 
    std::cout &lt;&lt; std::ctime(&amp;t) &lt;&lt; std::endl; 
  } 
  catch (boost::filesystem::filesystem_error &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>要获得一个文件最后被修改的时间，可使用    <code>boost::filesystem::last_write_time()</code>。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\&quot;); 
  try 
  { 
    boost::filesystem::space_info s = boost::filesystem::space(p); 
    std::cout &lt;&lt; s.capacity &lt;&lt; std::endl; 
    std::cout &lt;&lt; s.free &lt;&lt; std::endl; 
    std::cout &lt;&lt; s.available &lt;&lt; std::endl; 
  } 
  catch (boost::filesystem::filesystem_error &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.3.4/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::filesystem::space()</code> 用于取回磁盘的总空间和剩余空间。 它返回一个    <code>boost::filesystem::space_info</code>    类型的对象，其中定义了三个公有属性：capacity, free 和    available。 这三个属性的类型均为    <code>boost::uintmax_t</code>，该类型定义于 Boost.Integer 库，通常是 <code>unsigned    long long</code> 的 typedef。 磁盘空间是以字节数来计算的。</p>
<p>目前所看到的函数都不会触及文件和目录本身，不过有另外几个函数可以用于创建、改名或删除文件和目录。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;C:\\Test&quot;); 
  try 
  { 
    if (boost::filesystem::create_directory(p)) 
    { 
      boost::filesystem::rename(p, &quot;C:\\Test2&quot;); 
      boost::filesystem::remove(&quot;C:\\Test2&quot;); 
    } 
  } 
  catch (boost::filesystem::filesystem_error &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>以上例子应该是自解释的。 仔细察看，可以看到传递给各个函数的不一定是    <code>boost::filesystem::path</code> 类型的对象，也可以是一个简单的字符串。    这是可以的，因为 <code>boost::filesystem::path</code>    提供了一个非显式的构造函数，可以从简单的字符串转换为 <code>boost::filesystem::path</code>    类型的对象。 这实际上简化了 Boost.Filesystem 的使用，因为可以无须显式创建一个对象。</p>
<p>还有其它的函数，如 <code>create_symlink()</code> 用于创建符号链接，以及    <code>copy_file()</code> 用于复制文件或目录。</p>
<p>以下例子中介绍了一个函数，基于一个文件名或一小节路径来创建一个绝对路径。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    std::cout &lt;&lt; boost::filesystem::complete(&quot;photo.jpg&quot;) &lt;&lt; std::endl; 
  } 
  catch (boost::filesystem::filesystem_error &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.3.6/main.cpp">下载源代码</a></li>
</ul>
<p>输出哪个路径是由该程序运行时所处的路径决定的。 例如，如果该例子从 <code>C:\</code> 运行，输出将是    <code>C:/photo.jpg</code>。</p>
<p>请再次留意斜杠符 <code>/</code>! 如果想得到一个平台相关的路径，则需要初始化一个    <code>boost::filesystem::path</code> 类型的对象，且必须调用    <code>file_string()</code>。</p>
<p>要取出一个相对于其它目录的绝对路径，可将第二个参数传递给    <code>boost::filesystem::complete()</code>。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    std::cout &lt;&lt; boost::filesystem::complete(&quot;photo.jpg&quot;, &quot;D:\\&quot;) &lt;&lt; std::endl; 
  } 
  catch (boost::filesystem::filesystem_error &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.3.7/main.cpp">下载源代码</a></li>
</ul>
<p>现在，该程序显示的是 <code>D:/photo.jpg</code>。</p>
<p>最后，还有一个辅助函数用于取出当前工作目录，如下例所示。</p>
<pre><code class="language-c++">#include &lt;windows.h&gt; 
#include &lt;boost/filesystem.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    std::cout &lt;&lt; boost::filesystem::current_path() &lt;&lt; std::endl; 
    SetCurrentDirectory(&quot;C:\\&quot;); 
    std::cout &lt;&lt; boost::filesystem::current_path() &lt;&lt; std::endl; 
  } 
  catch (boost::filesystem::filesystem_error &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.3.8/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序只能在 Windows 中执行，这是 <code>SetCurrentDirectory()</code>    函数的原因。 这个函数更换了当前工作目录，因此对    <code>boost::filesystem::current_path()</code> 的两次调用将返回不同的结果。</p>
<p>函数 <code>boost::filesystem::initial_path()</code>    用于返回应用程序开始执行时所处的目录。 但是，这个函数取决于操作系统的支持，因此如果需要可移植性，建议不要使用。    在这种情况下，Boost.Filesystem 文档中建议的方法是，可以在程序开始时保存    <code>boost::filesystem::current_path()</code> 的返回值，以备后用。</p>
<hr />
<h2 id="94-文件流"><a class="header" href="#94-文件流">9.4. 文件流</a></h2>
<p>C++ 标准在 <code>fstream</code>    头文件中定义了几个文件流。 这些流不能接受 <code>boost::filesystem::path</code>    类型的参数。 由于 Boost.Filesystem 库很有可能被包含在 C++ 标准的 Technical Report 2    中，所以这些文件流将通过相应的构造函数来进行扩展。 为了当前可以让文件流与类型为    <code>boost::filesystem::path</code> 的路径信息一起工作，可以使用头文件 <code>boost/filesystem/fstream.hpp</code>。    它提供了对文件流所需的扩展，这些都是基于 Technical Report 2 即将加入 C++ 标准中的。</p>
<pre><code class="language-c++">#include &lt;boost/filesystem/fstream.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::filesystem::path p(&quot;test.txt&quot;); 
  boost::filesystem::ofstream ofs(p); 
  ofs &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/9.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>不仅是构造函数，还有 <code>open()</code> 方法也需要重载，以接受类型为    <code>boost::filesystem::path</code> 的参数。</p>
<hr />
<h2 id="95-练习"><a class="header" href="#95-练习">9.5. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>创建一个程序，该程序为位于应用程序当前工作目录的上一层目录中的一个名为        <code>data.txt</code> 的文件创建一个绝对路径。 例如，如果该程序从        <code>C:\Program Files\Test</code> 执行，则应显示        <code>C:\Program Files\data.txt</code>。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-10-章-日期与时间"><a class="header" href="#第-10-章-日期与时间">第 10 章 日期与时间</a></h1>
<h2 id="101-概述"><a class="header" href="#101-概述">10.1. 概述</a></h2>
<p>库 <a href="http://www.boost.org/libs/date_time/">Boost.DateTime</a>    可用于处理时间数据，如历法日期和时间。 另外，Boost.DateTime 还提供了扩展来处理时区的问题，且支持历法日期和时间的格式化输入与输出。    本章将覆盖 Boost.DateTime 的各个部分。</p>
<hr />
<h2 id="102-历法日期"><a class="header" href="#102-历法日期">10.2. 历法日期</a></h2>
<p>Boost.DateTime 只支持基于格里历的历法日期，这通常不成问题，因为这是最广泛使用的历法。    如果你与其它国家的某人有个会议，时间在2010年1月5日，你可以期望无需与对方确认这个日期是否基于格里历。</p>
<p>格里历是教皇 Gregory XIII 在1582年颁发的。 严格来说，Boost.DateTime    支持由1400年至9999年的历法日期，这意味着它支持1582年以前的日期。 因此，Boost.DateTime    可用于任一历法日期，只要该日期在转换为格里历后是在1400年之后。 如果需要更早的年份，就必须使用其它库来代替。</p>
<p>用于处理历法日期的类和函数位于名字空间 <code>boost::gregorian</code> 中，定义于 <code>boost/date_time/gregorian/gregorian.hpp</code>。    要创建一个日期，请使用 <code>boost::gregorian::date</code> 类。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d(2010, 1, 30); 
  std::cout &lt;&lt; d.year() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.month() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.day() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.day_of_week() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.end_of_month() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::gregorian::date</code> 提供了多个构造函数来进行日期的创建。    最基本的构造函数接受一个年份、一个月份和一个日期作为参数。 如果给定的是一个无效值，则将分别抛出    <code>boost::gregorian::bad_year</code>,    <code>boost::gregorian::bad_month</code> 或    <code>boost::gregorian::bad_day_of_month</code>    类型的异常，这些异常均派生自 <code>std::out_of_range</code>。</p>
<p>正如在这个例子中所示的， 有多个方法用于访问一个日期。 象 <code>year()</code>,    <code>month()</code> 和 <code>day()</code>    这些方法访问用于初始化的初始值，象 <code>day_of_week()</code> 和    <code>end_of_month()</code> 这些方法则访问计算得到的值。</p>
<p>而 <code>boost::gregorian::date</code>    的构造函数则接受年份、月份和日期的值来设定一个日期，调用 <code>month()</code> 方法实际上会显示    <code>Jan</code>，而调用    <code>day_of_week()</code> 则显示    <code>Sat</code>。 它们不是普通的数字值，而分别是    <code>boost::gregorian::date::month_type</code> 和    <code>boost::gregorian::date::day_of_week_type</code> 类型的值。    不过，Boost.DateTime 为格式化的输入输出提供了全面的支持，可以将以上输出从    <code>Jan</code> 调整为    <code>1</code>。</p>
<p>请留意，<code>boost::gregorian::date</code> 的缺省构造函数会创建一个无效的日期。    这样的无效日期也可以通过将 <code>boost::date_time::not_a_date_time</code>    作为单一参数传递给构造函数来显式地创建。</p>
<p>除了直接调用构造函数，也可以通过自由函数或其它对象的方法来创建一个    <code>boost::gregorian::date</code> 类型的对象。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d = boost::gregorian::day_clock::universal_day(); 
  std::cout &lt;&lt; d.year() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.month() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.day() &lt;&lt; std::endl; 

  d = boost::gregorian::date_from_iso_string(&quot;20100131&quot;); 
  std::cout &lt;&lt; d.year() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.month() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.day() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子使用了 <code>boost::gregorian::day_clock</code>    类，它是一个返回当前日期的时钟类。 方法 <code>universal_day()</code> 返回一个与时区及夏时制无关的    UTC 日期。 UTC 是世界时(universal time)的国际缩写。    <code>boost::gregorian::day_clock</code> 还提供了另一个方法    <code>local_day()</code>，它接受本地设置。 要取出本地时区的当前日期，必须使用    <code>local_day()</code>。</p>
<p>名字空间 <code>boost::gregorian</code> 中包含了许多其它自由函数，将保存在字符串中的日期转换为    <code>boost::gregorian::date</code> 类型的对象。 这个例子实际上是通过    <code>boost::gregorian::date_from_iso_string()</code> 函数对一个以 ISO    8601 格式给出的日期进行转换。 还有其它相类似的函数，如    <code>boost::gregorian::from_simple_string()</code> 和    <code>boost::gregorian::from_us_string()</code>。</p>
<p><code>boost::gregorian::date</code> 表示的是一个特定的时间点，而    <code>boost::gregorian::date_duration</code> 则表示了一段时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d1(2008, 1, 31); 
  boost::gregorian::date d2(2008, 8, 31); 
  boost::gregorian::date_duration dd = d2 - d1; 
  std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>由于 <code>boost::gregorian::date</code> 重载了    <code>operator-()</code> 操作符，所以两个时间点可以如上所示那样相减。 返回值的类型为    <code>boost::gregorian::date_duration</code>，表示了两个日期之间的时间长度。</p>
<p><code>boost::gregorian::date_duration</code> 所提供的最重要的方法是    <code>days()</code>，它返回一段时间内所包含的天数。</p>
<p>我们也可以通过传递一个天数作为构造函数的唯一参数，来显式创建    <code>boost::gregorian::date_duration</code> 类型的对象。    要创建涉及星期数、月份数或年数的时间段，可以相应使用 <code>boost::gregorian::weeks</code>,    <code>boost::gregorian::months</code> 和    <code>boost::gregorian::years</code>。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date_duration dd(4); 
  std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; 
  boost::gregorian::weeks ws(4); 
  std::cout &lt;&lt; ws.days() &lt;&lt; std::endl; 
  boost::gregorian::months ms(4); 
  std::cout &lt;&lt; ms.number_of_months() &lt;&lt; std::endl; 
  boost::gregorian::years ys(4); 
  std::cout &lt;&lt; ys.number_of_years() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.4/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::gregorian::months</code> 和    <code>boost::gregorian::years</code> 都无法确定其天数，因为某月或某年所含天数是可长的。    不过，这些类的用法还是可以从以下例子中看出。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d(2009, 1, 31); 
  boost::gregorian::months ms(1); 
  boost::gregorian::date d2 = d + ms; 
  std::cout &lt;&lt; d2 &lt;&lt; std::endl; 
  boost::gregorian::date d3 = d2 - ms; 
  std::cout &lt;&lt; d3 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>该程序将一个月加到给定的日期 January 31, 2009 上，得到 d2，其为    February 28, 2009。 接着，再减回一个月得到 d3，又重新变回 January 31,    2009。 如上所示，时间点和时间长度可用于计算。 不过，需要考虑具体的情况。    例如，从某月的最后一天开始计算，<code>boost::gregorian::months</code>    总是会到达另一个月的最后一天，如果反复前后跳，就可能得到令人惊讶的结果。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d(2009, 1, 30); 
  boost::gregorian::months ms(1); 
  boost::gregorian::date d2 = d + ms; 
  std::cout &lt;&lt; d2 &lt;&lt; std::endl; 
  boost::gregorian::date d3 = d2 - ms; 
  std::cout &lt;&lt; d3 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.6/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子与前一个例子的不同之处在于，初始的日期是 January 30, 2009。 虽然这不是 January    的最后一天，但是向前跳一个月后得到的 d2 还是 February 28, 2009，因为没有    February 30 这一天。 不过，当我们再往回跳一个月，这次得到的 d3 就变成 January 31,    2009! 因为 February 28, 2009 是当月的最后一天，往回跳实际上是返回到 January 的最后一天。</p>
<p>如果你觉得这种行为过于混乱，可以通过取消    <code>BOOST_DATE_TIME_OPTIONAL_GREGORIAN_TYPES</code> 宏的定义来改变这种行为。    取消该宏后，<code>boost::gregorian::weeks</code>,    <code>boost::gregorian::months</code> 和    <code>boost::gregorian::years</code> 类都不再可用。 唯一剩下的类是    <code>boost::gregorian::date_duration</code>，只能指定前向或后向的跳过的天数，这样就不会再有意外的结果了。</p>
<p><code>boost::gregorian::date_duration</code> 表示的是时间长度，而    <code>boost::gregorian::date_period</code>    则提供了对两个日期之间区间的支持。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d1(2009, 1, 30); 
  boost::gregorian::date d2(2009, 10, 31); 
  boost::gregorian::date_period dp(d1, d2); 
  boost::gregorian::date_duration dd = dp.length(); 
  std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.7/main.cpp">下载源代码</a></li>
</ul>
<p>两个类型为 <code>boost::gregorian::date</code>    的参数指定了开始和结束的日期，它们被传递给 <code>boost::gregorian::date_period</code>    的构造函数。 此外，也可以指定一个开始日期和一个类型为    <code>boost::gregorian::date_duration</code> 的时间长度。    请注意，结束日期的前一天才是这个时间区间的最后一天，这对于理解以下例子的输出非常重要。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d1(2009, 1, 30); 
  boost::gregorian::date d2(2009, 10, 31); 
  boost::gregorian::date_period dp(d1, d2); 
  std::cout &lt;&lt; dp.contains(d1) &lt;&lt; std::endl; 
  std::cout &lt;&lt; dp.contains(d2) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.8/main.cpp">下载源代码</a></li>
</ul>
<p>这个程序用 <code>contains()</code> 方法来检查某个给定的日期是否包含在时间区间内。 虽然    d1 和 d2 都是被传递给    <code>boost::gregorian::date_period</code> 的构造函数的，但是    <code>contains()</code> 仅对第一个返回 <code>true</code>。    因为结束日期不是区间的一部分，所以以 d2 调用    <code>contains()</code> 会返回 <code>false</code>。</p>
<p><code>boost::gregorian::date_period</code>    还提供了其它方法，如移动一个区间，或计算两个重叠区间的交集。</p>
<p>除了日期类、时间长度类和时间区间类，Boost.DateTime 还提供了迭代器和其它有用的自由函数，如下例所示。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d(2009, 1, 5); 
  boost::gregorian::day_iterator it(d); 
  std::cout &lt;&lt; *++it &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::date_time::next_weekday(*it, boost::gregorian::greg_weekday(boost::date_time::Friday)) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.9/main.cpp">下载源代码</a></li>
</ul>
<p>为了从一个指定日期向前或向后一天一天地跳，可以使用迭代器    <code>boost::gregorian::day_iterator</code>。 还有    <code>boost::gregorian::week_iterator</code>,    <code>boost::gregorian::month_iterator</code> 和    <code>boost::gregorian::year_iterator</code>    分别提供了按周、按月或是按年跳的迭代器。</p>
<p>这个例子还使用了    <code>boost::date_time::next_weekday()</code>，它基于一个给定的日期返回下一个星期几的日期。    以下程序将显示 <code>2009-Jan-09</code>，因为它是 January 6, 2009    之的第一个Friday。</p>
<hr />
<h2 id="103-位置无关的时间"><a class="header" href="#103-位置无关的时间">10.3. 位置无关的时间</a></h2>
<p><code>boost::gregorian::date</code>    用于创建日期，<code>boost::posix_time::ptime</code> 则用于定义一个位置无关的时间。    <code>boost::posix_time::ptime</code> 会存取    <code>boost::gregorian::date</code> 且额外保存一个时间。</p>
<p>为了使用 <code>boost::posix_time::ptime</code>，必须包含头文件    <code>boost/date_time/posix_time/posix_time.hpp</code>。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0)); 
  boost::gregorian::date d = pt.date(); 
  std::cout &lt;&lt; d &lt;&lt; std::endl; 
  boost::posix_time::time_duration td = pt.time_of_day(); 
  std::cout &lt;&lt; td &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>要初始化一个 <code>boost::posix_time::ptime</code> 类型的对象，要把一个类型为    <code>boost::gregorian::date</code> 的日期和一个类型为    <code>boost::posix_time::time_duration</code>    的时间长度作为第一和第二参数传递给构造函数。 传给    <code>boost::posix_time::time_duration</code> 构造函数的三个参数决定了时间点。    以上程序指定的时间点是 January 5, 2009 的 12 PM。</p>
<p>要查询日期和时间，可以使用 <code>date()</code> 和    <code>time_of_day()</code> 方法。</p>
<p>象 <code>boost::gregorian::date</code>    的缺省构造函数会创建一个无效日期一样，如果使用缺省构造函数，<code>boost::posix_time::ptime</code>    类型的对象也是无效的。 也可以通过传递一个 <code>boost::date_time::not_a_date_time</code>    给构造函数来显式创建一个无效时间。</p>
<p>和使用自由函数或其它对象的方法来创建 <code>boost::gregorian::date</code>    类型的历法日期一样，Boost.DateTime 也提供了相应的自由函数和对象来创建时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt = boost::posix_time::second_clock::universal_time(); 
  std::cout &lt;&lt; pt.date() &lt;&lt; std::endl; 
  std::cout &lt;&lt; pt.time_of_day() &lt;&lt; std::endl; 

  pt = boost::posix_time::from_iso_string(&quot;20090105T120000&quot;); 
  std::cout &lt;&lt; pt.date() &lt;&lt; std::endl; 
  std::cout &lt;&lt; pt.time_of_day() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>类 <code>boost::posix_time::second_clock</code>    表示一个返回当前时间的时钟。 <code>universal_time()</code> 方法返回 UTC 时间，如上例所示。    如果需要本地时间，则必须使用 <code>local_time()</code>。</p>
<p>Boost.DateTime 还提供了一个名为    <code>boost::posix_time::microsec_clock</code>    的类，它返回包含微秒在内的当前时间，供需要更高精度时使用。</p>
<p>要将一个保存在字符串中的时间点转换为类型为    <code>boost::posix_time::ptime</code> 的对象，可以用    <code>boost::posix_time::from_iso_string()</code> 这样的自由函数，它要求传入的时间点以    ISO 8601 格式提供。</p>
<p>除了 <code>boost::posix_time::ptime</code>, Boost.DateTime    也提供了 <code>boost::posix_time::time_duration</code> 类，用于指定一个时间长度。    这个类前面已经提到过，因为 <code>boost::posix_time::ptime</code> 的构造函数实际上需要一个    <code>boost::posix_time::time_duration</code> 类型的对象作为其第二个参数。    当然，<code>boost::posix_time::time_duration</code> 也可以单独使用。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::time_duration td(16, 30, 0); 
  std::cout &lt;&lt; td.hours() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.minutes() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.seconds() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.total_seconds() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>hours()</code>, <code>minutes()</code> 和    <code>seconds()</code> 均返回传给构造函数的各个值，而象    <code>total_seconds()</code>    这样的方法则返回总的秒数，以简单的方式为你提供额外的信息。</p>
<p>可以传递任意值给    <code>boost::posix_time::time_duration</code>，因为没有象24小时这样的上限存在。</p>
<p>和历法日期一样，时间点与时间长度也可以执行运算。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0)); 
  boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(18, 30, 0)); 
  boost::posix_time::time_duration td = pt2 - pt1; 
  std::cout &lt;&lt; td.hours() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.minutes() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.seconds() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.4/main.cpp">下载源代码</a></li>
</ul>
<p>如果两个 <code>boost::posix_time::ptime</code> 类型的时间点相减，结果将是一个    <code>boost::posix_time::time_duration</code>    类型的对象，给出两个时间点之间的时间长度。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0)); 
  boost::posix_time::time_duration td(6, 30, 0); 
  boost::posix_time::ptime pt2 = pt1 + td; 
  std::cout &lt;&lt; pt2.time_of_day() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>正如这个例子所示，时间长度可以被增加至一个时间点上，以得到一个新的时间点。 以上程序将打印    <code>18:30:00</code> 到标准输出流。</p>
<p>你可能已经留意到，Boost.DateTime 对于历法日期和时间使用了相同的概念。    就象有时间类和时间长度类一样，也有一个时间区间的类。 对于历法日期，这个类是    <code>boost::gregorian::date_period</code>; 对于时间则是    <code>boost::posix_time::time_period</code>。 这两个类均要求传入两个参数给构造函数：    <code>boost::gregorian::date_period</code> 要求两个历法日期，而    <code>boost::posix_time::time_period</code> 则要求两个时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0)); 
  boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(18, 30, 0)); 
  boost::posix_time::time_period tp(pt1, pt2); 
  std::cout &lt;&lt; tp.contains(pt1) &lt;&lt; std::endl; 
  std::cout &lt;&lt; tp.contains(pt2) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.6/main.cpp">下载源代码</a></li>
</ul>
<p>大致上说，<code>boost::posix_time::time_period</code> 非常象    <code>boost::gregorian::date_period</code>。 它提供了一个名为    <code>contains()</code> 的方法，对于位于该时间区间内的每一个时间点，它返回    <code>true</code>。 由于传给    <code>boost::posix_time::time_period</code>    的构造函数的结束时间不是时间区间的一部分，所以上例中第二个 <code>contains()</code> 调用将返回    <code>false</code>。</p>
<p><code>boost::posix_time::time_period</code> 还提供了其它方法，如    <code>intersection()</code> 和 <code>merge()</code>    分别用于计算两个重叠时间区间的交集，以及合并两个相交区间。</p>
<p>最后，迭代器 <code>boost::posix_time::time_iterator</code>    用于对时间点进行迭代。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/local_time/local_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0)); 
  boost::posix_time::time_iterator it(pt, boost::posix_time::time_duration(6, 30, 0)); 
  std::cout &lt;&lt; *++it &lt;&lt; std::endl; 
  std::cout &lt;&lt; *++it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.7/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序使用了迭代器 it 从时间点 pt    开始向前跳6.5个小时 。 由于迭代器被递增两次，所以相应的输出分别为 <code>2009-Jan-05    18:30:00</code> 和 <code>2009-Jan-06    01:00:00</code>。</p>
<hr />
<h2 id="104-位置相关的时间"><a class="header" href="#104-位置相关的时间">10.4. 位置相关的时间</a></h2>
<p>和前一节所介绍的位置无关时间不一样，位置相关时间是要考虑时区的。 为此，Boost.DateTime 提供了    <code>boost::local_time::local_date_time</code> 类，它定义于 <code>boost/date_time/local_time/local_time.hpp</code>,    并使用 <code>boost::local_time::posix_time_zone</code>    来保存时区信息。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/local_time/local_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+1&quot;)); 
  boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0)); 
  boost::local_time::local_date_time dt(pt, tz); 
  std::cout &lt;&lt; dt.utc_time() &lt;&lt; std::endl; 
  std::cout &lt;&lt; dt &lt;&lt; std::endl; 
  std::cout &lt;&lt; dt.local_time() &lt;&lt; std::endl; 
  std::cout &lt;&lt; dt.zone_name() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.4.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::local_time::local_date_time</code> 的构造函数要求一个    <code>boost::posix_time::ptime</code> 类型的对象作为其第一个参数，以及一个    <code>boost::local_time::time_zone_ptr</code> 类型的对象作为第二个参数。 后者只不过是    <code>boost::shared_ptr&lt;boost::local_time::posix_time_zone&gt;</code>    的类型定义。 换句话说，并不是传递一个    <code>boost::local_time::posix_time_zone</code>    对象，而是传递一个指向该对象的智能指针。 这样，多个    <code>boost::local_time::local_date_time</code> 类型的对象就可以共享时区信息。    只有当最后一个对象被销毁时，相应的表示时区的对象才会被自动释放。</p>
<p>要创建一个 <code>boost::local_time::posix_time_zone</code>    类型的对象，就要将一个描述该时区的字符串作为单一参数传递给构造函数。 以上例子指定了欧洲中部时区：CET 是欧洲中部时间(Central    European Time)的缩写。 由于 CET 比 UTC 早一个小时，所以时差以 +1 表示。 Boost.DateTime    并不能解释时区的缩写，也就不知道 CET 的意思。 所以，必须以小时数给出时差；传入 +0 表示没有时差。</p>
<p>在执行时，该程序将打印 <code>2009-Jan-05 12:00:00</code>,    <code>2009-Jan-05 13:00:00 CET</code>,    <code>2009-Jan-05 13:00:00</code> 和    <code>CET</code> 到标准输出流。 用以初始化    <code>boost::posix_time::ptime</code> 和    <code>boost::local_time::local_date_time</code> 类型的值缺省总是与 UTC    时区相关的。 只有当一个 <code>boost::local_time::local_date_time</code>    类型的对象被写出至标准输出流时，或者调用 <code>local_time()</code>    方法时，才使用时差来计算本地时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/local_time/local_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+1&quot;)); 
  boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0)); 
  boost::local_time::local_date_time dt(pt, tz); 
  std::cout &lt;&lt; dt.local_time() &lt;&lt; std::endl; 
  boost::local_time::time_zone_ptr tz2(new boost::local_time::posix_time_zone(&quot;EET+2&quot;)); 
  std::cout &lt;&lt; dt.local_time_in(tz2).local_time() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>通过使用 <code>local_time()</code> 方法，时区的偏差才被考虑进来。 为了计算 CET    时间，需要往保存在 dt 中的 UTC 时间 12 PM 上加一个小时，因为 CET 比 UTC 早一个小时。    <code>local_time()</code> 会相应地输出 <code>2009-Jan-05    13:00:00</code> 到标准输出流。</p>
<p>相比之下，<code>local_time_in()</code> 方法是在所传入参数的时区内解释保存在    dt 中的时间。 这意味着 12 PM UTC 相当于 2 PM EET，即东部欧洲时间，它比 UTC    早两个小时。</p>
<p>最后，Boost.DateTime 通过    <code>boost::local_time::local_time_period</code>    类提供了位置相关的时间区间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/local_time/local_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+0&quot;)); 
  boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0)); 
  boost::local_time::local_date_time dt1(pt1, tz); 
  boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(18, 0, 0)); 
  boost::local_time::local_date_time dt2(pt2, tz); 
  boost::local_time::local_time_period tp(dt1, dt2); 
  std::cout &lt;&lt; tp.contains(dt1) &lt;&lt; std::endl; 
  std::cout &lt;&lt; tp.contains(dt2) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.4.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::local_time::local_time_period</code>    的构造函数要求两个类型为 <code>boost::local_time::local_date_time</code>    的参数。 和其它类型的时间区间一样，第二个参数所表示的结束时间并不包含在区间之内。 通过如    <code>contains()</code>, <code>intersection()</code>,    <code>merge()</code> 以及其它的方法，时间区间可以与其它    <code>boost::local_time::local_time_period</code> 相互操作。</p>
<hr />
<h2 id="105-格式化输入输出"><a class="header" href="#105-格式化输入输出">10.5. 格式化输入输出</a></h2>
<p>本章中的所有例子在执行后都提供形如 <code>2009-Jan-07</code>    这样的输出结果。 有的人可能更喜欢用其它格式来显示结果。 Boost.DateTime 允许    <code>boost::date_time::date_facet</code> 和    <code>boost::date_time::time_facet</code> 类来格式化历法日期和时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;locale&gt; 

int main() 
{ 
  boost::gregorian::date d(2009, 1, 7); 
  boost::gregorian::date_facet *df = new boost::gregorian::date_facet(&quot;%A, %d %B %Y&quot;); 
  std::cout.imbue(std::locale(std::cout.getloc(), df)); 
  std::cout &lt;&lt; d &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.5.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.DateTime 使用了 locales 的概念，它来自于 C++ 标准，在 <a href="./stringhandling.html">第 5 章 <em>字符串处理</em></a> 中有概括的介绍。 要格式化一个历法日期，必须创建一个    <code>boost::date_time::date_facet</code> 类型的对象并安装在一个 locale 内。    一个描述新格式的字符串被传递给 <code>boost::date_time::date_facet</code> 的构造函数。    上面的例子传递的是 <code>%A, %d %B %Y</code>，指定格式为：星期几后跟日月年全名：    <code>Wednesday, 07 January 2009</code>。</p>
<p>Boost.DateTime 提供了多个格式化标志，标志由一个百分号后跟一个字符组成。 Boost.DateTime    的文档中对于所支持的所有标志有一个完整的介绍。 例如，%A 表示星期几的全名。</p>
<p>如果应用程序的基本用户是位于德国或德语国家，最好可以用德语而不是英语来显示星期几和月份。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;locale&gt; 
#include &lt;string&gt; 
#include &lt;vector&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string months[12] = { &quot;Januar&quot;, &quot;Februar&quot;, &quot;März&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;, &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot; }; 
  std::string weekdays[7] = { &quot;Sonntag&quot;, &quot;Montag&quot;, &quot;Dienstag&quot;, &quot;Mittwoch&quot;, &quot;Donnerstag&quot;, &quot;Freitag&quot;, &quot;Samstag&quot; }; 
  boost::gregorian::date d(2009, 1, 7); 
  boost::gregorian::date_facet *df = new boost::gregorian::date_facet(&quot;%A, %d. %B %Y&quot;); 
  df-&gt;long_month_names(std::vector&lt;std::string&gt;(months, months + 12)); 
  df-&gt;long_weekday_names(std::vector&lt;std::string&gt;(weekdays, weekdays + 7)); 
  std::cout.imbue(std::locale(std::cout.getloc(), df)); 
  std::cout &lt;&lt; d &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.5.2/main.cpp">下载源代码</a></li>
</ul>
<p>星期几和月份的名字可以通过分别传入两个数组给    <code>boost::date_time::date_facet</code> 类的    <code>long_month_names()</code> 和    <code>long_weekday_names()</code> 方法来修改，这两个数组分别包含了相应的名字。    以上例子现在将打印 <code>Mittwoch, 07. Januar 2009</code>    到标准输出流。</p>
<p>Boost.DateTime 在格式化输入输出方面是非常灵活的。 除了输出类    <code>boost::date_time::date_facet</code> 和    <code>boost::date_time::time_facet</code> 以外，类    <code>boost::date_time::date_input_facet</code> 和    <code>boost::date_time::time_input_facet</code> 可用于格式化输入。    所有这四个类都提供了许多方法，来为 Boost.DateTime 所提供的各种不同对象配置输入和输出的方式。 例如，可以指定    <code>boost::gregorian::date_period</code> 类型的时间长度如何输入和输出。    要弄清楚各种格式化输入输出的可能性，请参考 Boost.DateTime 的文档。</p>
<hr />
<h2 id="106-练习"><a class="header" href="#106-练习">10.6. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>创建一个程序，打印下一个 Christmas Eve, Christmas Day        及其后一天是星期几到标准输出流。</li>
<li>以天数计算你的年龄。 该程序应该自动根据当前日期来计算。</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-11-章-序列化"><a class="header" href="#第-11-章-序列化">第 11 章 序列化</a></h1>
<hr />
<h2 id="111-概述"><a class="header" href="#111-概述">11.1. 概述</a></h2>
<p>Boost C++ 的 <a href="http://www.boost.org/libs/serialization/">序列化</a> 库允许将 C++    应用程序中的对象转换为一个字节序列， 此序列可以被保存，并可在将来恢复对象的时候再次加载。 各种不同的数据格式，包括    XML，只要具有一定规则的数据格式，在序列化后都产生一个字节序列。所有 Boost.Serialization    支持的格式，在某些方面来说都是专有的。 比如 XML 格式不同用来和不是用 C++ Boost.Serialization    库开发的应用程序交换数据。所有以 XML 格式存储的数据适合于从之前存储的数据上恢复同一个 C++ 对象。 XML 格式的唯一优点是序列化的 C++    对象容易理解，这是很有用的，比如说在调试的时候。</p>
<hr />
<h2 id="112-归档"><a class="header" href="#112-归档">11.2. 归档</a></h2>
<p>Boost.Serialization 的主要概念是归档。 归档的文件是相当于序列化的 C++ 对象的一个字节流。    对象可以通过序列化添加到归档文件，相应地也可从归档文件中加载。 为了恢复和之前存储相同的 C++ 对象，需假定数据类型是相同的。</p>
<p>下面看一个简单的例子。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::archive::text_oarchive oa(std::cout); 
  int i = 1; 
  oa &lt;&lt; i; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.Serialization 提供了多个归档类，如    <code>boost::archive::text_oarchive </code>类，它定义在 <code>boost/archive/text_oarchive.hpp</code> 文件中。    <code>boost::archive::text_oarchive</code>，可将对象序列化为文本流。 上面的应用程序将    <code>22 serialization::archive 5 1</code>    写出到标准输出流。</p>
<p>可见， <code>boost::archive::text_oarchive </code> 类型的对象    oa 可以用来像流 (stream) 一样通过 <code>&lt;&lt; </code>来序列化对象。    尽管如此，归档也不能被认为是可以存储任何数据的常规的流。 为了以后恢复数据，必须以相同的顺序使用和先前存储时用的一样的数据类型。    下面的例子序列化和恢复了 <code>int</code> 类型的变量。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

void save() 
{ 
  std::ofstream file(&quot;archiv.txt&quot;); 
  boost::archive::text_oarchive oa(file); 
  int i = 1; 
  oa &lt;&lt; i; 
} 

void load() 
{ 
  std::ifstream file(&quot;archiv.txt&quot;); 
  boost::archive::text_iarchive ia(file); 
  int i = 0; 
  ia &gt;&gt; i; 
  std::cout &lt;&lt; i &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>当 <code>boost::archive::text_oarchive</code>    被用来把数据序列化为文本流， <code>boost::archive::text_iarchive</code>    就用来从文本流恢复数据。 为了使用这些类，必须包含 <code>boost/archive/text_iarchive.hpp</code> 头文件。</p>
<p>归档的构造函数需要一个输入或者输出流作为参数。 流分别用来序列化或恢复数据。 虽然上面的应用程序使用了一个文件流，其他流，如    stringstream 流也是可以的。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 

std::stringstream ss; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  int i = 1; 
  oa &lt;&lt; i; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  int i = 0; 
  ia &gt;&gt; i; 
  std::cout &lt;&lt; i &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>这个应用程序也向标准输出流写了 <code>1</code>。 然而，与前面的例子相比,    数据却是用 stringstream 流序列化的。</p>
<p>到目前为止， 原始的数据类型已经被序列化了。 接下来的例子演示如何序列化用户定义类型的对象。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age) 
    : age_(age) 
  { 
  } 

  int age() const 
  { 
    return age_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; age_; 
  } 

  int age_; 
}; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  person p(31); 
  oa &lt;&lt; p; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  person p; 
  ia &gt;&gt; p; 
  std::cout &lt;&lt; p.age() &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>为了序列化用户定义类型的对话， <code>serialize()</code>    函数必须定义，它在对象序列化或从字节流中恢复是被调用。 由于 <code>serialize ()</code>    函数既用来序列化又用来恢复数据， Boost.Serialization 除了 <code>&lt;&lt; </code> 和    <code>&gt;&gt; </code>之外还提供了 <code>&amp;</code> 操作符。如果使用这个操作符，就不再需要在    <code>serialize()</code> 函数中区分是序列化和恢复了。</p>
<p><code>serialize ()</code>    在对象序列化或恢复时自动调用。它应从来不被明确地调用，所以应生命为私有的。 这样的话，    <code>boost::serialization::access</code> 类必须被声明为友元，以允许    Boost.Serialization 能够访问到这个函数。</p>
<p>有些情况下需要添加 <code>serialize()</code> 函数却不能修改现有的类。 比如，对于来自    C++ 标准库或其他库的类就是这样的。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age) 
    : age_(age) 
  { 
  } 

  int age() const 
  { 
    return age_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version); 

  int age_; 
}; 

template &lt;typename Archive&gt; 
void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) 
{ 
  ar &amp; p.age_; 
} 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  person p(31); 
  oa &lt;&lt; p; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  person p; 
  ia &gt;&gt; p; 
  std::cout &lt;&lt; p.age() &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>为了序列化那些不能被修改的数据类型，要定义一个单独的函数    <code>serialize()</code>，如上面的例子所示。 这个函数需要相应的数据类型的引用作为它的第二个参数。</p>
<p>如果要被序列化的数据类型中含有不能经由公有函数访问的私有属性，事情就变得复杂了。 在这种情况下，该数据列席就需要修改。    在上面应用程序中的 <code>serialize ()</code> 函数如果不声明为 <code>friend    </code>，就不能访问 age_ 属性。</p>
<p>不过还好，Boost.Serialization 为许多C++标准库的类提供了    <code>serialize()</code> 函数。 为了序列化基于 C++ 标准库的类，需要包含额外的头文件。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;boost/serialization/string.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 
#include &lt;string&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age, const std::string &amp;name) 
    : age_(age), name_(name) 
  { 
  } 

  int age() const 
  { 
    return age_; 
  } 

  std::string name() const 
  { 
    return name_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version); 

  int age_; 
  std::string name_; 
}; 

template &lt;typename Archive&gt; 
void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) 
{ 
  ar &amp; p.age_; 
  ar &amp; p.name_; 
} 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  person p(31, &quot;Boris&quot;); 
  oa &lt;&lt; p; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  person p; 
  ia &gt;&gt; p; 
  std::cout &lt;&lt; p.age() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.name() &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.2.6/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子扩展了 <code>person </code> 类，增加了 <code>std::string    </code>类型的名称变量，为了序列化这个属性property, the header file <code>boost/serialization/string.hpp </code>    头文件必须包含，它提供了合适的单独的 <code>serialize ()</code> 函数。</p>
<p>正如前面所提到的， Boost.Serialization 为许多 C++ 标准库类定义了 <code>serialize    ()</code> 函数。 这些都定义在和 C++ 标准库头文件名称相对应的头文件中。 为了序列化 <code>std::string    </code> 类型的对象，必须包含 <code>boost/serialization/string.hpp </code> 头文件。 为了序列化    <code>std::vector </code> 类型的对象，必须包含 <code>boost/serialization/vector.hpp </code> 头文件。    于是在给定的场合中应该包含哪个头文件就显而易见了。</p>
<p>还有一个 <code>serialize ()</code>函数的参数，到目前为止我们一直忽略没谈到，那就是    version 。 如果归档需要向前兼容，以支持给定应用程序的未来版本，那么这个参数就是有意义的。    接下来的例子考虑到 <code>person </code> 类的归档需要向前兼容。由于 <code>person    </code> 的原始版本没有包含任何名称，新版本的 <code>person </code>    应该能够处理不带名称的旧的归档。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;boost/serialization/string.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 
#include &lt;string&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age, const std::string &amp;name) 
    : age_(age), name_(name) 
  { 
  } 

  int age() const 
  { 
    return age_; 
  } 

  std::string name() const 
  { 
    return name_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version); 

  int age_; 
  std::string name_; 
}; 

template &lt;typename Archive&gt; 
void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) 
{ 
  ar &amp; p.age_; 
  if (version &gt; 0) 
    ar &amp; p.name_; 
} 

BOOST_CLASS_VERSION(person, 1) 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  person p(31, &quot;Boris&quot;); 
  oa &lt;&lt; p; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  person p; 
  ia &gt;&gt; p; 
  std::cout &lt;&lt; p.age() &lt;&lt; std::endl; 
  std::cout &lt;&lt; p.name() &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.2.7/main.cpp">下载源代码</a></li>
</ul>
<p><code>BOOST_CLASS_VERSION </code> 宏用来指定类的版本号。 上面例子中    <code>person </code> 类的版本号设置为1。 如果没有使用 <code>BOOST_CLASS_VERSION    </code> ， 版本号缺省是0。</p>
<p>版本号存储在归档文件中，因此也就是归档的一部份。 当一个特定类的版本号通过 <code>BOOST_CLASS_VERSION    </code> 宏，在序列化时给定时， <code>serialize ()</code> 函数的 version     参数被设为给定值存储在归档中。 如果新版本的 <code>person </code>    访问一个包含旧版本序列化对象的归档时， name_  由于旧版本不含有这个属性而不能恢复。    通过这种机制，Boost.Serialization 提供了向前兼容归档的支持。</p>
<hr />
<h2 id="113-指针和引用"><a class="header" href="#113-指针和引用">11.3. 指针和引用</a></h2>
<p>Boost.Serialization 还能序列化指针和引用。    由于指针存储对象的地址，序列化对象的地址没有什么意义，而是在序列化指针和引用时，对象的引用被自动地序列化。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age) 
    : age_(age) 
  { 
  } 

  int age() const 
  { 
    return age_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; age_; 
  } 

  int age_; 
}; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  person *p = new person(31); 
  oa &lt;&lt; p; 
  std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl; 
  delete p; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  person *p; 
  ia &gt;&gt; p; 
  std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl; 
  std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl; 
  delete p; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>上面的应用程序创建了一个新的 <code>person </code> 类型的对象，使用 <code>new    </code> 创建并赋值给指针 p 。 是指针 - 而不是 <code>*p </code> -    被序列化了。Boost.Serialization 自动地通过 p     的引用序列化对象本身而不是对象的地址。</p>
<p>如果归档被恢复， p  不必指向相同的地址。 而是创建新对象并将它的地址赋值给    p  。 Boost.Serialization    只保证对象和之前序列化的对象相同，而不是地址相同。</p>
<p>由于新式的 C++ 在动态分配内存有关的地方使用 智能指针 (smart pointers) ， Boost.Serialization    对此也提供了相应的支持。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;boost/serialization/scoped_ptr.hpp&gt; 
#include &lt;boost/scoped_ptr.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age) 
    : age_(age) 
  { 
  } 

  int age() const 
  { 
    return age_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; age_; 
  } 

  int age_; 
}; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  boost::scoped_ptr&lt;person&gt; p(new person(31)); 
  oa &lt;&lt; p; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  boost::scoped_ptr&lt;person&gt; p; 
  ia &gt;&gt; p; 
  std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>例子中使用了智能指针 <code>boost::scoped_ptr </code> 来管理动态分配的    <code>person </code> 类型的对象。 为了序列化这样的指针，必须包含 <code>boost/serialization/scoped_ptr.hpp </code>    头文件。</p>
<p>在使用 <code>boost::shared_ptr </code> 类型的智能指针的时候需要序列化，那么必须包含    <code>boost/serialization/shared_ptr.hpp </code>    头文件。</p>
<p>下面的应用程序使用引用替代了指针。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age) 
    : age_(age) 
  { 
  } 

  int age() const 
  { 
    return age_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; age_; 
  } 

  int age_; 
}; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  person p(31); 
  person &amp;pp = p; 
  oa &lt;&lt; pp; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  person p; 
  person &amp;pp = p; 
  ia &gt;&gt; pp; 
  std::cout &lt;&lt; pp.age() &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>可见，Boost.Serialization 还能没有任何问题地序列化引用。 就像指针一样，引用对象被自动地序列化。</p>
<hr />
<h2 id="114-对象类层次结构的序列化"><a class="header" href="#114-对象类层次结构的序列化">11.4. 对象类层次结构的序列化</a></h2>
<p>为了序列化基于类层次结构的对象，子类必须在 <code>serialize ()</code>函数中访问    <code>boost::serialization::base_object ()</code>。    此函数确保继承自基类的属性也能正确地序列化。 下面的例子演示了一个名为 <code>developer </code>    类，它继承自类 <code>person </code> 。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;boost/serialization/string.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 
#include &lt;string&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age) 
    : age_(age) 
  { 
  } 

  int age() const 
  { 
    return age_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; age_; 
  } 

  int age_; 
}; 

class developer 
  : public person 
{ 
public: 
  developer() 
  { 
  } 

  developer(int age, const std::string &amp;language) 
    : person(age), language_(language) 
  { 
  } 

  std::string language() const 
  { 
    return language_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; boost::serialization::base_object&lt;person&gt;(*this); 
    ar &amp; language_; 
  } 

  std::string language_; 
}; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  developer d(31, &quot;C++&quot;); 
  oa &lt;&lt; d; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  developer d; 
  ia &gt;&gt; d; 
  std::cout &lt;&lt; d.age() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.language() &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.4.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>person </code> 和 <code>developer </code>    这两个类都包含有一个私有的 <code>serialize ()</code> 函数， 它使得基于其他类的对象能被序列化。 由于    <code>developer </code> 类继承自 <code>person </code>类，    所以它的 <code>serialize ()</code> 函数必须确保继承自 <code>person    </code> 属性也能被序列化。</p>
<p>继承自基类的属性被序列化是通过在子类的 <code>serialize ()</code> 函数中用    <code>boost::serialization::base_object ()</code> 函数访问基类实现的。    在例子中强制要求使用这个函数而不是 <code>static_cast </code> 是因为只有    <code>boost::serialization::base_object ()</code> 才能保证正确地序列化。</p>
<p>动态创建对象的地址可以被赋值给对应的基类类型的指针。 下面的例子演示了 Boost.Serialization    还能够正确地序列化它们。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;boost/serialization/string.hpp&gt; 
#include &lt;boost/serialization/export.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 
#include &lt;string&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age) 
    : age_(age) 
  { 
  } 

  virtual int age() const 
  { 
    return age_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; age_; 
  } 

  int age_; 
}; 

class developer 
  : public person 
{ 
public: 
  developer() 
  { 
  } 

  developer(int age, const std::string &amp;language) 
    : person(age), language_(language) 
  { 
  } 

  std::string language() const 
  { 
    return language_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; boost::serialization::base_object&lt;person&gt;(*this); 
    ar &amp; language_; 
  } 

  std::string language_; 
}; 

BOOST_CLASS_EXPORT(developer) 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  person *p = new developer(31, &quot;C++&quot;); 
  oa &lt;&lt; p; 
  delete p; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  person *p; 
  ia &gt;&gt; p; 
  std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl; 
  delete p; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>应用程序在 <code>save ()</code> 函数创建了 <code>developer    </code> 类型的对象并赋值给 <code>person* </code> 类型的指针，接下来通过 <code>&lt;&lt;    </code> 序列化。</p>
<p>正如在前面章节中提到的， 引用对象被自动地序列化。 为了让 Boost.Serialization 识别将要序列化的    <code>developer </code> 类型的对象，即使指针是 <code>person* </code> 类型的对象。    <code>developer </code> 类需要相应的声明。 这是通过这个    <code>BOOST_CLASS_EXPORT </code> 宏实现的，它定义在 <code>boost/serialization/export.hpp </code> 文件中。 因为    <code>developer </code> 这个数据类型没有指针形式的定义，所以 Boost.Serialization    没有这个宏就不能正确地序列化 <code>developer </code> 。</p>
<p>如果子类对象需要通过基类的指针序列化，那么 <code>BOOST_CLASS_EXPORT </code> 宏必须要用。</p>
<p>由于静态注册的原因， <code>BOOST_CLASS_EXPORT </code>    的一个缺点是可能有些注册的类最后是不需要序列化的。 Boost.Serialization 为这种情况提供一种解决方案。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;boost/serialization/string.hpp&gt; 
#include &lt;boost/serialization/export.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 
#include &lt;string&gt; 

std::stringstream ss; 

class person 
{ 
public: 
  person() 
  { 
  } 

  person(int age) 
    : age_(age) 
  { 
  } 

  virtual int age() const 
  { 
    return age_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; age_; 
  } 

  int age_; 
}; 

class developer 
  : public person 
{ 
public: 
  developer() 
  { 
  } 

  developer(int age, const std::string &amp;language) 
    : person(age), language_(language) 
  { 
  } 

  std::string language() const 
  { 
    return language_; 
  } 

private: 
  friend class boost::serialization::access; 

  template &lt;typename Archive&gt; 
  void serialize(Archive &amp;ar, const unsigned int version) 
  { 
    ar &amp; boost::serialization::base_object&lt;person&gt;(*this); 
    ar &amp; language_; 
  } 

  std::string language_; 
}; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  oa.register_type&lt;developer&gt;(); 
  person *p = new developer(31, &quot;C++&quot;); 
  oa &lt;&lt; p; 
  delete p; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  ia.register_type&lt;developer&gt;(); 
  person *p; 
  ia &gt;&gt; p; 
  std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl; 
  delete p; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.4.3/main.cpp">下载源代码</a></li>
</ul>
<p>上面的应用程序没有使用 <code>BOOST_CLASS_EXPORT </code> 宏，而是调用了    <code>register_type ()</code> 模板函数。 需要注册的类型作为模板参数传入。</p>
<p>请注意 <code>register_type ()</code> 必须在 <code>save    ()</code> 和 <code>load ()</code> 都要调用。</p>
<p><code>register_type ()</code> 的优点是只有需要序列化的类才注册。    比如在开发一个库时，你不知道开发人员将来要序列化哪些类。 当然 <code>BOOST_CLASS_EXPORT </code>    宏用起来简单，可它却可能注册那些不需要序列化的类型。</p>
<hr />
<h2 id="115-优化用封装函数"><a class="header" href="#115-优化用封装函数">11.5. 优化用封装函数</a></h2>
<p>在理解了如何序列化对象之后，本节介绍用来优化序列化过程的封装函数。 通过这个函数，对象被打上标记允许    Boost.Serialization 使用一些优化技术。</p>
<p>下面例子使用不带封装函数的 Boost.Serialization 。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;boost/array.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 

std::stringstream ss; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  boost::array&lt;int, 3&gt; a = { 0, 1, 2 }; 
  oa &lt;&lt; a; 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  boost::array&lt;int, 3&gt; a; 
  ia &gt;&gt; a; 
  std::cout &lt;&lt; a[0] &lt;&lt; &quot;, &quot; &lt;&lt; a[1] &lt;&lt; &quot;, &quot; &lt;&lt; a[2] &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.5.1/main.cpp">下载源代码</a></li>
</ul>
<p>上面的应用程序创建一个文本流 <code>22 serialization::archive 5 0 0 3 0 1    2</code> 并将其写到标准输出流中。 使用封装函数    <code>boost::serialization::make_array ()</code> ，输出可以缩短到    <code>22 serialization::archive 5 0 1 2</code>    。</p>
<pre><code class="language-c++">#include &lt;boost/archive/text_oarchive.hpp&gt; 
#include &lt;boost/archive/text_iarchive.hpp&gt; 
#include &lt;boost/serialization/array.hpp&gt; 
#include &lt;boost/array.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;sstream&gt; 

std::stringstream ss; 

void save() 
{ 
  boost::archive::text_oarchive oa(ss); 
  boost::array&lt;int, 3&gt; a = { 0, 1, 2 }; 
  oa &lt;&lt; boost::serialization::make_array(a.data(), a.size()); 
} 

void load() 
{ 
  boost::archive::text_iarchive ia(ss); 
  boost::array&lt;int, 3&gt; a; 
  ia &gt;&gt; boost::serialization::make_array(a.data(), a.size()); 
  std::cout &lt;&lt; a[0] &lt;&lt; &quot;, &quot; &lt;&lt; a[1] &lt;&lt; &quot;, &quot; &lt;&lt; a[2] &lt;&lt; std::endl; 
} 

int main() 
{ 
  save(); 
  load(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/11.5.2/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::serialization::make_array ()</code> 函数需要地址和数组的长度。    由于长度是硬编码的，所以它不需要作为 <code>boost::array </code> 类型的一部分序列化。任何时候，如果    <code>boost::array </code> 或 <code>std::vector </code>    包含一个可以直接序列化的数组，都可以使用这个函数。 其他一般需要序列化的属性不能被序列化。</p>
<p>另一个 Boost.Serialization 提供的封装函数是    <code>boost::serialization::make_binary_object ()</code> 。 与    <code>boost::serialization::make_array ()</code> 类似，它也需要地址和长度。    <code>boost::serialization::make_binary_object ()</code>    函数只是为了用来序列化没有底层结构的二进制数据，而 <code>boost::serialization::make_array    ()</code> 是用来序列化数组的。</p>
<hr />
<h2 id="116-练习"><a class="header" href="#116-练习">11.6. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>开发一个应用程序，能够将任意个数有名称，部门和雇员唯一标识号构成的记录， 序列化到文件并从中恢复。        记录应该在恢复后在屏幕上显示。 用样本记录测试应用程序。</li>
<li>扩展上面的应用程序，为每个雇员存储生日。 应用程序应该还可以恢复 在上面的练习创建的的旧版本的记录。</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-12-章-词法分析器"><a class="header" href="#第-12-章-词法分析器">第 12 章 词法分析器</a></h1>
<h2 id="121-概述"><a class="header" href="#121-概述">12.1. 概述</a></h2>
<p>词法分析器用于读取各种格式的数据，这些数据可以具有灵活但可能非常复杂的结构。 关于&quot;格式&quot;的一个最好的例子就是 C++ 代码。    编译器的词法分析器必须理解 C++ 的各种可能的语言结构组合，以将它们翻译为某种二进制形式。</p>
<p>开发词法分析器的主要问题是所分析的数据的组成结构具有大量的规则。 例如，C++    支持很多的语言结构，开发一个相应的词法分析器可能需要无数个 <code>if</code> 表达式来识别任意所能想象到的 C++    代码是否有效。</p>
<p>本章所介绍的 <a href="http://www.boost.org/libs/spirit/">Boost.Spirit</a>    库将词法分析器的开发放到了桌面上来。 无需将明确的规则转换为代码并使用无数的 <code>if</code>    表达式来验证代码，Boost.Spirit 可以使用一种被称为扩展BNF范式的东西来表示规则。 通过使用这些规则，Boost.Spirit    就可以对一个 C++ 源代码进行分析。</p>
<p>Boost.Spirit 的基本思想类似于正则表达式。 即不用 <code>if</code>    表达式来查找指定模式的文本，而是将模式以正则表达式的方式指定出来。 然后就可以使用象 Boost.Regex    这样的库来执行相应的查找国，因此开发者无需关心其中的细节。</p>
<p>本章将示范如何用 Boost.Spirit 来读入正则表达式不再适用的复杂格式。 由于 Boost.Spirit    是一个功能非常全的库，引入了多个不同的概念，所以在本章我们将开发一个 <a href="http://www.json.org/">JSON 格式</a> 的简单的词法分析器。 JSON 是被如 Ajax    一类的应用程序用于在程序之间交换数据的格式，类似于 XML，可以在不同平台上运行。</p>
<p>虽然 Boost.Spirit 简化了词法分析器的开发，但是还没有人能够成功地基于这个库写出一个 C++ 词法分析器。    这类词法分析器的开发仍然是 Boost.Spirit 的一个长期目标，不过，由于 C++ 语言的复杂性，目前还未能实现。 Boost.Spirit    目前还不能很好地适用于这种复杂性或二进制格式。</p>
<hr />
<h2 id="122-扩展bnf范式"><a class="header" href="#122-扩展bnf范式">12.2. 扩展BNF范式</a></h2>
<p>Backus-Naur 范式，简称 BNF，是一种精确描述规则的语言，被应用于多种技术规范。 例如，众多互联网协议的许多技术规范，称为    RFC，除了文字说明以外，都包含了以 BNF 编写的规则。</p>
<p>Boost.Spirit 支持扩展BNF范式(EBNF)，可以用比 BNF 更简短的方式来指定规则。 EBNF    的主要优点就是简短，从而写法更简单。</p>
<p>请注意，EBNF 有几种不同的变体，它们的语法可能有些差异。 本章以及 Boost.Spirit 所使用的 EBNF    语法类似于正则表达式。</p>
<p>要使用 Boost.Spirit，你必须懂得 EBNF。 多数情况下，开发者已经知道 EBNF，因此才会选择 Boost.Spirit    来重用以前用 EBNF 表示的规则。 以下是对 EBNF 的一个简短介绍；如果需要对本章当中以及 Boost.Spirit    所使用的语法有一个快速的参考，请查看 W3C XML 规范，其中包含了一个 <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#sec-notation">短摘要</a>。</p>
<table><thead><tr><th><code>digit</code></th><th>=</th><th>&quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;</th></tr></thead><tbody>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p>严格地讲，EBNF 以生成规则来表示规则。 可以将任意数量的生成规则组合起来，描述一个特定的格式。 以上格式只包含一个生成规则。    它定义了一个 <code>digit</code>    是由0至9之间的任一数字组成。</p>
<p>象 <code>digit</code> 这样的定义被称为非终结符号。    以上定义中的数字 0 到 9 则被称为终结符号。 这些符号不具有任意特定意义，而且很容易识别出来，因为它们是用双引号引起来的。</p>
<p>所有数字值是用竖直符相连的，其意义与 C++ 中的 <code>||</code> 操作符一样：多选一。</p>
<p>一句话，这个生成规则指明了0至9之间的任一数字都是一个 <code>digit</code>。</p>
<table><thead><tr><th><code>integer</code></th><th>=</th><th>(&quot;+&quot; | &quot;-&quot;)? <code>digit</code>+</th></tr></thead><tbody>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p>这个新的非终结符 <code>integer</code>    包含至少一个 <code>digit</code>，而且可选地以一个加号或减号开头。</p>
<p><code>integer</code> 的定义用到了多个新的操作符。    圆括号用于创建一个子表达式，就象它在数学中的作用。 其它操作符可应用于这些子表达式。 问号表示这个子表达式只能出现一次或不出现。</p>
<p><code>digit</code>    之后的加号表示相应的表达式必须出现至少一次。</p>
<p>这个新的生成规则定义了一个任意的正或负的整数。 一个 <code>digit</code> 正好是一个数字，而一个 <code>integer</code> 则可以由多个数字组成，且可以被标记为无符号的或有符号的。 因此 5    即是一个 <code>digit</code> 也是一个 <code>integer</code>，而 +5 则只是一个 <code>integer</code>。 同样地，169 或 -8 也只是 <code>integer</code>。</p>
<p>通过定义和组合各种非终结符，可以创建越来越复杂的生成规则。</p>
<table><thead><tr><th><code>real</code></th><th>=</th><th><code>integer</code> &quot;.&quot;        <code>digit</code>*</th></tr></thead><tbody>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p><code>integer</code> 的定义表示的是整数，而    <code>real</code> 的定义则表示了浮点数。    这个规则基于前面已定义的非终结符 <code>integer</code> 和    <code>digit</code>，以一个句点号分隔。 <code>digit</code>    之后的星类表示点号之后的数字是可选的：可以有任意多个数字或没有数字。</p>
<p>浮点数如 1.2, -16.99 甚至 3. 都符合 <code>real</code> 的定义。 但是，当前的定义不允许浮点数不带前导的零，如 .9。</p>
<p>正如本章开始的时候所提到的，接下来我们要用 Boost.Spirit 开发一个 JSON 格式的词法分析器。 为此，需要用 EBNF    来给出 JSON 格式的规则。</p>
<table><thead><tr><th><code>object</code></th><th>=</th><th>&quot;{&quot; <code>member</code> (&quot;,&quot;        <code>member</code>)* &quot;}&quot;</th></tr></thead><tbody>
<tr><td><code>member</code></td><td>=</td><td><code>string</code> &quot;:&quot;        <code>value</code></td></tr>
<tr><td><code>string</code></td><td>=</td><td>'&quot;' <code>character</code>*        '&quot;'</td></tr>
<tr><td><code>value</code></td><td>=</td><td><code>string</code></td></tr>
<tr><td><code>number</code></td><td>=</td><td><code>integer</code></td></tr>
<tr><td><code>array</code></td><td>=</td><td>&quot;[&quot; <code>value</code> (&quot;,&quot;        <code>value</code>)* &quot;]&quot;</td></tr>
<tr><td><code>character</code></td><td>=</td><td>&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; | &quot;j&quot; | &quot;k&quot; |        &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; | &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot;        | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;</td></tr>
</tbody></table>
<p>JSON 格式基于一些包含了键值和值的成对的对象，它们被花括号括起来。    其中键值是普通的字符串，而值可以是字符串、数字值、数组、其它对象或是字面值 <code>true</code>,    <code>false</code> 或 <code>null</code>。 字符串是由双引号引起来的连续字符。    数字值可以是整数或浮点数。 数组包含以逗号分隔的值，并以方括号括起来。</p>
<p>请注意，以上定义并不完整。 一方面，<code>character</code> 的定义缺少了大写字母以及其它字符；另一方面，JSON    还特别支持 Unicode 或控制字符。 这些现在都可以先忽略掉，因为 Boost.Spirit    定义了常用的非终结符号，如字母数字字符，以减少你打字的次数。 另外，稍后在代码中，字符串被定义为除双引号以外的任意字符的连续串。    由于双引号用于结束一个字符串，所以其它所有字符都在字符串中使用。 上述 EBNF 并不如此表示，因为 EBNF    要求定义一个包含除单个字符外的所有字符的非终结符号，应该定义一个例外来排除。</p>
<p>以下是使用了上述定义的 JSON 格式的一个例子。</p>
<pre><code class="language-json">{
  &quot;Boris Schäling&quot; :
  {
    &quot;Male&quot;: true,
    &quot;Programming Languages&quot;: [ &quot;C++&quot;, &quot;Java&quot;, &quot;C#&quot; ],
    &quot;Age&quot;: 31
  }
}
</code></pre>
<p>整个对象由最外层的花括号给出，它包含了一个键-值对。 键值是 &quot;Boris Schäling&quot;，值则是一个新的对象，包含多个键-值对。    其中所有键值均为字符串，而值则分别为字面值 <code>true</code>，一个包含几个字符串的数组，以及一个数字值。</p>
<p>以上所定义的 EBNF 规则现在就可用于通过 Boost.Spirit 开发一个可以读取以上 JSON 格式的词法分析器。</p>
<hr />
<h2 id="123-语法"><a class="header" href="#123-语法">12.3. 语法</a></h2>
<p>继上一节中以 EBNF 为 JSON 格式定义了相关规则后，现在要将这些规则与 Boost.Spirit 一起使用。    Boost.Spirit 实际上允许以 C++ 代码来定义 EBNF 规则，方法是重载各个由 EBNF 使用的不同操作符。</p>
<p>请注意，EBNF 规则需要稍作修改，才能创建出合法的 C++ 代码。 在 EBNF 中各个符号是以空格相连的，在 C++    中需要用某个操作符来连接。 此外，象星号、问号和加号这些操作符，在 EBNF 中是置于对应的符号后面的，在 C++    中必须置于符号的前面，才能作为单参操作符来使用。</p>
<p>以下是在 Boost.Spirit 中为表示 JSON 格式，用 C++ 代码写的 EBNF 规则。</p>
<pre><code class="language-c++">#include &lt;boost/spirit.hpp&gt; 

struct json_grammar 
  : public boost::spirit::grammar&lt;json_grammar&gt; 
{ 
  template &lt;typename Scanner&gt; 
  struct definition 
  { 
    boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array; 

    definition(const json_grammar &amp;self) 
    { 
      using namespace boost::spirit; 
      object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;; 
      member = string &gt;&gt; &quot;:&quot; &gt;&gt; value; 
      string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;; 
      value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;; 
      number = real_p; 
      array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;; 
    } 

    const boost::spirit::rule&lt;Scanner&gt; &amp;start() 
    { 
      return object; 
    } 
  }; 
}; 

int main() 
{ 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/12.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>为了使用 Boost.Spirit 中的各个类，需要包含头文件 <code>boost/spirit.hpp</code>。 所有类均位于名字空间    <code>boost::spirit</code> 内。</p>
<p>为了用 Boost.Spirit 创建一个词法分析器，除了那些定义了数据是如何构成的规则以外，还必须创建一个所谓的语法。    在上例中，就创建一个 <code>json_grammar</code> 类，它派生自模板类    <code>boost::spirit::grammar</code>，并以该类的名字来实例化。    <code>json_grammar</code> 定义了理解 JSON 格式所需的完整语法。</p>
<p>语法的一个最重要的组成部分就是正确读入结构化数据的规则。 这些规则在一个名为    <code>definition</code> 的内层类中定义 - 这个名字是强制性的。 这个类是带有一个模板参数的模板类，由    Boost.Spirit 以一个所谓的扫描器来进行实例化。 扫描器是 Boost.Spirit 内部使用的一个概念。 虽然强制要求    <code>definition</code> 必须是以一个扫描器类型作为其模板参数的模板类，但是对于 Boost.Spirit    的日常使用来说，这些扫描器是什么以及为什么要定义它们，并不重要。</p>
<p><code>definition</code> 必须定义一个名为    <code>start()</code> 的方法，它会被 Boost.Spirit 调用，以获得该语法的完整规则和标准。    这个方法的返回值是 <code>boost::spirit::rule</code>    的一个常量引用，它也是一个以扫描器类型实例化的模板类。</p>
<p><code>boost::spirit::rule</code> 类用于定义规则。 非终结符号就以这个类来定义。    前面所定义的非终结符号 <code>object</code>,    <code>member</code>, <code>string</code>, <code>value</code>, <code>number</code> 和 <code>array</code> 的类型均为    <code>boost::spirit::rule</code>。</p>
<p>所有这些对象都被定义为 <code>definition</code>    类的属性，这并非强制性的，但简化了定义，尤其是当各个规则之间有递归引用时。 正如在上一节中所看到的 EBNF    例子那样，递归引用并不是一个问题。</p>
<p>乍一看，在 <code>definition</code> 的构造函数内的规则定义非常类似于在上一节中看到的    EBNF 生成规则。 这并不奇怪，因为这正是 Boost.Spirit 的目标：重用在 EBNF 中定义的生成规则。</p>
<p>由于是用 C++ 代码来组成 EBNF 中建立的规则，为了写出合法的 C++，其实是有一点点差异的。 例如，所有符号间的连接是通过    <code>&gt;&gt;</code> 操作符完成的。 EBNF 中的一些操作符，如星号，被置于相应符号的前面而非后面。    尽管有这样一些语法上的修改，Boost.Spirit 还是尽量在将 EBNF 规则转换至 C++ 代码时不进行太多的修改。</p>
<p><code>definition</code> 的构造函数使用了由 Boost.Spirit    提供的两个类：<code>boost::spirit::ch_p</code> 和    <code>boost::spirit::real_p</code>。 这些以分析器形式提供的常用规则可以很方便地重用。    一个例子就是    <code>boost::spirit::real_p</code>，它可以用于保存正或负的整数或浮点数，无需定义象    <code>digit</code> 或 <code>real</code> 这样的非终结符号。</p>
<p><code>boost::spirit::ch_p</code>    可用于创建一个针对单个字符的分析器，相当于将字符置于双引号中。    在上例中，<code>boost::spirit::ch_p</code>    的使用是强制性的，因为波浪号和星号是要应用于双引号之上的。 没有这个类，代码将变为    <code>*~&quot;\&quot;&quot;</code>，这会被编译器拒绝为非法代码。</p>
<p>波浪号实际上是实现了前一节中提到的一个技巧：在双引号之前加上波浪号，可以接受除双引号以外的所有其它字符。</p>
<p>定义完了识别 JSON 格式的规则后，以下例子示范了如何使用这些规则。</p>
<pre><code class="language-c++">#include &lt;boost/spirit.hpp&gt; 
#include &lt;fstream&gt; 
#include &lt;sstream&gt; 
#include &lt;iostream&gt; 

struct json_grammar 
  : public boost::spirit::grammar&lt;json_grammar&gt; 
{ 
  template &lt;typename Scanner&gt; 
  struct definition 
  { 
    boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array; 

    definition(const json_grammar &amp;self) 
    { 
      using namespace boost::spirit; 
      object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;; 
      member = string &gt;&gt; &quot;:&quot; &gt;&gt; value; 
      string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;; 
      value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;; 
      number = real_p; 
      array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;; 
    } 

    const boost::spirit::rule&lt;Scanner&gt; &amp;start() 
    { 
      return object; 
    } 
  }; 
}; 

int main(int argc, char *argv[]) 
{ 
  std::ifstream fs(argv[1]); 
  std::ostringstream ss; 
  ss &lt;&lt; fs.rdbuf(); 
  std::string data = ss.str(); 

  json_grammar g; 
  boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p); 
  if (pi.hit) 
  { 
    if (pi.full) 
      std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl; 
    else 
      std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl; 
    std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl; 
  } 
  else 
    std::cout &lt;&lt; &quot;parsing failed; stopped at '&quot; &lt;&lt; pi.stop &lt;&lt; &quot;'&quot; &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/12.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.Spirit 提供了一个名为 <code>boost::spirit::parse()</code>    的自由函数。 通过创建一个语法的实例，就会相应地创建一个词法分析器，该分析器被作为第二个参数传递给    <code>boost::spirit::parse()</code>。    第一个参数表示要进行分析的文本，而第三个参数则是一个表明在给定文本中哪些字符将被跳过的词法分析器。 为了跳过空格，要将一个类型为    <code>boost::spirit::space_p</code> 的对象作为第三个参数传入。 这只是表示在被捕获的数据之间    - 换句话说，就是规则中使用了 <code>&gt;&gt;</code> 操作符的地方 - 可以有任意数量的空格。    这其中包含了制表符和换行符，令数据的格式可以更为灵活。</p>
<p><code>boost::spirit::parse()</code> 返回一个类型为    <code>boost::spirit::parse_info</code>    的对象，该对象提供了四个属性来表示文本是否被成功分析。 如果文本被成功分析，则属性 hit 被设置为    <code>true</code>。 如果文本中的所有字符都被分析完了，最后没有剩余空格，则    full 也被设置为 <code>true</code>。 仅当    hit 为 <code>true</code>    时，length 是有效的，其中保存了被成功分析的字符数量。</p>
<p>如果文本未能分析成功，则属性 length 不能被访问。 此时，可以访问属性    stop 来获得停止分析的文本位置。 如果文本被成功分析，stop    也是可访问的，只不过没什么意义，因为此时它肯定是指向被分析文本之后。</p>
<hr />
<h2 id="124-动作"><a class="header" href="#124-动作">12.4. 动作</a></h2>
<p>到目前为止，你已经知道了如何定义一个语法，以得到一个新的词法分析器，用于识别一个给定的文本是否具有该语法的规则所规定的结构。    但是此刻，数据的格式仍未被解释，因为从结构化格式如 JSON 中所读取的数据并没有被进一步处理。</p>
<p>要对由分析器识别出来的符合某个特定规则的数据进行处理，可以使用动作(action)。 动作是一些与规则相关联的函数。    如果词法分析器识别出某些数据符合某个特定的规则，则相关联的动作会被执行，并把识别得到的数据传入进行处理，如下例所示。</p>
<pre><code class="language-c++">#include &lt;boost/spirit.hpp&gt; 
#include &lt;string&gt; 
#include &lt;fstream&gt; 
#include &lt;sstream&gt; 
#include &lt;iostream&gt; 

struct json_grammar 
  : public boost::spirit::grammar&lt;json_grammar&gt; 
{ 
  struct print 
  { 
    void operator()(const char *begin, const char *end) const 
    { 
      std::cout &lt;&lt; std::string(begin, end) &lt;&lt; std::endl; 
    } 
  }; 

  template &lt;typename Scanner&gt; 
  struct definition 
  { 
    boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array; 

    definition(const json_grammar &amp;self) 
    { 
      using namespace boost::spirit; 
      object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;; 
      member = string[print()] &gt;&gt; &quot;:&quot; &gt;&gt; value; 
      string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;; 
      value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;; 
      number = real_p; 
      array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;; 
    } 

    const boost::spirit::rule&lt;Scanner&gt; &amp;start() 
    { 
      return object; 
    } 
  }; 
}; 

int main(int argc, char *argv[]) 
{ 
  std::ifstream fs(argv[1]); 
  std::ostringstream ss; 
  ss &lt;&lt; fs.rdbuf(); 
  std::string data = ss.str(); 

  json_grammar g; 
  boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p); 
  if (pi.hit) 
  { 
    if (pi.full) 
      std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl; 
    else 
      std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl; 
    std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl; 
  } 
  else 
    std::cout &lt;&lt; &quot;parsing failed; stopped at '&quot; &lt;&lt; pi.stop &lt;&lt; &quot;'&quot; &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/12.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>动作被实现为函数或函数对象。 如果动作需要被初始化或是要在多次执行之间维护某些状态信息，则后者更好一些。    以上例子中将动作实现为函数对象。</p>
<p>类 <code>print</code> 是一个函数对象，它将数据写出至标准输出流。 当其被调用时，重载的    <code>operator()()</code>    操作符将接受一对指向数据起始点和结束点的指针，所指范围即为被执行该动作的规则所识别出来的数据。</p>
<p>这个例子将这个动作关联至在 <code>member</code>    之后作为第一个符号出现的非终结符号 <code>string</code>。    一个类型为 <code>print</code> 的实例被放在方括号内传递给非终结符号 <code>string</code>。 由于 <code>string</code> 表示的是 JSON 对象的键-值对中的键，所以每次找到一个键时，类    <code>print</code> 中的重载 <code>operator()()</code>    操作符将被调用，将该键写出到标准输出流。</p>
<p>我们可以定义任意数量的动作，或将它们关联至任意数量的符号。 要把一个动作关联至一个字面值，必须明确给出一个词法分析器。 这与在非终结符号    <code>string</code> 的定义中指定    <code>boost::spirit::ch_p</code> 类没什么不同。 以下例子使用了    <code>boost::spirit::str_p</code> 类来将一个    <code>print</code> 类型的对象关联至字面值 <code>true</code>。</p>
<pre><code class="language-c++">#include &lt;boost/spirit.hpp&gt; 
#include &lt;string&gt; 
#include &lt;fstream&gt; 
#include &lt;sstream&gt; 
#include &lt;iostream&gt; 

struct json_grammar 
  : public boost::spirit::grammar&lt;json_grammar&gt; 
{ 
  struct print 
  { 
    void operator()(const char *begin, const char *end) const 
    { 
      std::cout &lt;&lt; std::string(begin, end) &lt;&lt; std::endl; 
    } 

    void operator()(const double d) const 
    { 
      std::cout &lt;&lt; d &lt;&lt; std::endl; 
    } 
  }; 

  template &lt;typename Scanner&gt; 
  struct definition 
  { 
    boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array; 

    definition(const json_grammar &amp;self) 
    { 
      using namespace boost::spirit; 
      object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;; 
      member = string[print()] &gt;&gt; &quot;:&quot; &gt;&gt; value; 
      string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;; 
      value = string | number | object | array | str_p(&quot;true&quot;)[print()] | &quot;false&quot; | &quot;null&quot;; 
      number = real_p[print()]; 
      array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;; 
    } 

    const boost::spirit::rule&lt;Scanner&gt; &amp;start() 
    { 
      return object; 
    } 
  }; 
}; 

int main(int argc, char *argv[]) 
{ 
  std::ifstream fs(argv[1]); 
  std::ostringstream ss; 
  ss &lt;&lt; fs.rdbuf(); 
  std::string data = ss.str(); 

  json_grammar g; 
  boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p); 
  if (pi.hit) 
  { 
    if (pi.full) 
      std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl; 
    else 
      std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl; 
    std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl; 
  } 
  else 
    std::cout &lt;&lt; &quot;parsing failed; stopped at '&quot; &lt;&lt; pi.stop &lt;&lt; &quot;'&quot; &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/12.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>另外，这个例子还将一个动作关联至 <code>boost::spirit::real_p</code>。    大多数分析器会传递一对指向被识别数据起始点和结束点的指针，而    <code>boost::spirit::real_p</code> 则将所找到的数字作为    <code>double</code> 来传递。 这样可以使对数字的处理更为方便，因为这些数字不再需要被显式转换。 为了传递一个    <code>double</code> 类型的值给这个动作，我们相应地增加了一个重载的    <code>operator()()</code> 操作符给    <code>print</code>。</p>
<p>除了在本章中介绍过的分析器，如 <code>boost::spirit::str_p</code> 或    <code>boost::spirit::real_p</code> 以外，Boost.Spirit 还提供了很多其它的分析器。    例如，如果要使用正则表达式，我们有 <code>boost::spirit::regex_p</code> 可用。    此外，还有用于验证条件或执行循环的分析器。 它们有助于创建动态的词法分析器，根据条件来对数据进行不同的处理。 要对 Boost.Spirit    提供的这些工具有一个大概的了解，你应该看一下这个库的文档。</p>
<hr />
<h2 id="125-练习"><a class="header" href="#125-练习">12.5. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>开发一个可以对任意整数和浮点数进行加减的计算器。 这个计算器接受形如 <strong><code>=-4+8 +        1.5</code></strong> 的输入，并显示结果 <code>5.5</code>。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-13-章-容器"><a class="header" href="#第-13-章-容器">第 13 章 容器</a></h1>
<h2 id="131-概述"><a class="header" href="#131-概述">13.1. 概述</a></h2>
<p>这一章将会介绍许多我们在 C++ 标准中已经很熟悉的容器的 Boost 版本。  在这一章里，  我们会对 Boost.Unordered 的用法有一定的了解 （这个容器已经在 TR1 里被加入到了 C++ 标准）； 我们将会学习如何定义一个 Boost.MultiIndex； 我们还会了解何时应该使用 MuitiIndex 的一个特殊的扩展 —— Boost.Bimap。 接下来， 我们会向你介绍第一个容器 —— Boost.Array， 通过使用它， 你可以把 C++ 标准里普通的数组以容器的形式实现。</p>
<hr />
<h2 id="132-boostarray"><a class="header" href="#132-boostarray">13.2. Boost.Array</a></h2>
<p>库 <a href="http://www.boost.org/libs/array/">Boost.Array</a> 在 <code>boost/array.hpp</code> 中定义了一个模板类 <code>boost::array</code> 。 通过使用这个类， 你可以创建一个跟 C++ 里传统的数组有着相同属性的容器。 而且，  <code>boost::array</code> 还满足了 C++ 中容器的一切需求， 因此， 你可以像操作容器一样方便的操作这个 array。 基本上， 你可以把  <code>boost::array</code> 当成  <code>std::vector</code> 来使用， 只不过  <code>boost::array</code> 是定长的。</p>
<pre><code class="language-c++">#include &lt;boost/array.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 
#include &lt;algorithm&gt; 

int main() 
{ 
  typedef boost::array&lt;std::string, 3&gt; array; 
  array a; 

  a[0] = &quot;Boris&quot;; 
  a.at(1) = &quot;Anton&quot;; 
  *a.rbegin() = &quot;Caesar&quot;; 

  std::sort(a.begin(), a.end()); 

  for (array::const_iterator it = a.begin(); it != a.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 

  std::cout &lt;&lt; a.size() &lt;&lt; std::endl; 
  std::cout &lt;&lt; a.max_size() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>就像我们在上面的例子看到的那样，  <code>boost::array</code> 简直就是简单的不需要任何多余的解释， 因为所有操作都跟 <code>std::vector</code> 是一样的。</p>
<p>在下面的例子里， 我们会见识到 Boost.Array 的一个特性。</p>
<pre><code class="language-c++">#include &lt;boost/array.hpp&gt; 
#include &lt;string&gt; 

int main() 
{ 
  typedef boost::array&lt;std::string, 3&gt; array; 
  array a = { &quot;Boris&quot;, &quot;Anton&quot;, &quot;Caesar&quot; }; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>一个 <code>boost::array</code> 类型的数组可以使用传统 C++ 数组的初始化方式来初始化。</p>
<p>既然这个容器已经在 TR1 中加入到了 C++ 标准， 它同样可以通过  <code>std::array</code> 来访问到。 他被定义在头文件  <code>array</code> 中， 使用它的前提是你正在使用一个支持 TR1 的 C++ 标准的库。</p>
<hr />
<h2 id="133-boostunordered"><a class="header" href="#133-boostunordered">13.3. Boost.Unordered</a></h2>
<p><a href="http://www.boost.org/libs/unordered/">Boost.Unordered</a> 在 C++ 标准容器 <code>std::set</code>， <code>std::multiset</code>， <code>std::map</code> 和 <code>std::multimap</code> 的基础上多实现了四个容器：  <code>boost::unordered_set</code>， <code>boost::unordered_multiset</code>， <code>boost::unordered_map</code> 和 <code>boost::unordered_multimap</code>。 那些名字很相似的容器之间并没有什么不同， 甚至还提供了相同的接口。 在很多情况下， 替换这两种容器 (std 和 boost) 对你的应用不会造成任何影响。</p>
<p>Boost.Unordered 和 C++ 标准里的容器的不同之处在于—— Boost.Unordered 不要求其中的元素是可排序的， 因为它不会做出排序操作。  在排序操作无足轻重时（或是根本不需要）， Boost.Unordered 就很合适了。</p>
<p>为了能够快速的查找元素， 我们需要使用 Hash 值。 Hash 值是一些可以唯一标识容器中元素的数字， 它在比较时比起类似 String 的数据类型会更加有效率。 为了计算 Hash 值， 容器中的所有元素都必须支持对他们自己唯一 ID 的计算。 比如 <code>std::set</code> 要求其中的元素都要是可比较的， 而 <code>boost::unordered_set</code> 要求其中的元素都要可计算 Hash 值。 尽管如此， 在对排序没有需求时， 你还是应该倾向使用 Boost.Unordered 。</p>
<p>下面的例子展示了 <code>boost::unordered_set</code> 的用法。</p>
<pre><code class="language-c++">#include &lt;boost/unordered_set.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  typedef boost::unordered_set&lt;std::string&gt; unordered_set; 
  unordered_set set; 

  set.insert(&quot;Boris&quot;); 
  set.insert(&quot;Anton&quot;); 
  set.insert(&quot;Caesar&quot;); 

  for (unordered_set::iterator it = set.begin(); it != set.end(); ++it) 
    std::cout &lt;&lt; *it &lt;&lt; std::endl; 

  std::cout &lt;&lt; set.size() &lt;&lt; std::endl; 
  std::cout &lt;&lt; set.max_size() &lt;&lt; std::endl; 

  std::cout &lt;&lt; (set.find(&quot;David&quot;) != set.end()) &lt;&lt; std::endl; 
  std::cout &lt;&lt; set.count(&quot;Boris&quot;) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.3.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::unordered_set</code> 提供了与  <code>std::set</code> 相似的函数。 当然， 这个例子不需要多大改进就可以用 <code>std::set</code> 来实现。</p>
<p>下面的例子展示了如何用 <code>boost::unordered_map</code> 来存储每一个的 person 的 name 和 age。</p>
<pre><code class="language-c++">#include &lt;boost/unordered_map.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  typedef boost::unordered_map&lt;std::string, int&gt; unordered_map; 
  unordered_map map; 

  map.insert(unordered_map::value_type(&quot;Boris&quot;, 31)); 
  map.insert(unordered_map::value_type(&quot;Anton&quot;, 35)); 
  map.insert(unordered_map::value_type(&quot;Caesar&quot;, 25)); 

  for (unordered_map::iterator it = map.begin(); it != map.end(); ++it) 
    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;, &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl; 

  std::cout &lt;&lt; map.size() &lt;&lt; std::endl; 
  std::cout &lt;&lt; map.max_size() &lt;&lt; std::endl; 

  std::cout &lt;&lt; (map.find(&quot;David&quot;) != map.end()) &lt;&lt; std::endl; 
  std::cout &lt;&lt; map.count(&quot;Boris&quot;) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>就像我们看到的， <code>boost::unordered_map</code> 和 <code>std::map</code> 之间并没多大区别。 同样地， 你可以很方便的用 <code>std::map</code> 来重新实现这个例子。</p>
<p>就像上面提到过的， Boost.Unordered 需要其中的元素可计算 Hash 值。 一些类似于 <code>std::string</code> 的数据类型“天生”就支持 Hash 值的计算。 对于那些自定义的类型， 你需要手动的定义 Hash 函数。</p>
<pre><code class="language-c++">#include &lt;boost/unordered_set.hpp&gt; 
#include &lt;string&gt; 

struct person 
{ 
  std::string name; 
  int age; 

  person(const std::string &amp;n, int a) 
    : name(n), age(a) 
  { 
  } 

  bool operator==(const person &amp;p) const 
  { 
    return name == p.name &amp;&amp; age == p.age; 
  } 
}; 

std::size_t hash_value(person const &amp;p) 
{ 
  std::size_t seed = 0; 
  boost::hash_combine(seed, p.name); 
  boost::hash_combine(seed, p.age); 
  return seed; 
} 

int main() 
{ 
  typedef boost::unordered_set&lt;person&gt; unordered_set; 
  unordered_set set; 

  set.insert(person(&quot;Boris&quot;, 31)); 
  set.insert(person(&quot;Anton&quot;, 35)); 
  set.insert(person(&quot;Caesar&quot;, 25)); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>在代码中， <code>person</code> 类型的元素被存到了  <code>boost::unordered_set</code> 中。 因为  <code>boost::unordered_set</code> 中的 Hash 函数不能识别 <code>person</code> 类型， Hash 值就变得无法计算了。 若果没有定义另一个 Hash 函数， 你的代码将不会通过编译。</p>
<p>Hash 函数的签名必须是： <code>hash_value()</code>。 它接受唯一的一个参数来指明需要计算 Hash 值的对象的类型。 因为 Hash 值是单纯的数字， 所以函数的返回值为： <code>std::size_t</code>。</p>
<p>每当一个对象需要计算它的 Hash 值时，  <code>hash_value()</code> 都会自动被调用。 Boost C++ 库已经为一些数据类型定义好了 Hash 函数， 比如： <code>std::string</code>。 但对于像  <code>person</code> 这样的自定义类型， 你就需要自己手工定义了。 </p>
<p><code>hash_value()</code> 的实现往往都很简单： 你只需要按顺序对其中的每个属性都调用 Boost 在 <code>boost/functional/hash.hpp</code> 中提供的 <code>boost::hash_combine()</code> 函数就行了。 当你使用 Boost.Unordered 时， 这个头文件已经自动被包含了。</p>
<p>除了自定义 <code>hash_value()</code> 函数， 自定义的类型还需要支持通过 <code>==</code> 运算符的比较操作。 因此，  <code>person</code> 就重载了相应的  <code>operator==()</code> 操作符。</p>
<hr />
<h2 id="134-boostmultiindex"><a class="header" href="#134-boostmultiindex">13.4. Boost.MultiIndex</a></h2>
<p><a href="http://www.boost.org/libs/multi_index/">Boost.MultiIndex</a> 比我们之前介绍的任何库都要复杂。 不像 Boost.Array 和  Boost.Unordered 为我们提供了可以直接使用的容器，  Boost.MultiIndex 让我们可以自定义新的容器。 跟 C++ 标准中的容器不同的是：  一个用户自定义的容器可以对其中的数据提供多组访问接口。 举例来说， 你可以定义一个类似于  <code>std::map</code> 的容器， 但它可以通过 value 值来查询。 如果不用 Boost.MultiIndex， 你就需要自己整合两个  <code>std::map</code> 类型的容器， 还要自己处理一些同步操作来确保数据的完整性。</p>
<p>下面这个例子就用 Boost.MultiIndex 定义了一个新容器来存储每个人的 name 和 age， 不像 <code>std::map</code>， 这个容器可以分别通过 name 和 age 来查询（std::map 只能用一个值）。</p>
<pre><code class="language-c++">#include &lt;boost/multi_index_container.hpp&gt; 
#include &lt;boost/multi_index/hashed_index.hpp&gt; 
#include &lt;boost/multi_index/member.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

struct person 
{ 
  std::string name; 
  int age; 

  person(const std::string &amp;n, int a) 
    : name(n), age(a) 
  { 
  } 
}; 

typedef boost::multi_index::multi_index_container&lt; 
  person, 
  boost::multi_index::indexed_by&lt; 
    boost::multi_index::hashed_non_unique&lt; 
      boost::multi_index::member&lt; 
        person, std::string, &amp;person::name 
      &gt; 
    &gt;, 
    boost::multi_index::hashed_non_unique&lt; 
      boost::multi_index::member&lt; 
        person, int, &amp;person::age 
      &gt; 
    &gt; 
  &gt; 
&gt; person_multi; 

int main() 
{ 
  person_multi persons; 

  persons.insert(person(&quot;Boris&quot;, 31)); 
  persons.insert(person(&quot;Anton&quot;, 35)); 
  persons.insert(person(&quot;Caesar&quot;, 25)); 

  std::cout &lt;&lt; persons.count(&quot;Boris&quot;) &lt;&lt; std::endl; 

  const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;(); 
  std::cout &lt;&lt; age_index.count(25) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>就像上面提到的， Boost.MultiIndex 并没有提供任何特定的容器而是一些类来方便我们定义新的容器。 典型的做法是： 你需要用到  <code>typedef</code> 来为你的新容器提供对 Boost.MultiIndex 中类的方便的访问。</p>
<p>每个容器定义都需要的类  <code>boost::multi_index::multi_index_container</code> 被定义在了 <code>boost/multi_index_container.hpp</code> 里。 因为他是一个模板类， 你需要为它传递两个模板参数。 第一个参数是容器中储存的元素类型， 在例子中是 <code>person</code>； 而第二个参数指明了容器所提供的所有索引类型。</p>
<p>基于 Boost.MultiIndex 的容器最大的优势在于： 他对一组同样的数据提供了多组访问接口。 访问接口的具体细节都可以在定义容器时被指定。 因为例子中的 person 为 age 和 name 都提供了查询功能， 我们必须要定义两组接口。 </p>
<p>接口的定义必须借由模板类  <code>boost::multi_index::indexed_by</code> 来实现。 每一个接口都作为参数传递给它。 例子中定义了两个  <code>boost::multi_index::hashed_non_unique</code> 类型的接口，（定义在头文件 <code>boost/multi_index/hashed_index.hpp</code> 中） 如果你希望容器像 Boost.Unordered 一样存储一些可以计算 Hash 值的元素， 你就可以使用这个接口。</p>
<p><code>boost::multi_index::hashed_non_unique</code> 是一个模板类， 他需要一个可计算 Hash 值的类型作为它的参数。 因为接口需要访问 person 中的 name 和 age， 所以 name 和 age 都要是可计算 Hash 值的。</p>
<p>Boost.MultiIndex 提供了一个辅助模板类：  <code>boost::multi_index::member</code> （定义在 <code>boost/multi_index/member.hpp</code> 中） 来访问类中的属性。 就像我们在例子中所看到的， 我们指定了好几个参数来让  <code>boost::multi_index::member</code> 明白可以访问  <code>person</code> 中的哪些属性以及这些属性的类型。</p>
<p>不得不说 <code>person_multi</code> 的定义第一眼看起来相当复杂， 但这个类本身跟 Boost.Unordered 中的 <code>boost::unordered_map</code> 并没有什么不同， 他也可以分别通过其中的两个属性 name 和 age 来查询容器。</p>
<p>为了访问 MultiIndex 容器， 你必须要定义至少一个接口。 如果用 <code>insert()</code> 或者 <code>count()</code> 来直接访问 persons 对象， 第一个接口会被隐式的调用 —— 在例子中是 name 属性的 Hash 容器。 如果你想用其他接口， 你必须要显示的指定它。</p>
<p>接口都是用从0开始的索引值来编号的。 想要访问第二个接口， 你需要调用  <code>get()</code> 函数并且传入想要访问的接口的索引值。</p>
<p>函数 <code>get()</code> 的返回值看起来也有点复杂： 他是一个用来访问 MultiIndex 容器的类 <code>nth_index</code> ， 同样的， 你也需要指定需要访问的接口的索引值。 当然， 这个值肯定跟  <code>get()</code> 函数指定的模板参数是一样的。 最后一步：   用 <code>::</code> 来得到 <code>nth_index</code> 的 <code>type</code>， 也就是接口的真正的<code>type</code>。</p>
<p>虽然我们并不知道细节就用 <code>nth_index</code> 和 <code>type</code> 得到了接口， 我们还是需要明白这到底是什么接口。  通过传给 <code>get()</code> 和  <code>nth_index</code> 的索引值， 我们就可以很容易得知所使用的哪一个接口了。 例子中的 age_index 就是一个通过 age 来访问的 Hash 容器。</p>
<p>既然 MultiIndex 容器中的 name 和 key 作为了接口访问的键值， 他们都不能再被更改了。 比如一个 person 的  age 在通过 name 搜索以后被改变了，  使用 age 作为键值的接口却意识不到这种更改， 因此， 你需要重新计算 Hash 值才行。</p>
<p>就像 <code>std::map</code> 一样， MultiIndex  容器中的值也不允许被修改。 严格的说， 所有存储在 MultiIndex 中的元素都该是常量。 为了避免删除或修改其中元素真正的值，  Boost.MultiIndex 提供了一些常用函数来操作其中的元素。 使用这些函数来操作 MultiIndex  容器中的值并不会引起那些元素所指向的真正的对象改变， 所以更新动作是安全的。 而且所有接口都会被通知这种改变， 然后去重新计算新的 Hash  值等。</p>
<pre><code class="language-c++">#include &lt;boost/multi_index_container.hpp&gt; 
#include &lt;boost/multi_index/hashed_index.hpp&gt; 
#include &lt;boost/multi_index/member.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

struct person 
{ 
  std::string name; 
  int age; 

  person(const std::string &amp;n, int a) 
    : name(n), age(a) 
  { 
  } 
}; 

typedef boost::multi_index::multi_index_container&lt; 
  person, 
  boost::multi_index::indexed_by&lt; 
    boost::multi_index::hashed_non_unique&lt; 
      boost::multi_index::member&lt; 
        person, std::string, &amp;person::name 
      &gt; 
    &gt;, 
    boost::multi_index::hashed_non_unique&lt; 
      boost::multi_index::member&lt; 
        person, int, &amp;person::age 
      &gt; 
    &gt; 
  &gt; 
&gt; person_multi; 

void set_age(person &amp;p) 
{ 
  p.age = 32; 
} 

int main() 
{ 
  person_multi persons; 

  persons.insert(person(&quot;Boris&quot;, 31)); 
  persons.insert(person(&quot;Anton&quot;, 35)); 
  persons.insert(person(&quot;Caesar&quot;, 25)); 

  person_multi::iterator it = persons.find(&quot;Boris&quot;); 
  persons.modify(it, set_age); 

  const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;(); 
  std::cout &lt;&lt; age_index.count(32) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>每个 Boost.MultiIndex 中的接口都支持  <code>modify()</code> 函数来提供直接对容器本身的操作。 它的第一个参数是一个需要更改对象的迭代器； 第二参数则是一个对该对象进行操作的函数。 在例子中， 对应的两个参数则是：  <code>person</code> 和 <code>set_age()</code> 。</p>
<p>至此， 我们都还只介绍了一个接口：  <code>boost::multi_index::hashed_non_unique</code> ， 他会计算其中元素的 Hash 值， 但并不要求是唯一的。 为了确保容器中存储的值是唯一的， 你可以使用 <code>boost::multi_index::hashed_unique</code> 接口。 请注意： 所有要被存入容器中的值都必须满足它的接口的限定。 只要一个接口限定了容器中的值必须是唯一的， 那其他接口都不会对该限定造成影响。</p>
<pre><code class="language-c++">#include &lt;boost/multi_index_container.hpp&gt; 
#include &lt;boost/multi_index/hashed_index.hpp&gt; 
#include &lt;boost/multi_index/member.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

struct person 
{ 
  std::string name; 
  int age; 

  person(const std::string &amp;n, int a) 
    : name(n), age(a) 
  { 
  } 
}; 

typedef boost::multi_index::multi_index_container&lt; 
  person, 
  boost::multi_index::indexed_by&lt; 
    boost::multi_index::hashed_non_unique&lt; 
      boost::multi_index::member&lt; 
        person, std::string, &amp;person::name 
      &gt; 
    &gt;, 
    boost::multi_index::hashed_unique&lt; 
      boost::multi_index::member&lt; 
        person, int, &amp;person::age 
      &gt; 
    &gt; 
  &gt; 
&gt; person_multi; 

int main() 
{ 
  person_multi persons; 

  persons.insert(person(&quot;Boris&quot;, 31)); 
  persons.insert(person(&quot;Anton&quot;, 31)); 
  persons.insert(person(&quot;Caesar&quot;, 25)); 

  const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;(); 
  std::cout &lt;&lt; age_index.count(31) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.4.3/main.cpp">下载源代码</a></li>
</ul>
<p>上例中的容器现在使用了  <code>boost::multi_index::hashed_unique</code> 来作为他的第二个接口， 因此他不允许其中有两个同 age 的 person 存在。</p>
<p>上面的代码尝试存储一个与 Boris 同 age 的 Anton， 因为这个动作违反了容器第二个接口的限定， 它（Anton）将不会被存入到容器中。 因此， 程序将会输出： <code>1</code> 而不是2。</p>
<p>接下来的例子向我们展示了 Boost.MultiIndex 中剩下的三个接口：  <code>boost::multi_index::sequenced</code>， <code>boost::multi_index::ordered_non_unique</code> 和  <code>boost::multi_index::random_access</code>。</p>
<pre><code class="language-c++">#include &lt;boost/multi_index_container.hpp&gt; 
#include &lt;boost/multi_index/sequenced_index.hpp&gt; 
#include &lt;boost/multi_index/ordered_index.hpp&gt; 
#include &lt;boost/multi_index/random_access_index.hpp&gt; 
#include &lt;boost/multi_index/member.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

struct person 
{ 
  std::string name; 
  int age; 

  person(const std::string &amp;n, int a) 
    : name(n), age(a) 
  { 
  } 
}; 

typedef boost::multi_index::multi_index_container&lt; 
  person, 
  boost::multi_index::indexed_by&lt; 
    boost::multi_index::sequenced&lt;&gt;, 
    boost::multi_index::ordered_non_unique&lt; 
      boost::multi_index::member&lt; 
        person, int, &amp;person::age 
      &gt; 
    &gt;, 
    boost::multi_index::random_access&lt;&gt; 
  &gt; 
&gt; person_multi; 

int main() 
{ 
  person_multi persons; 

  persons.push_back(person(&quot;Boris&quot;, 31)); 
  persons.push_back(person(&quot;Anton&quot;, 31)); 
  persons.push_back(person(&quot;Caesar&quot;, 25)); 

  const person_multi::nth_index&lt;1&gt;::type &amp;ordered_index = persons.get&lt;1&gt;(); 
  person_multi::nth_index&lt;1&gt;::type::iterator lower = ordered_index.lower_bound(30); 
  person_multi::nth_index&lt;1&gt;::type::iterator upper = ordered_index.upper_bound(40); 
  for (; lower != upper; ++lower) 
    std::cout &lt;&lt; lower-&gt;name &lt;&lt; std::endl; 

  const person_multi::nth_index&lt;2&gt;::type &amp;random_access_index = persons.get&lt;2&gt;(); 
  std::cout &lt;&lt; random_access_index[2].name &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.4.4/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::multi_index::sequenced</code> 接口让我们可以像使用 <code>std::list</code> 一样的使用 MultiIndex。  这个接口定义起来十分容易： 你不用为它传递任何模板参数。 <code>person</code> 类型的对象在容器中就是像 list 一样按照加入的顺序来排列的。</p>
<p>而通过使用  <code>boost::multi_index::ordered_non_unique</code> 接口，  容器中的对象会自动的排序。 你在定义容器时就必须指定接口的排序规则。  示例中的对象 <code>person</code> 就是以 age 来排序的， 它借助了辅助类 <code>boost::multi_index::member</code> 来实现这一功能。</p>
<p><code>boost::multi_index::ordered_non_unique</code> 为我们提供了一些特别的函数来查找特定范围的数据。 通过使用 <code>lower_bound()</code> 和 <code>upper_bound()</code>， 示例实现了对所有 30 岁至 40 岁的 person 的查询。 要注意因为容器中的数据是有序的， 所以才提供了这些函数， 其他接口中并不提供这些函数。</p>
<p>最后一个接口是：  <code>boost::multi_index::random_access</code>， 他让我们可以像使用 <code>std::vector</code> 一样使用 MultiIndex 容器。 你又可以使用你熟悉的 <code>operator[]()</code> 和 <code>at()</code> 操作了。</p>
<p>请注意  <code>boost::multi_index::random_access</code> 已经被完整的包含在了 <code>boost::multi_index::sequenced</code> 接口中。 所以当你使用 <code>boost::multi_index::random_access</code> 的时候， 你也可以使用  <code>boost::multi_index::sequenced</code> 接口中的所有函数。</p>
<p>在介绍完 Boost.MultiIndex 剩下的4个接口后， 本章剩下的部分将向你介绍所谓的“键值提取器”（key extractors）。 目前为止， 我们已经见过一个在 <code>boost/multi_index/member.hpp</code> 定义的键值提取器了—— <code>boost::multi_index::member</code> 。 这个辅助函数的得名源自它可以显示的声明类中的哪些属性会作为接口中的键值使用。</p>
<p>接下来的例子介绍了另外两个键值提取器。</p>
<pre><code class="language-c++">#include &lt;boost/multi_index_container.hpp&gt; 
#include &lt;boost/multi_index/ordered_index.hpp&gt; 
#include &lt;boost/multi_index/hashed_index.hpp&gt; 
#include &lt;boost/multi_index/identity.hpp&gt; 
#include &lt;boost/multi_index/mem_fun.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

class person 
{ 
public: 
  person(const std::string &amp;n, int a) 
    : name(n), age(a) 
  { 
  } 

  bool operator&lt;(const person &amp;p) const 
  { 
    return age &lt; p.age; 
  } 

  std::string get_name() const 
  { 
    return name; 
  } 

private: 
  std::string name; 
  int age; 
}; 

typedef boost::multi_index::multi_index_container&lt; 
  person, 
  boost::multi_index::indexed_by&lt; 
    boost::multi_index::ordered_unique&lt; 
      boost::multi_index::identity&lt;person&gt; 
    &gt;, 
    boost::multi_index::hashed_unique&lt; 
      boost::multi_index::const_mem_fun&lt; 
        person, std::string, &amp;person::get_name 
      &gt; 
    &gt; 
  &gt; 
&gt; person_multi; 

int main() 
{ 
  person_multi persons; 

  persons.insert(person(&quot;Boris&quot;, 31)); 
  persons.insert(person(&quot;Anton&quot;, 31)); 
  persons.insert(person(&quot;Caesar&quot;, 25)); 

  std::cout &lt;&lt; persons.begin()-&gt;get_name() &lt;&lt; std::endl; 

  const person_multi::nth_index&lt;1&gt;::type &amp;hashed_index = persons.get&lt;1&gt;(); 
  std::cout &lt;&lt; hashed_index.count(&quot;Boris&quot;) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.4.5/main.cpp">下载源代码</a></li>
</ul>
<p>键值提取器<code>boost::multi_index::identity</code>（定义在  <code>boost/multi_index/identity.hpp</code> 中） 可以使用容器中的数据类型作为键值。 示例中， 就需要  <code>person</code> 类是可排序的， 因为它已经作为了接口  <code>boost::multi_index::ordered_unique</code> 的键值。  在示例里， 它是通过重载 <code>operator&lt;()</code> 操作符来实现的。</p>
<p>头文件 <code>boost/multi_index/mem_fun.hpp</code> 定义了两个可以把函数返回值作为键值的键值提取器：  <code>boost::multi_index::const_mem_fun</code> 和 <code>boost::multi_index::mem_fun</code> 。 在示例程序中， 就是用到了 <code>get_name()</code> 的返回值作为键值。 显而易见的，  <code>boost::multi_index::const_mem_fun</code> 适用于返回常量的函数， 而 <code>boost::multi_index::mem_fun</code> 适用于返回非常量的函数。</p>
<p>Boost.MultiIndex 还提供了两个键值提取器：  <code>boost::multi_index::global_fun</code> 和 <code>boost::multi_index::composite_key</code>。 前一个适用于独立的函数或者静态函数， 后一个允许你将几个键值提取器组合成一个新的的键值提取器。</p>
<hr />
<h2 id="135-boostbimap"><a class="header" href="#135-boostbimap">13.5. Boost.Bimap</a></h2>
<p><a href="http://www.boost.org/libs/bimap/">Boost.Bimap</a> 库提供了一个建立在 Boost.MultiIndex 之上但不需要预先定义就可以使用的容器。 这个容器十分类似于 <code>std::map</code>， 但他不仅可以通过 key 搜索， 还可以用 value 来搜索。</p>
<pre><code class="language-c++">#include &lt;boost/bimap.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  typedef boost::bimap&lt;std::string, int&gt; bimap; 
  bimap persons; 

  persons.insert(bimap::value_type(&quot;Boris&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Anton&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Caesar&quot;, 25)); 

  std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.5.1/main.cpp">下载源代码</a></li>
</ul>
<p>在 <code>boost/bimap.hpp</code> 中定义的 <code>boost::bimap</code> 为我们提供了两个属性：  left 和 right 来访问在 <code>boost::bimap</code> 统一的两个  <code>std::map</code> 类型的容器。 在例子中，  left 用 <code>std::string</code> 类型的 key 来访问容器， 而 right 用到了 <code>int</code>  类型的 key。</p>
<p>除了支持用 left 和 right 对容器中的记录进行单独的访问，  <code>boost::bimap</code> 还允许像下面的例子一样展示记录间的关联关系。</p>
<pre><code class="language-c++">#include &lt;boost/bimap.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  typedef boost::bimap&lt;std::string, int&gt; bimap; 
  bimap persons; 

  persons.insert(bimap::value_type(&quot;Boris&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Anton&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Caesar&quot;, 25)); 

  for (bimap::iterator it = persons.begin(); it != persons.end(); ++it) 
    std::cout &lt;&lt; it-&gt;left &lt;&lt; &quot; is &quot; &lt;&lt; it-&gt;right &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.5.2/main.cpp">下载源代码</a></li>
</ul>
<p>对一个记录访问时， left 和 right 并不是必须的。 你也可以使用迭代器来访问每个记录中的 left 和 right 容器。</p>
<p><code>std::map</code> 和 <code>std::multimap</code> 组合让你觉得似乎可以存储多个具有相同 key 值的记录， 但 <code>boost::bimap</code> 并没有这样做。 但这并不代表在 <code>boost::bimap</code> 存储两个具有相同 key 值的记录是不可能的。 严格来说， 那两个模板参数并不会对 left 和 right 的容器类型做出具体的规定。 如果像例子中那样并没有指定容器类型时，  <code>boost::bimaps::set_of</code> 类型会缺省的使用。 跟  <code>std::map</code> 一样， 它要求记录有唯一的 key 值。</p>
<p>第一个 <code>boost::bimap</code> 例子也可以像下面这样写。</p>
<pre><code class="language-c++">#include &lt;boost/bimap.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  typedef boost::bimap&lt;boost::bimaps::set_of&lt;std::string&gt;, boost::bimaps::set_of&lt;int&gt;&gt; bimap; 
  bimap persons; 

  persons.insert(bimap::value_type(&quot;Boris&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Anton&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Caesar&quot;, 25)); 

  std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.5.3/main.cpp">下载源代码</a></li>
</ul>
<p>除了 <code>boost::bimaps::set_of</code>， 你还可以用一些其他的容器类型来定制你的  <code>boost::bimap</code>。</p>
<pre><code class="language-c++">#include &lt;boost/bimap.hpp&gt; 
#include &lt;boost/bimap/multiset_of.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  typedef boost::bimap&lt;boost::bimaps::set_of&lt;std::string&gt;, boost::bimaps::multiset_of&lt;int&gt;&gt; bimap; 
  bimap persons; 

  persons.insert(bimap::value_type(&quot;Boris&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Anton&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Caesar&quot;, 25)); 

  std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl; 
  std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.5.4/main.cpp">下载源代码</a></li>
</ul>
<p>代码中的容器使用了定义在 <code>boost/bimap/multiset_of.hpp</code>  中的 <code>boost::bimaps::multiset_of</code>。 这个容器的操作和  <code>boost::bimaps::set_of</code> 差不了多少， 只是它不再要求 key 值是唯一的。 因此， 上面的例子将会在计算 age 为 31 的 person 数时输出： <code>2</code>。</p>
<p>既然 <code>boost::bimaps::set_of</code> 会在定义  <code>boost::bimap</code> 被缺省的使用， 你没必要再显示的包含头文件： <code>boost/bimap/set_of.hpp</code>。  但在使用其它类型的容器时， 你就必须要显示的包含一些相应的头文件了。</p>
<p>Boost.Bimap 还提供了类：  <code>boost::bimaps::unordered_set_of</code>， <code>boost::bimaps::unordered_multiset_of</code>， <code>boost::bimaps::list_of</code>，<code>boost::bimaps::vector_of</code> 和  <code>boost::bimaps::unconstrainted_set_of</code> 以供使用。 除了 <code>boost::bimaps::unconstrainted_set_of</code>， 剩下的所有容器类型的使用方法都和他们在 C++ 标准里的版本一样。</p>
<pre><code class="language-c++">#include &lt;boost/bimap.hpp&gt; 
#include &lt;boost/bimap/unconstrained_set_of.hpp&gt; 
#include &lt;boost/bimap/support/lambda.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  typedef boost::bimap&lt;std::string, boost::bimaps::unconstrained_set_of&lt;int&gt;&gt; bimap; 
  bimap persons; 

  persons.insert(bimap::value_type(&quot;Boris&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Anton&quot;, 31)); 
  persons.insert(bimap::value_type(&quot;Caesar&quot;, 25)); 

  bimap::left_map::iterator it = persons.left.find(&quot;Boris&quot;); 
  persons.left.modify_key(it, boost::bimaps::_key = &quot;Doris&quot;); 

  std::cout &lt;&lt; it-&gt;first &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/13.5.5/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::bimaps::unconstrainted_set_of</code>  可以使 <code>boost::bimap</code> 的  right （也就是 age）值无法用来查找 person。 在这种特定的情况下， <code>boost::bimap</code> 可以被视为是一个  <code>std::map</code> 类型的容器。</p>
<p>虽然如此， 例子还是向我们展示了  <code>boost::bimap</code> 对于 <code>std::map</code> 的优越性。 因为 Boost.Bimap 是基于 Boost.MultiIndex 的， 你当然可以使用 Boost.MultiIndex 提供的所有函数。  例子中就用 <code>modify_key()</code> 修改了 key 值， 这在  <code>std::map</code> 中是不可能的。</p>
<p>请注意修改 key 值的以下细节： key 通过  boost::bimaps::_key 函数赋予了新值， 而 boost::bimaps::_key 是一个定义在 <code>boost/bimap/support/lambda.hpp</code> 中的 lambda 函数。 有关 lambda 函数， 详见：<a href="./functionobjects.html">第 3 章 <em>函数对象</em></a>。</p>
<p><code>boost/bimap/support/lambda.hpp</code> 还定义了 boost::bimaps::_data。 函数  <code>modify_data()</code> 可以用来修改  <code>boost::bimap</code> 中的 value 值。</p>
<hr />
<h2 id="136-练习"><a class="header" href="#136-练习">13.6. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>创建你的应用： 它支持指派员工到一家公司不同的部门。 存入一些示例记录， 然后通过指定员工来得到他所在的部门， 再通过指定部门来得到该部门的员工数。</li>
<li>扩展你的应用： 加入员工的 ID 号。 ID 号必须是唯一的， 保证在员工同名的情况下依然可以唯一的标识员工。 通过指定 ID 号来得到某个员工的信息并把它输出以验证正确性。</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-14-章-数据结构"><a class="header" href="#第-14-章-数据结构">第 14 章 数据结构</a></h1>
<h2 id="141-概述"><a class="header" href="#141-概述">14.1. 概述</a></h2>
<p>在 Boost C++ 库中， 把一些类型定义为container显得不太合适， 所以就并没有放在 <a href="./containers.html">第 13 章 <em>容器</em></a> 里。 而把他们放在本章就比较合适了。 举例来说， <code>boost::tuple</code> 就扩展了 C++ 的数据类型 <code>std::pair</code> 用以储存多个而不只是两个值。 </p>
<p>除了 <code>boost::tuple</code>， 这一章还涵盖了类  <code>boost::any</code> 和 <code>boost::variant</code> 以储存那些不确定类型的值。 其中 <code>boost::any</code> 类型的变量使用起来就像弱类型语言中的变量一样灵活。 另一方面， <code>boost::variant</code> 类型的变量可以储存一些预定义的数据类型， 就像我们用 <code>union</code> 时候一样。</p>
<hr />
<h2 id="142-元组"><a class="header" href="#142-元组">14.2. 元组</a></h2>
<p><a href="http://www.boost.org/libs/tuple/">Boost.Tuple</a> 库提供了一个更一般的版本的 <code>std::pair</code> ——  <code>boost::tuple</code> 。 不过 <code>std::pair</code> 只能储存两个值而已, <code>boost::tuple</code> 则给了我们更多的选择。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string&gt; person; 
  person p(&quot;Boris&quot;, &quot;Schaeling&quot;); 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>为了使用 <code>boost::tuple</code>， 你必须要包含头文件： <code>boost/tuple/tuple.hpp</code> 。 若想要让元组和流一起使用， 你还需要包含头文件：   <code>boost/tuple/tuple_io.hpp</code> 才行。 </p>
<p>其实， <code>boost::tuple</code> 的用法基本上和  <code>std::pair</code> 一样。 就像我们在上面的例子里看到的那样， 两个值类型的 <code>std::string</code> 通过两个相应的模板参数存储在了元组里。 </p>
<p>当然 <code>person</code> 类型也可以用 <code>std::pair</code> 来实现。 所有  <code>boost::tuple</code> 类型的对象都可以被写入流里。 再次强调， 为了使用流操作和各种流操作运算符， 你必须要包含头文件： <code>boost/tuple/tuple_io.hpp</code> 。 显然，我们的例子会输出： <code>(Boris Schaeling)</code> 。</p>
<p><code>boost::tuple</code> 和 <code>std::pair</code> 之间最重要的一点不同点： 元组可以存储无限多个值！ </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string, int&gt; person; 
  person p(&quot;Boris&quot;, &quot;Schaeling&quot;, 43); 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>我们修改了实例， 现在的元组里不仅储存了一个人的firstname和lastname， 还加上了他的鞋子的尺码。 现在， 我们的例子将会输出：  <code>(Boris Schaeling 43)</code> 。</p>
<p>就像 <code>std::pair</code> 有辅助函数 <code>std::make_pair()</code> 一样， 一个元组也可以用它的辅助函数 <code>boost::make_tuple()</code> 来创建。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>就像下面的例子所演示的那样， 一个元组也可以存储引用类型的值。 </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::string s = &quot;Boris&quot;; 
  std::cout &lt;&lt; boost::make_tuple(boost::ref(s), &quot;Schaeling&quot;, 43) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>因为 &quot;Schaeling&quot; 和 43 是按值传递的，所以就直接存储在了元组中。  与他们不同的是： person 的第一个元素是一个指向 s 的引用。 Boost.Ref 中的  <code>boost::ref()</code> 就是用来创建这样的引用的。 相对的， 要创建一个常量的引用的时候， 你需要使用 <code>boost::cref()</code> 。</p>
<p>在学习了创建元组的方法之后， 让我们来了解一下访问元组中元素的方式。 <code>std::pair</code> 只包含两个元素， 故可以使用属性 first 和 second 来访问其中的元素。 但元组可以包含无限多个元素， 显然， 我们需要用另一种方式来解决访问的问题。 </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string, int&gt; person; 
  person p = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43); 
  std::cout &lt;&lt; p.get&lt;0&gt;() &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::get&lt;0&gt;(p) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>我们可以用两种方式来访问元组中的元素： 使用成员函数  <code>get()</code> ， 或者将元组传给一个独立的函数  <code>boost::get()</code> 。 使用这两种方式时， 元素的索引值都是通过模板参数来指定的。 例子中就分别使用了这两种方式来访问  p 中的第一个元素。 因此， <code>Boris</code> 会被输出两次。 </p>
<p>另外， 对于索引值合法性的检查会在编译期执行， 故访问非法的索引值会引起编译期错误而不是运行时的错误。</p>
<p>对于元组中元素的修改， 你同样可以使用   <code>get()</code> 和 <code>boost::get()</code> 函数。 </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string, int&gt; person; 
  person p = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43); 
  p.get&lt;1&gt;() = &quot;Becker&quot;; 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.6/main.cpp">下载源代码</a></li>
</ul>
<p><code>get()</code> 和 <code>boost::get()</code> 都会返回一个引用值。 例子中修改了 lastname 之后将会输出： <code>(Boris Becker 43)</code> 。</p>
<p>Boost.Tuple 除了重载了流操作运算符以外， 还为我们提供了比较运算符。 为了使用它们， 你必须要包含相应的头文件： <code>boost/tuple/tuple_comparison.hpp</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_comparison.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string, int&gt; person; 
  person p1 = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43); 
  person p2 = boost::make_tuple(&quot;Boris&quot;, &quot;Becker&quot;, 43); 
  std::cout &lt;&lt; (p1 != p2) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.7/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子将会输出 <code>1</code> 因为两个元组  p1 和 p2 是不同的。</p>
<p>同时， 头文件 <code>boost/tuple/tuple_comparison.hpp</code> 还定义了一些其他的比较操作， 比如用来做字典序比较的大于操作等。 </p>
<p>Boost.Tuple 还提供了一种叫做 Tier 的特殊元组。 Tier 的特殊之处在于它包含的所有元素都是引用类型的。 它可以通过构造函数  <code>boost::tie()</code> 来创建。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string&amp;, std::string&amp;, int&amp;&gt; person; 

  std::string firstname = &quot;Boris&quot;; 
  std::string surname = &quot;Schaeling&quot;; 
  int shoesize = 43; 
  person p = boost::tie(firstname, surname, shoesize); 
  surname = &quot;Becker&quot;; 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.8/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子创建了一个 tier p， 他包含了三个分别指向 firstname， surname 和 shoesize 的引用值。 在修改变量  surname 的同时， tier 也会跟着改变。 </p>
<p>就像下面的例子展示的那样，你当然可以用  <code>boost::make_tuple()</code> 和 <code>boost::ref()</code> 来代替构造函数  <code>boost::tie()</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string&amp;, std::string&amp;, int&amp;&gt; person; 

  std::string firstname = &quot;Boris&quot;; 
  std::string surname = &quot;Schaeling&quot;; 
  int shoesize = 43; 
  person p = boost::make_tuple(boost::ref(firstname), boost::ref(surname), boost::ref(shoesize)); 
  surname = &quot;Becker&quot;; 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.9/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::tie()</code> 在一定程度上简化了语法， 同时， 也可以用作“拆箱”元组。 在接下来的这个例子里， 元组中的各个元素就被很方便的“拆箱”并直接赋给了其他变量。 </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

boost::tuple&lt;std::string, int&gt; func() 
{ 
  return boost::make_tuple(&quot;Error message&quot;, 2009); 
}

int main() 
{ 
  std::string errmsg; 
  int errcode; 

  boost::tie(errmsg, errcode) = func(); 
  std::cout &lt;&lt; errmsg &lt;&lt; &quot;: &quot; &lt;&lt; errcode &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.10/main.cpp">下载源代码</a></li>
</ul>
<p>通过使用 <code>boost::tie()</code> ， 元组中的元素：字符串“Error massage”和错误代码“2009”就很方便地经  <code>func()</code> 的返回值直接赋给了  errmsg 和 errcode 。</p>
<hr />
<h2 id="143-boostany"><a class="header" href="#143-boostany">14.3. Boost.Any</a></h2>
<p>像 C++ 这样的强类型语言要求给每个变量一个确定的类型。 而以 JavaScript 为代表的弱类型语言却不这样做， 弱类型的每个变量都可以存储数组、 布尔值、 或者是字符串。</p>
<p>库 <a href="http://www.boost.org/libs/any/">Boost.Any</a> 给我们提供了 <code>boost::any</code> 类， 让我们可以在 C++ 中像 JavaScript 一样的使用弱类型的变量。 </p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 

int main() 
{ 
  boost::any a = 1; 
  a = 3.14; 
  a = true; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>为了使用 <code>boost::any</code>， 你必须要包含头文件：  <code>boost/any.hpp</code>。 接下来， 你就可以定义和使用 <code>boost::any</code> 的对象了。 </p>
<p>需要注明的是： <code>boost::any</code> 并不能真的存储任意类型的值； Boost.Any 需要一些特定的前提条件才能工作。 任何想要存储在 <code>boost::any</code> 中的值，都必须是可拷贝构造的。  因此，想要在 <code>boost::any</code> 存储一个字符串类型的值， 就必须要用到 <code>std::string</code> ， 就像在下面那个例子中做的一样。 </p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::any a = 1; 
  a = 3.14; 
  a = true; 
  a = std::string(&quot;Hello, world!&quot;); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>如果你企图把字符串 &quot;Hello, world!&quot; 直接赋给 a ， 你的编译器就会报错， 因为由基类型 <code>char</code> 构成的字符串在 C++ 中并不是可拷贝构造的。 </p>
<p>想要访问 <code>boost::any</code> 中具体的内容， 你必须要使用转型操作： <code>boost::any_cast</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::any a = 1; 
  std::cout &lt;&lt; boost::any_cast&lt;int&gt;(a) &lt;&lt; std::endl; 
  a = 3.14; 
  std::cout &lt;&lt; boost::any_cast&lt;double&gt;(a) &lt;&lt; std::endl; 
  a = true; 
  std::cout &lt;&lt; boost::any_cast&lt;bool&gt;(a) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>通过由模板参数传入 <code>boost::any_cast</code> 的值， 变量会被转化成相应的类型。 一旦你指定了一种非法的类型， 该操作会抛出  <code>boost::bad_any_cast</code> 类型的异常。</p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    boost::any a = 1; 
    std::cout &lt;&lt; boost::any_cast&lt;float&gt;(a) &lt;&lt; std::endl; 
  } 
  catch (boost::bad_any_cast &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.4/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子就抛出了一个异常， 因为 <code>float</code> 并不能匹配原本存储在 a 中的 <code>int</code> 类型。 记住， 在任何情况下都保证 <code>boost::any</code> 中的类型匹配是很重要的。 在没有通过模板参数指定 <code>short</code> 或 <code>long</code>  类型时， 同样会有异常抛出。</p>
<p>既然 <code>boost::bad_any_cast</code> 继承自  <code>std::bad_cast</code>， <code>catch</code> 当然也可以捕获相应类型的异常。 </p>
<p>想要检查 <code>boost::any</code> 是否为空， 你可以使用  <code>empty()</code> 函数。 想要确定其中具体的类型信息， 你可以使用 <code>type()</code> 函数。</p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;typeinfo&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::any a = 1; 
  if (!a.empty()) 
  { 
    const std::type_info &amp;ti = a.type(); 
    std::cout &lt;&lt; ti.name() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子同时用到了 <code>empty()</code> 和 <code>type()</code> 函数。 <code>empty()</code> 将会返回一个布尔值， 而 <code>type()</code> 则会返回一个在 <code>typeinfo</code> 中定义的  <code>std::type_info</code> 值。</p>
<p>作为对这一节的总结， 最后一个例子会向你展示怎样用 <code>boost::any_cast</code> 来定义一个指向 <code>boost::any</code> 中内容的指针。</p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::any a = 1; 
  int *i = boost::any_cast&lt;int&gt;(&amp;a); 
  std::cout &lt;&lt; *i &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.6/main.cpp">下载源代码</a></li>
</ul>
<p>你需要做的就是传递一个 <code>boost::any</code> 类型的指针， 作为 <code>boost::any_cast</code> 的参数； 模板参数却没有任何改动。</p>
<hr />
<h2 id="144-boostvariant"><a class="header" href="#144-boostvariant">14.4. Boost.Variant</a></h2>
<p><a href="http://www.boost.org/libs/variant/">Boost.Variant</a> 和 Boost.Any 之间的不同点在于 Boost.Any 可以被视为任意的类型， 而 Boost.Variant 只能被视为固定数量的类型。 让我们来看下面这个例子。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 

int main() 
{ 
  boost::variant&lt;double, char&gt; v; 
  v = 3.14; 
  v = 'A'; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.Variant 为我们提供了一个定义在 <code>boost/variant.hpp</code> 中的类：  <code>boost::variant</code> 。 既然 <code>boost::variant</code> 是一个模板， 你必须要指定至少一个参数。 Variant 所存储的数据类型就由这些参数来指定。 上面的例子就给  v 指定了 <code>double</code> 类型和 <code>char</code> 类型。 注意， 一旦你将一个 <code>int</code> 值赋给了 v， 你的代码将不会编译通过。</p>
<p>当然， 上面的例子也可以用一个 <code>union</code> 类型来实现， 但是与 union 不同的是： <code>boost::variant</code> 可以储存像 <code>std::string</code>  这样的 class 类型的数据。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  v = 'A'; 
  v = &quot;Hello, world!&quot;; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>要访问 v 中的数据， 你可以使用独立的  <code>boost::get()</code> 函数。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  std::cout &lt;&lt; boost::get&lt;double&gt;(v) &lt;&lt; std::endl; 
  v = 'A'; 
  std::cout &lt;&lt; boost::get&lt;char&gt;(v) &lt;&lt; std::endl; 
  v = &quot;Hello, world!&quot;; 
  std::cout &lt;&lt; boost::get&lt;std::string&gt;(v) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::get()</code> 需要传入一个模板参数来指明你需要返回的数据类型。 若是指定了一个非法的类型， 你会遇到一个运行时而不是编译期的错误。</p>
<p>所有 <code>boost::variant</code> 类型的值都可以被直接写入标准输入流这样的流中， 这可以在一定程度上让你避开运行时错误的风险。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  std::cout &lt;&lt; v &lt;&lt; std::endl; 
  v = 'A'; 
  std::cout &lt;&lt; v &lt;&lt; std::endl; 
  v = &quot;Hello, world!&quot;; 
  std::cout &lt;&lt; v &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.4/main.cpp">下载源代码</a></li>
</ul>
<p>想要分别处理各种不同类型的数据， Boost.Variant 为我们提供了一个名为 <code>boost::apply_visitor()</code> 的函数。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;boost/any.hpp&gt; 
#include &lt;vector&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

std::vector&lt;boost::any&gt; vector; 

struct output : 
  public boost::static_visitor&lt;&gt; 
{ 
  void operator()(double &amp;d) const 
  { 
    vector.push_back(d); 
  } 

  void operator()(char &amp;c) const 
  { 
    vector.push_back(c); 
  } 

  void operator()(std::string &amp;s) const 
  { 
    vector.push_back(s); 
  } 
}; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  boost::apply_visitor(output(), v); 
  v = 'A'; 
  boost::apply_visitor(output(), v); 
  v = &quot;Hello, world!&quot;; 
  boost::apply_visitor(output(), v); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.5/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::apply_visitor()</code> 第一个参数需要传入一个继承自 <code>boost::static_visitor</code> 类型的对象。 这个类必须要重载 <code>operator()()</code> 运算符来处理  <code>boost::variant</code> 每个可能的类型。 相应的， 例子中的  v 就重载了三次 operator() 来处理三种可能的类型：  <code>double</code>， <code>char</code> 和 <code>std::string</code>。</p>
<p>再仔细看代码， 不难发现 <code>boost::static_visitor</code> 是一个模板。 那么，当  <code>operator()()</code> 有返回值的时候， 就必须返回一个模板才行。 如果 operator() 像例子那样没有返回值时， 你就不需要模板了。</p>
<p><code>boost::apply_visitor()</code> 的第二个参数是一个  <code>boost::variant</code> 类型的值。</p>
<p>在使用时， <code>boost::apply_visitor()</code> 会自动调用跟第二个参数匹配的 <code>operator()()</code> 。 示例程序中的  <code>boost::apply_visitor()</code> 就自动调用了三个不同的 operator 第一个是 <code>double</code> 类型的， 第二个是  <code>char</code> 最后一个是 <code>std::string</code>。</p>
<p><code>boost::apply_visitor()</code> 的优点不只是“自动调用匹配的函数”这一点。 更有用的是，  <code>boost::apply_visitor()</code> 会确认是否  <code>boost::variant</code> 中的每个可能值都定义了相应的函数。  如果你忘记重载了任何一个函数， 代码都不会编译通过。 </p>
<p>当然， 如果对每种类型的操作都是一样的， 你也可以像下面的示例一样使用一个模板来简化你的代码。 </p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;boost/any.hpp&gt; 
#include &lt;vector&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

std::vector&lt;boost::any&gt; vector; 

struct output : 
  public boost::static_visitor&lt;&gt; 
{ 
  template &lt;typename T&gt; 
  void operator()(T &amp;t) const 
  { 
    vector.push_back(t); 
  } 
}; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  boost::apply_visitor(output(), v); 
  v = 'A'; 
  boost::apply_visitor(output(), v); 
  v = &quot;Hello, world!&quot;; 
  boost::apply_visitor(output(), v); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.6/main.cpp">下载源代码</a></li>
</ul>
<p>既然 <code>boost::apply_visitor()</code> 可以在编译期确定代码的正确性， 你就该更多的使用它而不是  <code>boost::get()</code>。</p>
<hr />
<h2 id="145-练习"><a class="header" href="#145-练习">14.5. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>自定义一种数据类型： <code>configuration</code>  它可以存储一个 name-value 对。 Name 为  <code>std::string</code> 类型， 而 value 可为 <code>std::string</code> 或者 <code>int</code> 或者  <code>float</code> 类型。 在 <code>main()</code> 函数里， 用 <code>configuration</code> 存储下列 name-value 对:  path=C:\Windows, version=3， pi=3.1415。 通过向便准输出流输出来验证你对数据类型的设计。 </li>
<li>在输出后， 将对象中的 path 修改为 C:\Windows\System。 再次向标准输出流输出以验证你的设计。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-15-章-错误处理"><a class="header" href="#第-15-章-错误处理">第 15 章 错误处理</a></h1>
<h2 id="151-概述"><a class="header" href="#151-概述">15.1. 概述</a></h2>
<p>在执行时会有潜在失败可能的每个函数都需要一种合适的方式和它的调用者进行交互。 在C++中，这一步是通过返回值或抛出一个异常来完成的。    作为常识，返回值经常用在处理非错误的异常中。 调用者通过返回值作出相应的反馈。</p>
<p>异常被通常用来标示出未预期的异常情况。 一个很好的例子是在错误的使用 <code>new</code>    时将抛出的一个动态内存分配异常类型 <code>std::bad_alloc</code> 。    由于内存的分配通常不会出现任何问题，如果总是检查返回值将会变得异常累赘。</p>
<p>本章介绍了两种可以帮助开发者利用错误处理的Boost C++库：其中 Boost.System    可以由特定操作系统平台的错误代码转换出跨平台的错误代码。 借助于    Boost.System，函数基于某个特定操作系统的返回值类型可以被转换成为跨平台的类型。 另外，Boost.Exception    允许给任何异常添加额外的信息，以便利用 <code>catch</code> 相应的处理程序更好的对异常作出反应。</p>
<hr />
<h2 id="152-boostsystem"><a class="header" href="#152-boostsystem">15.2. Boost.System</a></h2>
<p><a href="http://www.boost.org/libs/system/">Boost.System</a>    是一个定义了四个类的小型库，用以识别错误。 <code>boost::system::error_code</code>    是一个最基本的类，用于代表某个特定操作系统的异常。    由于操作系统通常枚举异常，<code>boost::system::error_code</code>    中以变量的形式保存错误代码 <code>int</code>。 下面的例子说明了如何通过访问 Boost.Asio 类来使用这个类。</p>
<pre><code class="language-c++">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::system::error_code ec; 
  std::string hostname = boost::asio::ip::host_name(ec); 
  std::cout &lt;&lt; ec.value() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/15.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.Asio 提供了独立的函数 <code>boost::asio::ip::host_name()</code>    可以返回正在执行的应用程序名。</p>
<p><code>boost::system::error_code</code> 类型的一个对象可以作为单独的参数传递给    <code>boost::asio::ip::host_name()</code>。 如果当前的操作系统函数失败，    这个参数包含相关的错误代码。 也可以通过调用 <code>boost::asio::ip::host_name()</code>    而不使用任何参数，以防止错误代码是非相关的。</p>
<p>事实上在Boost 1.36.0中 <code>boost::asio::ip::host_name()</code>    是有问题的，然而它可以当作一个很好的例子。 即使当前操作系统函数成功返回了计算机名，这个函数它也可能返回一个错误代码。 由于在Boost    1.37.0中解决了这个问题，现在可以放心使用 <code>boost::asio::ip::host_name()</code>    了。</p>
<p>由于错误代码仅仅是一个数值，因此可以借助于 <code>value()</code> 方法得到它。    由于错误代码0通常意味着没有错误，其他的值的意义则依赖于操作系统并且需要查看相关手册。</p>
<p>如果使用Boost 1.36.0， 并且用Visual Studio 2008在Windows    XP环境下编译以上应用程序将不断产生错误代码14（没有足够的存储空间以完成操作）。 即使函数    <code>boost::asio::ip::host_name()</code> 成功决定了计算机名，也会报出错误代码14。    事实上这是因为函数 <code>boost::asio::ip::host_name()</code> 的实现有问题。</p>
<p>除了 <code>value()</code> 方法之外, 类    <code>boost::system::error_code</code> 提供了方法    <code>category()</code>。 这个方法可返回一个在 Boost.System 中定义的二级对象:    <code>boost::system::category</code>。</p>
<p>错误代码是简单的数值。 操作系统开发商，例如微软，可以保证系统错误代码的特异性。    对于任何开发商来说，在所有现有应用程序中保持错误代码的独一无二是几乎不可能的。    他需要一个包含有所有软件开发者的错误代码中心数据库，以防止在不同的方案下重复使用相同的代码。 当然这是不实际的。    这是错误分类表存在的缘由。</p>
<p>类型 <code>boost::system::error_code</code> 的错误代码总是属于可以使用    <code>category()</code> 方法获取的分类。 通过预定义的对象    boost::system::system_category 来表示操作系统的错误。</p>
<p>通过调用 <code>category()</code> 方法，可以返回预定义变量    boost::system::system_category 的一个引用。 它允许获取关于分类的特定信息。    例如在使用的是 system 分类的情况下，通过使用 <code>name()</code> 方法将得到它的名字    <code>system</code>。</p>
<pre><code class="language-c++">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::system::error_code ec; 
  std::string hostname = boost::asio::ip::host_name(ec); 
  std::cout &lt;&lt; ec.value() &lt;&lt; std::endl; 
  std::cout &lt;&lt; ec.category().name() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/15.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>通过错误代码和错误分类识别出的错误是独一无二的。    由于仅仅在错误分类中的错误代码是必须唯一的，程序员应当在希望定义某个特定应用程序的错误代码时创建一个新的分类。    这使得任何错误代码都不会影响到其他开发者的错误代码。</p>
<pre><code class="language-c++">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

class application_category : 
  public boost::system::error_category 
{ 
public: 
  const char *name() const { return &quot;application&quot;; } 
  std::string message(int ev) const { return &quot;error message&quot;; } 
}; 

application_category cat; 

int main() 
{ 
  boost::system::error_code ec(14, cat); 
  std::cout &lt;&lt; ec.value() &lt;&lt; std::endl; 
  std::cout &lt;&lt; ec.category().name() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/15.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>通过创建一个派生于 <code>boost::system::error_category</code>    的类以及实现作为新分类的所必须的接口的不同方法可以定义一个新的错误分类。 由于方法 <code>name()</code> 和    <code>message()</code> 在类    <code>boost::system::error_category</code>    中被定义为纯虚拟函数，所以它们是必须提供的。 至于额外的方法，在必要的条件下，可以重载相对应的默认行为。</p>
<p>当方法 <code>name()</code> 返回错误分类名时，可以使用方法    <code>message()</code> 来获取针对某个错误代码的描述。 不像之前的那个例子，参数    ev 往往被用于返回基于错误代码的描述。</p>
<p>新创建的错误分类的对象可以被用来初始化相应的错误代码。 本例中定义了一个用于新分类    <code>application_category</code> 的错误代码 ec 。    然而错误代码14不再是系统错误；他的意义被开发者指定为新的错误分类。</p>
<p><code>boost::system::error_code</code> 包含了一个叫作    <code>default_error_condition()</code> 的方法，它可以返回    <code>boost::system::error_condition</code>类型的对象。    <code>boost::system::error_condition</code> 的接口几乎与    <code>boost::system::error_code</code> 相同。 唯一的差别是只有类    <code>boost::system::error_code</code> 提供了方法    <code>default_error_condition()</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::system::error_code ec; 
  std::string hostname = boost::asio::ip::host_name(ec); 
  boost::system::error_condition ecnd = ec.default_error_condition(); 
  std::cout &lt;&lt; ecnd.value() &lt;&lt; std::endl; 
  std::cout &lt;&lt; ecnd.category().name() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/15.2.4/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::system::error_condition</code> 的使用方法与    <code>boost::system::error_code</code> 类似。    对象<code>boost::system::error_condition</code> 的    <code>value()</code> 和 <code>category()</code>    方法都可以像上面的例子中那样调用。</p>
<p>有或多或少两个相同的类的原因很简单：当类    <code>boost::system::error_code</code> 被当作当前平台的错误代码时， 类    <code>boost::system::error_condition</code> 可以被用作获取跨平台的错误代码。    通过调用 <code>default_error_condition()</code>    方法，可以把依赖于某个平台的的错误代码转换成    <code>boost::system::error_condition</code> 类型的跨平台的错误代码。</p>
<p>如果执行以上应用程序，它将显示数字12以及错误分类 <code>GENERIC</code>。    依赖于平台的错误代码14被转换成了跨平台的错误代码12。 借助于    <code>boost::system::error_condition</code>    ，可以总是使用相同的数字表示错误，无视当前操作系统。 当Windows报出错误14时，其他操作系统可能会对相同的错误报出错误代码25。 使用    <code>boost::system::error_condition</code>    ，总是对这个错误报出错误代码12。</p>
<p>最后 Boost.System 提供了类    <code>boost::system::system_error</code> ，它派生于    <code>std::runtime_error</code>。 它可被用来传送发生在异常里类型为    <code>boost::system::error_code</code> 的错误代码。</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt; 
#include &lt;boost/system/system_error.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    std::cout &lt;&lt; boost::asio::ip::host_name() &lt;&lt; std::endl; 
  } 
  catch (boost::system::system_error &amp;e) 
  { 
    boost::system::error_code ec = e.code(); 
    std::cerr &lt;&lt; ec.value() &lt;&lt; std::endl; 
    std::cerr &lt;&lt; ec.category().name() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/15.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>独立的函数 <code>boost::asio::ip::host_name()</code>    是以两种方式提供的：一种是需要类型为 <code>boost::system::error_code</code>    的参数，另一种不需要参数。 第二个版本将在错误发生时抛出    <code>boost::system::system_error</code> 类型的异常。 异常传出类型为    <code>boost::system::error_code</code> 的相应错误代码。</p>
<hr />
<h2 id="153-boostexception"><a class="header" href="#153-boostexception">15.3. Boost.Exception</a></h2>
<p><a href="http://www.boost.org/libs/exception/">Boost.Exception</a>    库提供了一个新的异常类 <code>boost::exception</code>    允许给一个抛出的异常添加信息。 它被定义在文件 <code>boost/exception/exception.hpp</code> 中。 由于    Boost.Exception 中的类和函数分布在不同的头文件中， 下面的例子中将使用 <code>boost/exception/all.hpp</code> 以避免一个一个添加头文件。</p>
<pre><code class="language-c++">#include &lt;boost/exception/all.hpp&gt; 
#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;boost/shared_array.hpp&gt; 
#include &lt;exception&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; 

class allocation_failed : 
  public boost::exception, 
  public std::exception 
{ 
public: 
  allocation_failed(std::size_t size) 
    : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;) 
  { 
  } 

  virtual const char *what() const throw() 
  { 
    return what_.c_str(); 
  } 

private: 
  std::string what_; 
}; 

boost::shared_array&lt;char&gt; allocate(std::size_t size) 
{ 
  if (size &gt; 1000) 
    throw allocation_failed(size); 
  return boost::shared_array&lt;char&gt;(new char[size]); 
} 

void save_configuration_data() 
{ 
  try 
  { 
    boost::shared_array&lt;char&gt; a = allocate(2000); 
    // saving configuration data ... 
  } 
  catch (boost::exception &amp;e) 
  { 
    e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;); 
    throw; 
  } 
} 

int main() 
{ 
  try 
  { 
    save_configuration_data(); 
  } 
  catch (boost::exception &amp;e) 
  { 
    std::cerr &lt;&lt; boost::diagnostic_information(e); 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/15.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子在 <code>main()</code> 中调用了一个函数    <code>save_configuration_data()</code> ，它调回了    <code>allocate()</code> 。 <code>allocate()</code>    函数动态分配内存，而它检查是否超过某个限度。 这个限度在本例中被设定为1,000个字节。</p>
<p>如果 <code>allocate()</code> 被调用的值大于1,000，将会抛出    <code>save_configuration_data()</code> 函数里的相应异常。    正如注释中所标识的那样，这个函数把配置数据被存储在动态分配的内存中。</p>
<p>事实上，这个例子的目的是通过抛出异常以示范 Boost.Exception。 这个通过    <code>allocate()</code> 抛出的异常是    <code>allocation_failed</code> 类型的，而且它同时继承了    <code>boost::exception</code> 和    <code>std::exception</code>。</p>
<p>当然，也不是一定要派生于 <code>std::exception</code> 异常的。    为了把它嵌入到现有的框架中，异常 <code>allocation_failed</code>    可以派生于其他类的层次结构。 当通过C++标准来定义以上例子的类层次结构的时候， 单独从    <code>boost::exception</code> 中派生出    <code>allocation_failed</code> 就足够了。</p>
<p>当抛出 <code>allocation_failed</code>    类型的异常的时候，分配内存的大小是存储在异常中的，以缓解相应应用程序的调试。 如果想通过 <code>allocate()</code>    分配获取更多的内存空间，那么可以很容易发现导致异常的根本原因。</p>
<p>如果仅仅通过一个函数(例子中的函数 <code>save_configuration_data()</code>)来调用    <code>allocate()</code> ，这个信息足以找到问题的所在。 然而，在有许多函数调用    <code>allocate()</code> 以动态分配内存的更加复杂的应用程序中，这个信息不足以高效的调试应用程序。    在这些情况下，它最好能有助于找到哪个函数试图分配 <code>allocate()</code> 所能提供空间之外的内存。    向异常中添加更多的信息，在这些情况下，将非常有助于进程的调试。</p>
<p>有挑战性的是，函数 <code>allocate()</code>    中并没有调用者名等信息，以把它加入到相关的异常中。</p>
<p>Boost.Exception 提供了如下的解决方案：对于任何一个可以添加到异常中的信息，可以通过定义一个派生于    <code>boost::error_info</code> 的数据类型，来随时向这个异常添加信息。</p>
<p><code>boost::error_info</code>    是一个需要两个参数的模板，第一个参数叫做标签(tag)，特定用来识别新建的数据类型。 通常是一个有特定名字的结构体。    第二个参数是与存储于异常中的数据类型信息相关的。</p>
<p>这个应用程序定义了一个新的数据类型 <code>errmsg_info</code>，可以通过    <code>tag_errmsg</code> 结构来特异性的识别，它存储着一个    <code>std::string</code> 类型的字符串。</p>
<p>在 <code>save_configuration_data()</code> 的 <code>catch</code>    句柄中，通过获取 <code>tag_errmsg</code> 以创建一个对象，它通过字符串 &quot;saving configuration data    failed&quot; 进行初始化，以便通过 <code>operator&lt;&lt;()</code> 操作符向异常    <code>boost::exception</code> 中加入更多信息。 然后这个异常被相应的重新抛出。</p>
<p>现在，这个异常不仅包含有需要动态分配的内存大小，而且对于错误的描述被填入到    <code>save_configuration_data()</code> 函数中。    在调试时，这个描述显然很有帮助，因为可以很容易明白哪个函数试图分配更多的内存。</p>
<p>为了从一个异常中获取所有可用信息，可以像例子中那样在 <code>main()</code> 的    <code>catch</code> 句柄中使用函数    <code>boost::diagnostic_information()</code> 。 对于每个异常，函数    <code>boost::diagnostic_information()</code> 不仅调用    <code>what()</code> 而且获取所有附加信息存储到异常中。 返回一个可以在标准输出中写入的    <code>std::string</code> 字符串。</p>
<p>以上程序通过Visual C++ 2008编译会显示如下的信息：</p>
<pre><code class="language-c++">Throw in function (unknown)
Dynamic exception type: class allocation_failed
std::exception::what: allocation of 2000 bytes failed
[struct tag_errmsg *] = saving configuration data failed
</code></pre>
<p>正如我们所看见的，数据包含了异常的数据类型，通过 <code>what()</code>    方法获取到错误信息，以及包括相应结构体名的描述。</p>
<p><code>boost::diagnostic_information()</code>    函数在运行时检查一个给定的异常是否派生于 <code>std::exception</code>。 只会在派生于    <code>std::exception</code> 的条件下调用    <code>what()</code> 方法。</p>
<p>抛出异常类型 <code>allocation_failed</code>    的函数名会被指定为&quot;unknown&quot;(未知)信息。</p>
<p>Boost.Exception 提供了一个用以抛出异常的宏，它包含了函数名，以及如文件名、行数的附加信息。</p>
<pre><code class="language-c++">#include &lt;boost/exception/all.hpp&gt; 
#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;boost/shared_array.hpp&gt; 
#include &lt;exception&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; 

class allocation_failed : 
  public std::exception 
{ 
public: 
  allocation_failed(std::size_t size) 
    : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;) 
  { 
  } 

  virtual const char *what() const throw() 
  { 
    return what_.c_str(); 
  } 

private: 
  std::string what_; 
}; 

boost::shared_array&lt;char&gt; allocate(std::size_t size) 
{ 
  if (size &gt; 1000) 
    BOOST_THROW_EXCEPTION(allocation_failed(size)); 
  return boost::shared_array&lt;char&gt;(new char[size]); 
} 

void save_configuration_data() 
{ 
  try 
  { 
    boost::shared_array&lt;char&gt; a = allocate(2000); 
    // saving configuration data ... 
  } 
  catch (boost::exception &amp;e) 
  { 
    e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;); 
    throw; 
  } 
} 

int main() 
{ 
  try 
  { 
    save_configuration_data(); 
  } 
  catch (boost::exception &amp;e) 
  { 
    std::cerr &lt;&lt; boost::diagnostic_information(e); 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/15.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>通过使用宏 <code>BOOST_THROW_EXCEPTION</code> 替代 <code>throw</code>，    如函数名、文件名、行数之类的附加信息将自动被添加到异常中。但这仅仅在编译器支持宏的情况下有效。 当通过C++标准定义    <code>__FILE__</code> 和 <code>__LINE__</code> 之类的宏时，没有用于返回当前函数名的标准化的宏。    由于许多编译器制造商提供这样的宏， <code>BOOST_THROW_EXCEPTION</code> 试图识别当前编译器，从而利用相对应的宏。    使用 Visual C++ 2008 编译时，以上应用程序显示以下信息：</p>
<pre><code class="language-c++">.\main.cpp(31): Throw in function class boost::shared_array&lt;char&gt; __cdecl allocate(unsigned int)
Dynamic exception type: class boost::exception_detail::clone_impl&lt;struct boost::exception_detail::error_info_injector&lt;class allocation_failed&gt; &gt;
std::exception::what: allocation of 2000 bytes failed
[struct tag_errmsg *] = saving configuration data failed
</code></pre>
<p>即使 <code>allocation_failed</code> 类不再派生于    <code>boost::exception</code> 代码的编译也不会产生错误。    <code>BOOST_THROW_EXCEPTION</code> 获取到一个能够动态识别是否派生于    <code>boost::exception</code> 的函数    <code>boost::enable_error_info()</code>。 如果不是，他将自动建立一个派生于特定类和    <code>boost::exception</code> 的新异常类型。    这个机制使得以上信息中不仅仅显示内存分配异常 <code>allocation_failed</code>    。</p>
<p>最后，这个部分包含了一个例子，它选择性的获取了添加到异常中的信息。</p>
<pre><code class="language-c++">#include &lt;boost/exception/all.hpp&gt; 
#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;boost/shared_array.hpp&gt; 
#include &lt;exception&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; 

class allocation_failed : 
  public std::exception 
{ 
public: 
  allocation_failed(std::size_t size) 
    : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;) 
  { 
  } 

  virtual const char *what() const throw() 
  { 
    return what_.c_str(); 
  } 

private: 
  std::string what_; 
}; 

boost::shared_array&lt;char&gt; allocate(std::size_t size) 
{ 
  if (size &gt; 1000) 
    BOOST_THROW_EXCEPTION(allocation_failed(size)); 
  return boost::shared_array&lt;char&gt;(new char[size]); 
} 

void save_configuration_data() 
{ 
  try 
  { 
    boost::shared_array&lt;char&gt; a = allocate(2000); 
    // saving configuration data ... 
  } 
  catch (boost::exception &amp;e) 
  { 
    e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;); 
    throw; 
  } 
} 

int main() 
{ 
  try 
  { 
    save_configuration_data(); 
  } 
  catch (boost::exception &amp;e) 
  { 
    std::cerr &lt;&lt; *boost::get_error_info&lt;errmsg_info&gt;(e); 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/15.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子并没有使用函数 <code>boost::diagnostic_information()</code> 而是使用    <code>boost::get_error_info()</code> 函数来直接获取错误信息的类型    <code>errmsg_info</code>。 函数    <code>boost::get_error_info()</code> 用于返回    <code>boost::shared_ptr</code> 类型的智能指针。 如果传递的参数不是    <code>boost::exception</code> 类型的，返回的值将是相应的空指针。 如果    <code>BOOST_THROW_EXCEPTION</code> 宏总是被用来抛出异常，派生于    <code>boost::exception</code>    的异常是可以得到保障的——在这些情况下没有必要去检查返回的智能指针是否为空。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-16-章-类型转换操作符"><a class="header" href="#第-16-章-类型转换操作符">第 16 章 类型转换操作符</a></h1>
<h2 id="161-概述"><a class="header" href="#161-概述">16.1. 概述</a></h2>
<p>C++标准定义了四种类型转换操作符: <code>static_cast</code>,    <code>dynamic_cast</code>, <code>const_cast</code> 和    <code>reinterpret_cast</code>。 Boost.Conversion 和 Boost.NumericConversion    这两个库特别为某些类型转换定义了额外的类型转换操作符。</p>
<hr />
<h2 id="162-boostconversion"><a class="header" href="#162-boostconversion">16.2. Boost.Conversion</a></h2>
<p><a href="http://www.boost.org/libs/conversion/">Boost.Conversion</a>    库由两个文件组成。分别在 <code>boost/cast.hpp</code> 文件中定义了    <code>boost::polymorphic_cast</code> 和    <code>boost::polymorphic_downcast</code> 这两个类型转换操作符, 在 <code>boost/lexical_cast.hpp</code> 文件中定义了    <code>boost::lexical_cast</code>。</p>
<p><code>boost::polymorphic_cast</code> 和    <code>boost::polymorphic_downcast</code> 是为了使原来用 <code>dynamic_cast</code>    实现的类型转换更加具体。具体细节，如下例所示。</p>
<pre><code class="language-c++">struct father 
{ 
  virtual ~father() { }; 
}; 

struct mother 
{ 
  virtual ~mother() { }; 
}; 

struct child : 
  public father, 
  public mother 
{ 
}; 

void func(father *f) 
{ 
  child *c = dynamic_cast&lt;child*&gt;(f); 
} 

int main() 
{ 
  child *c = new child; 
  func(c); 

  father *f = new child; 
  mother *m = dynamic_cast&lt;mother*&gt;(f); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/16.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>本例使用 <code>dynamic_cast</code> 类型转换操作符两次: 在    <code>func()</code> 函数中，它将指向父类的指针转换为指向子类的指针。在    <code>main()</code> 中,    它将一个指向父类的指针转为指向另一个父类的指针。第一个转换称为向下转换(downcast)，第二个转换称为交叉转换(cross    cast)。</p>
<p>通过使用 Boost.Conversion 的类型转换操作符，可以将向下转换和交叉转换区分开来。</p>
<pre><code class="language-c++">#include &lt;boost/cast.hpp&gt; 

struct father 
{ 
  virtual ~father() { }; 
}; 

struct mother 
{ 
  virtual ~mother() { }; 
}; 

struct child : 
  public father, 
  public mother 
{ 
}; 

void func(father *f) 
{ 
  child *c = boost::polymorphic_downcast&lt;child*&gt;(f); 
} 

int main() 
{ 
  child *c = new child; 
  func(c); 

  father *f = new child; 
  mother *m = boost::polymorphic_cast&lt;mother*&gt;(f); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/16.2.2/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::polymorphic_downcast</code> 类型转换操作符只能用于向下转换。 它内部使用    <code>static_cast</code> 实现类型转换。 由于 <code>static_cast</code>    并不动态检查类型转换是否合法，所以 <code>boost::polymorphic_downcast</code>    应该只在类型转换是安全的情况下使用。 在调试(debug builds)模式下,    <code>boost::polymorphic_downcast</code> 实际上在 <code>assert    ()</code>函数中使用<code> dynamic_cast</code> 验证类型转换是否合法。    请注意这种合法性检测只在定义了<code>NDEBUG</code>宏的情况下执行，这通常是在调试模式下。</p>
<p>向下转换最好使用 <code>boost::polymorphic_downcast</code>, 那么    <code>boost::polymorphic_cast</code> 就是交叉转换所需要的了。 由于    <code>dynamic_cast</code>    是唯一能实现交叉转换的类型转换操作符，<code>boost::polymorphic_cast</code> 内部使用了它。 由于    <code>boost::polymorphic_cast</code> 能够在错误的时候抛出    <code>std::bad_cast</code>    类型的异常，所以优先使用这个类型转换操作符还是很有必要的。相反，<code>dynamic_cast</code> 在类型转换失败使将返回0。    避免手工验证返回值，<code>boost::polymorphic_cast</code> 提供了自动化的替代方式。</p>
<p><code>boost::polymorphic_downcast</code> 和    <code>boost::polymorphic_cast</code> 只在指针必须转换的时候使用；否则，必须使用    <code>dynamic_cast</code> 执行转换。 由于    <code>boost::polymorphic_downcast</code> 是基于    <code>static_cast</code>，所以它不能够，比如说，将父类对象转换为子类对象。 如果转换的类型不是指针，则使用    <code>boost::polymorphic_cast</code> 执行类型转换也没有什么意义，而在这种情况下使用    <code>dynamic_cast</code> 还会抛出一个    <code>std::bad_cast</code> 异常。</p>
<p>虽然所有的类型转换都可用 <code>dynamic_cast</code> 实现，可    <code>boost::polymorphic_downcast</code> 和    <code>boost::polymorphic_cast</code> 也不是真正随意使用的。 Boost.Conversion    还提供了另外一种在实践中很有用的类型转换操作符。 体会一下下面的例子。</p>
<pre><code class="language-c++">#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::string s = boost::lexical_cast&lt;std::string&gt;(169); 
  std::cout &lt;&lt; s &lt;&lt; std::endl; 
  double d = boost::lexical_cast&lt;double&gt;(s); 
  std::cout &lt;&lt; d &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/16.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>类型转换操作符 <code>boost::lexical_cast</code> 可将数字转换为其他类型。    例子首先将整数169转换为字符串，然后将字符串转换为浮点数。</p>
<p><code>boost::lexical_cast</code> 内部使用流(streams)执行转换操作。 因此，只有那些重载了    <code>operator&lt;&lt;()</code> 和    <code>operator&gt;&gt;()</code> 这两个操作符的类型可以转换。 使用    <code>boost::lexical_cast</code> 的优点是类型转换出现在一行代码之内，无需手工操作流(streams)。    由于流的用法对于类型转换不能立刻理解代码含义, 而 <code>boost::lexical_cast</code>    类型转换操作符还可以使代码更有意义，更加容易理解。</p>
<p>请注意 <code>boost::lexical_cast</code>    并不总是访问流(streams)；它自己也优化了一些数据类型的转换。</p>
<p>如果转换失败，则抛出 <code>boost::bad_lexical_cast</code>    类型的异常，它继承自 <code>std::bad_cast</code>。</p>
<pre><code class="language-c++">#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    int i = boost::lexical_cast&lt;int&gt;(&quot;abc&quot;); 
    std::cout &lt;&lt; i &lt;&lt; std::endl; 
  } 
  catch (boost::bad_lexical_cast &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/16.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>本例由于字符串 &quot;abc&quot; 不能转换为 <code>int</code> 类型的数字而抛出异常。</p>
<hr />
<h2 id="163-boostnumericconversion"><a class="header" href="#163-boostnumericconversion">16.3. Boost.NumericConversion</a></h2>
<p><a href="http://www.boost.org/libs/numeric/conversion/">Boost.NumericConversion</a>    可将一种数值类型转换为不同的数值类型。 在C++里, 这种转换可以隐式地发生，如下面例所示。</p>
<pre><code class="language-c++">#include &lt;iostream&gt; 

int main() 
{ 
  int i = 0x10000; 
  short s = i; 
  std::cout &lt;&lt; s &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/16.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>由于从 <code>int</code> 到 <code>short</code> 的类型转换自动产生，所以本例编译没有错误。    虽然本例可以运行，但结果由于依赖具体的编译器实现而结果无法预期。 数字<code>0x10000</code>对于变量    i 来说太大而不能存储在 <code>short</code> 类型的变量中。    依据C++标准，这个操作的结果是实现定义的(&quot;implementation defined&quot;)。 用Visual C++    2008编译，应用程序显示的是<code>0</code>。 s    的值当然不同于 i 的值。</p>
<p>为避免这种数值转换错误，可以使用 <code>boost::numeric_cast</code>    类型转换操作符。</p>
<pre><code class="language-c++">#include &lt;boost/numeric/conversion/cast.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    int i = 0x10000; 
    short s = boost::numeric_cast&lt;short&gt;(i); 
    std::cout &lt;&lt; s &lt;&lt; std::endl; 
  } 
  catch (boost::numeric::bad_numeric_cast &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/16.3.2/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::numeric_cast</code> 的用法与C++类型转换操作符非常相似。 当然需要包含正确的头文件；就是    <code>boost/numeric/conversion/cast.hpp</code>。</p>
<p><code>boost::numeric_cast</code> 执行与C++相同的隐式转换操作。    但是，<code>boost::numeric_cast</code> 验证了在不改变数值的情况下转换是否能够发生。    前面给的应用例子，转换不能发生，因而由于<code>0x10000</code>太大而不能存储在 <code>short</code>    类型的变量上，而抛出 <code>boost::numeric::bad_numeric_cast</code>    异常。</p>
<p>严格来讲，抛出的是    <code>boost::numeric::positive_overflow</code>    类型的异常，这个类型特指所谓的溢出(overflow) - 在此例中是正数。 相应地，还存在着    <code>boost::numeric::negative_overflow</code>    类型的异常，它特指负数的溢出。</p>
<pre><code class="language-c++">#include &lt;boost/numeric/conversion/cast.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    int i = -0x10000; 
    short s = boost::numeric_cast&lt;short&gt;(i); 
    std::cout &lt;&lt; s &lt;&lt; std::endl; 
  } 
  catch (boost::numeric::negative_overflow &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/16.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.NumericConversion 还定义了其他的异常类型，都继承自    <code>boost::numeric::bad_numeric_cast</code>。 因为    <code>boost::numeric::bad_numeric_cast</code> 继承自    <code>std::bad_cast</code>，所以 <code>catch</code>    处理也可以捕获这个类型的异常。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
