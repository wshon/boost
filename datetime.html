<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 10 章 日期与时间 - Boost C++ 库</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="frontpage.html"><strong aria-hidden="true">1.</strong> 导言</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">2.</strong> 第 1 章 简介</a></li><li class="chapter-item expanded "><a href="smartpointers.html"><strong aria-hidden="true">3.</strong> 第 2 章 智能指针</a></li><li class="chapter-item expanded "><a href="functionobjects.html"><strong aria-hidden="true">4.</strong> 第 3 章 函数对象</a></li><li class="chapter-item expanded "><a href="eventhandling.html"><strong aria-hidden="true">5.</strong> 第 4 章 事件处理</a></li><li class="chapter-item expanded "><a href="stringhandling.html"><strong aria-hidden="true">6.</strong> 第 5 章 字符串处理</a></li><li class="chapter-item expanded "><a href="multithreading.html"><strong aria-hidden="true">7.</strong> 第 6 章 多线程</a></li><li class="chapter-item expanded "><a href="asio.html"><strong aria-hidden="true">8.</strong> 第 7 章 异步输入输出</a></li><li class="chapter-item expanded "><a href="interprocesscommunication.html"><strong aria-hidden="true">9.</strong> 第 8 章 进程间通讯</a></li><li class="chapter-item expanded "><a href="filesystem.html"><strong aria-hidden="true">10.</strong> 第 9 章 文件系统</a></li><li class="chapter-item expanded "><a href="datetime.html" class="active"><strong aria-hidden="true">11.</strong> 第 10 章 日期与时间</a></li><li class="chapter-item expanded "><a href="serialization.html"><strong aria-hidden="true">12.</strong> 第 11 章 序列化</a></li><li class="chapter-item expanded "><a href="parser.html"><strong aria-hidden="true">13.</strong> 第 12 章 词法分析器</a></li><li class="chapter-item expanded "><a href="containers.html"><strong aria-hidden="true">14.</strong> 第 13 章 容器</a></li><li class="chapter-item expanded "><a href="datastructures.html"><strong aria-hidden="true">15.</strong> 第 14 章 数据结构</a></li><li class="chapter-item expanded "><a href="errorhandling.html"><strong aria-hidden="true">16.</strong> 第 15 章 错误处理</a></li><li class="chapter-item expanded "><a href="castoperators.html"><strong aria-hidden="true">17.</strong> 第 16 章 类型转换操作符</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Boost C++ 库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-10-章-日期与时间"><a class="header" href="#第-10-章-日期与时间">第 10 章 日期与时间</a></h1>
<h2 id="101-概述"><a class="header" href="#101-概述">10.1. 概述</a></h2>
<p>库 <a href="http://www.boost.org/libs/date_time/">Boost.DateTime</a>    可用于处理时间数据，如历法日期和时间。 另外，Boost.DateTime 还提供了扩展来处理时区的问题，且支持历法日期和时间的格式化输入与输出。    本章将覆盖 Boost.DateTime 的各个部分。</p>
<hr />
<h2 id="102-历法日期"><a class="header" href="#102-历法日期">10.2. 历法日期</a></h2>
<p>Boost.DateTime 只支持基于格里历的历法日期，这通常不成问题，因为这是最广泛使用的历法。    如果你与其它国家的某人有个会议，时间在2010年1月5日，你可以期望无需与对方确认这个日期是否基于格里历。</p>
<p>格里历是教皇 Gregory XIII 在1582年颁发的。 严格来说，Boost.DateTime    支持由1400年至9999年的历法日期，这意味着它支持1582年以前的日期。 因此，Boost.DateTime    可用于任一历法日期，只要该日期在转换为格里历后是在1400年之后。 如果需要更早的年份，就必须使用其它库来代替。</p>
<p>用于处理历法日期的类和函数位于名字空间 <code>boost::gregorian</code> 中，定义于 <code>boost/date_time/gregorian/gregorian.hpp</code>。    要创建一个日期，请使用 <code>boost::gregorian::date</code> 类。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d(2010, 1, 30); 
  std::cout &lt;&lt; d.year() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.month() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.day() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.day_of_week() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.end_of_month() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::gregorian::date</code> 提供了多个构造函数来进行日期的创建。    最基本的构造函数接受一个年份、一个月份和一个日期作为参数。 如果给定的是一个无效值，则将分别抛出    <code>boost::gregorian::bad_year</code>,    <code>boost::gregorian::bad_month</code> 或    <code>boost::gregorian::bad_day_of_month</code>    类型的异常，这些异常均派生自 <code>std::out_of_range</code>。</p>
<p>正如在这个例子中所示的， 有多个方法用于访问一个日期。 象 <code>year()</code>,    <code>month()</code> 和 <code>day()</code>    这些方法访问用于初始化的初始值，象 <code>day_of_week()</code> 和    <code>end_of_month()</code> 这些方法则访问计算得到的值。</p>
<p>而 <code>boost::gregorian::date</code>    的构造函数则接受年份、月份和日期的值来设定一个日期，调用 <code>month()</code> 方法实际上会显示    <code>Jan</code>，而调用    <code>day_of_week()</code> 则显示    <code>Sat</code>。 它们不是普通的数字值，而分别是    <code>boost::gregorian::date::month_type</code> 和    <code>boost::gregorian::date::day_of_week_type</code> 类型的值。    不过，Boost.DateTime 为格式化的输入输出提供了全面的支持，可以将以上输出从    <code>Jan</code> 调整为    <code>1</code>。</p>
<p>请留意，<code>boost::gregorian::date</code> 的缺省构造函数会创建一个无效的日期。    这样的无效日期也可以通过将 <code>boost::date_time::not_a_date_time</code>    作为单一参数传递给构造函数来显式地创建。</p>
<p>除了直接调用构造函数，也可以通过自由函数或其它对象的方法来创建一个    <code>boost::gregorian::date</code> 类型的对象。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d = boost::gregorian::day_clock::universal_day(); 
  std::cout &lt;&lt; d.year() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.month() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.day() &lt;&lt; std::endl; 

  d = boost::gregorian::date_from_iso_string(&quot;20100131&quot;); 
  std::cout &lt;&lt; d.year() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.month() &lt;&lt; std::endl; 
  std::cout &lt;&lt; d.day() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子使用了 <code>boost::gregorian::day_clock</code>    类，它是一个返回当前日期的时钟类。 方法 <code>universal_day()</code> 返回一个与时区及夏时制无关的    UTC 日期。 UTC 是世界时(universal time)的国际缩写。    <code>boost::gregorian::day_clock</code> 还提供了另一个方法    <code>local_day()</code>，它接受本地设置。 要取出本地时区的当前日期，必须使用    <code>local_day()</code>。</p>
<p>名字空间 <code>boost::gregorian</code> 中包含了许多其它自由函数，将保存在字符串中的日期转换为    <code>boost::gregorian::date</code> 类型的对象。 这个例子实际上是通过    <code>boost::gregorian::date_from_iso_string()</code> 函数对一个以 ISO    8601 格式给出的日期进行转换。 还有其它相类似的函数，如    <code>boost::gregorian::from_simple_string()</code> 和    <code>boost::gregorian::from_us_string()</code>。</p>
<p><code>boost::gregorian::date</code> 表示的是一个特定的时间点，而    <code>boost::gregorian::date_duration</code> 则表示了一段时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d1(2008, 1, 31); 
  boost::gregorian::date d2(2008, 8, 31); 
  boost::gregorian::date_duration dd = d2 - d1; 
  std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>由于 <code>boost::gregorian::date</code> 重载了    <code>operator-()</code> 操作符，所以两个时间点可以如上所示那样相减。 返回值的类型为    <code>boost::gregorian::date_duration</code>，表示了两个日期之间的时间长度。</p>
<p><code>boost::gregorian::date_duration</code> 所提供的最重要的方法是    <code>days()</code>，它返回一段时间内所包含的天数。</p>
<p>我们也可以通过传递一个天数作为构造函数的唯一参数，来显式创建    <code>boost::gregorian::date_duration</code> 类型的对象。    要创建涉及星期数、月份数或年数的时间段，可以相应使用 <code>boost::gregorian::weeks</code>,    <code>boost::gregorian::months</code> 和    <code>boost::gregorian::years</code>。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date_duration dd(4); 
  std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; 
  boost::gregorian::weeks ws(4); 
  std::cout &lt;&lt; ws.days() &lt;&lt; std::endl; 
  boost::gregorian::months ms(4); 
  std::cout &lt;&lt; ms.number_of_months() &lt;&lt; std::endl; 
  boost::gregorian::years ys(4); 
  std::cout &lt;&lt; ys.number_of_years() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.4/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::gregorian::months</code> 和    <code>boost::gregorian::years</code> 都无法确定其天数，因为某月或某年所含天数是可长的。    不过，这些类的用法还是可以从以下例子中看出。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d(2009, 1, 31); 
  boost::gregorian::months ms(1); 
  boost::gregorian::date d2 = d + ms; 
  std::cout &lt;&lt; d2 &lt;&lt; std::endl; 
  boost::gregorian::date d3 = d2 - ms; 
  std::cout &lt;&lt; d3 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>该程序将一个月加到给定的日期 January 31, 2009 上，得到 d2，其为    February 28, 2009。 接着，再减回一个月得到 d3，又重新变回 January 31,    2009。 如上所示，时间点和时间长度可用于计算。 不过，需要考虑具体的情况。    例如，从某月的最后一天开始计算，<code>boost::gregorian::months</code>    总是会到达另一个月的最后一天，如果反复前后跳，就可能得到令人惊讶的结果。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d(2009, 1, 30); 
  boost::gregorian::months ms(1); 
  boost::gregorian::date d2 = d + ms; 
  std::cout &lt;&lt; d2 &lt;&lt; std::endl; 
  boost::gregorian::date d3 = d2 - ms; 
  std::cout &lt;&lt; d3 &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.6/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子与前一个例子的不同之处在于，初始的日期是 January 30, 2009。 虽然这不是 January    的最后一天，但是向前跳一个月后得到的 d2 还是 February 28, 2009，因为没有    February 30 这一天。 不过，当我们再往回跳一个月，这次得到的 d3 就变成 January 31,    2009! 因为 February 28, 2009 是当月的最后一天，往回跳实际上是返回到 January 的最后一天。</p>
<p>如果你觉得这种行为过于混乱，可以通过取消    <code>BOOST_DATE_TIME_OPTIONAL_GREGORIAN_TYPES</code> 宏的定义来改变这种行为。    取消该宏后，<code>boost::gregorian::weeks</code>,    <code>boost::gregorian::months</code> 和    <code>boost::gregorian::years</code> 类都不再可用。 唯一剩下的类是    <code>boost::gregorian::date_duration</code>，只能指定前向或后向的跳过的天数，这样就不会再有意外的结果了。</p>
<p><code>boost::gregorian::date_duration</code> 表示的是时间长度，而    <code>boost::gregorian::date_period</code>    则提供了对两个日期之间区间的支持。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d1(2009, 1, 30); 
  boost::gregorian::date d2(2009, 10, 31); 
  boost::gregorian::date_period dp(d1, d2); 
  boost::gregorian::date_duration dd = dp.length(); 
  std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.7/main.cpp">下载源代码</a></li>
</ul>
<p>两个类型为 <code>boost::gregorian::date</code>    的参数指定了开始和结束的日期，它们被传递给 <code>boost::gregorian::date_period</code>    的构造函数。 此外，也可以指定一个开始日期和一个类型为    <code>boost::gregorian::date_duration</code> 的时间长度。    请注意，结束日期的前一天才是这个时间区间的最后一天，这对于理解以下例子的输出非常重要。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d1(2009, 1, 30); 
  boost::gregorian::date d2(2009, 10, 31); 
  boost::gregorian::date_period dp(d1, d2); 
  std::cout &lt;&lt; dp.contains(d1) &lt;&lt; std::endl; 
  std::cout &lt;&lt; dp.contains(d2) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.8/main.cpp">下载源代码</a></li>
</ul>
<p>这个程序用 <code>contains()</code> 方法来检查某个给定的日期是否包含在时间区间内。 虽然    d1 和 d2 都是被传递给    <code>boost::gregorian::date_period</code> 的构造函数的，但是    <code>contains()</code> 仅对第一个返回 <code>true</code>。    因为结束日期不是区间的一部分，所以以 d2 调用    <code>contains()</code> 会返回 <code>false</code>。</p>
<p><code>boost::gregorian::date_period</code>    还提供了其它方法，如移动一个区间，或计算两个重叠区间的交集。</p>
<p>除了日期类、时间长度类和时间区间类，Boost.DateTime 还提供了迭代器和其它有用的自由函数，如下例所示。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::gregorian::date d(2009, 1, 5); 
  boost::gregorian::day_iterator it(d); 
  std::cout &lt;&lt; *++it &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::date_time::next_weekday(*it, boost::gregorian::greg_weekday(boost::date_time::Friday)) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.2.9/main.cpp">下载源代码</a></li>
</ul>
<p>为了从一个指定日期向前或向后一天一天地跳，可以使用迭代器    <code>boost::gregorian::day_iterator</code>。 还有    <code>boost::gregorian::week_iterator</code>,    <code>boost::gregorian::month_iterator</code> 和    <code>boost::gregorian::year_iterator</code>    分别提供了按周、按月或是按年跳的迭代器。</p>
<p>这个例子还使用了    <code>boost::date_time::next_weekday()</code>，它基于一个给定的日期返回下一个星期几的日期。    以下程序将显示 <code>2009-Jan-09</code>，因为它是 January 6, 2009    之的第一个Friday。</p>
<hr />
<h2 id="103-位置无关的时间"><a class="header" href="#103-位置无关的时间">10.3. 位置无关的时间</a></h2>
<p><code>boost::gregorian::date</code>    用于创建日期，<code>boost::posix_time::ptime</code> 则用于定义一个位置无关的时间。    <code>boost::posix_time::ptime</code> 会存取    <code>boost::gregorian::date</code> 且额外保存一个时间。</p>
<p>为了使用 <code>boost::posix_time::ptime</code>，必须包含头文件    <code>boost/date_time/posix_time/posix_time.hpp</code>。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0)); 
  boost::gregorian::date d = pt.date(); 
  std::cout &lt;&lt; d &lt;&lt; std::endl; 
  boost::posix_time::time_duration td = pt.time_of_day(); 
  std::cout &lt;&lt; td &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>要初始化一个 <code>boost::posix_time::ptime</code> 类型的对象，要把一个类型为    <code>boost::gregorian::date</code> 的日期和一个类型为    <code>boost::posix_time::time_duration</code>    的时间长度作为第一和第二参数传递给构造函数。 传给    <code>boost::posix_time::time_duration</code> 构造函数的三个参数决定了时间点。    以上程序指定的时间点是 January 5, 2009 的 12 PM。</p>
<p>要查询日期和时间，可以使用 <code>date()</code> 和    <code>time_of_day()</code> 方法。</p>
<p>象 <code>boost::gregorian::date</code>    的缺省构造函数会创建一个无效日期一样，如果使用缺省构造函数，<code>boost::posix_time::ptime</code>    类型的对象也是无效的。 也可以通过传递一个 <code>boost::date_time::not_a_date_time</code>    给构造函数来显式创建一个无效时间。</p>
<p>和使用自由函数或其它对象的方法来创建 <code>boost::gregorian::date</code>    类型的历法日期一样，Boost.DateTime 也提供了相应的自由函数和对象来创建时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt = boost::posix_time::second_clock::universal_time(); 
  std::cout &lt;&lt; pt.date() &lt;&lt; std::endl; 
  std::cout &lt;&lt; pt.time_of_day() &lt;&lt; std::endl; 

  pt = boost::posix_time::from_iso_string(&quot;20090105T120000&quot;); 
  std::cout &lt;&lt; pt.date() &lt;&lt; std::endl; 
  std::cout &lt;&lt; pt.time_of_day() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>类 <code>boost::posix_time::second_clock</code>    表示一个返回当前时间的时钟。 <code>universal_time()</code> 方法返回 UTC 时间，如上例所示。    如果需要本地时间，则必须使用 <code>local_time()</code>。</p>
<p>Boost.DateTime 还提供了一个名为    <code>boost::posix_time::microsec_clock</code>    的类，它返回包含微秒在内的当前时间，供需要更高精度时使用。</p>
<p>要将一个保存在字符串中的时间点转换为类型为    <code>boost::posix_time::ptime</code> 的对象，可以用    <code>boost::posix_time::from_iso_string()</code> 这样的自由函数，它要求传入的时间点以    ISO 8601 格式提供。</p>
<p>除了 <code>boost::posix_time::ptime</code>, Boost.DateTime    也提供了 <code>boost::posix_time::time_duration</code> 类，用于指定一个时间长度。    这个类前面已经提到过，因为 <code>boost::posix_time::ptime</code> 的构造函数实际上需要一个    <code>boost::posix_time::time_duration</code> 类型的对象作为其第二个参数。    当然，<code>boost::posix_time::time_duration</code> 也可以单独使用。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::time_duration td(16, 30, 0); 
  std::cout &lt;&lt; td.hours() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.minutes() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.seconds() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.total_seconds() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>hours()</code>, <code>minutes()</code> 和    <code>seconds()</code> 均返回传给构造函数的各个值，而象    <code>total_seconds()</code>    这样的方法则返回总的秒数，以简单的方式为你提供额外的信息。</p>
<p>可以传递任意值给    <code>boost::posix_time::time_duration</code>，因为没有象24小时这样的上限存在。</p>
<p>和历法日期一样，时间点与时间长度也可以执行运算。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0)); 
  boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(18, 30, 0)); 
  boost::posix_time::time_duration td = pt2 - pt1; 
  std::cout &lt;&lt; td.hours() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.minutes() &lt;&lt; std::endl; 
  std::cout &lt;&lt; td.seconds() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.4/main.cpp">下载源代码</a></li>
</ul>
<p>如果两个 <code>boost::posix_time::ptime</code> 类型的时间点相减，结果将是一个    <code>boost::posix_time::time_duration</code>    类型的对象，给出两个时间点之间的时间长度。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0)); 
  boost::posix_time::time_duration td(6, 30, 0); 
  boost::posix_time::ptime pt2 = pt1 + td; 
  std::cout &lt;&lt; pt2.time_of_day() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>正如这个例子所示，时间长度可以被增加至一个时间点上，以得到一个新的时间点。 以上程序将打印    <code>18:30:00</code> 到标准输出流。</p>
<p>你可能已经留意到，Boost.DateTime 对于历法日期和时间使用了相同的概念。    就象有时间类和时间长度类一样，也有一个时间区间的类。 对于历法日期，这个类是    <code>boost::gregorian::date_period</code>; 对于时间则是    <code>boost::posix_time::time_period</code>。 这两个类均要求传入两个参数给构造函数：    <code>boost::gregorian::date_period</code> 要求两个历法日期，而    <code>boost::posix_time::time_period</code> 则要求两个时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0)); 
  boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(18, 30, 0)); 
  boost::posix_time::time_period tp(pt1, pt2); 
  std::cout &lt;&lt; tp.contains(pt1) &lt;&lt; std::endl; 
  std::cout &lt;&lt; tp.contains(pt2) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.6/main.cpp">下载源代码</a></li>
</ul>
<p>大致上说，<code>boost::posix_time::time_period</code> 非常象    <code>boost::gregorian::date_period</code>。 它提供了一个名为    <code>contains()</code> 的方法，对于位于该时间区间内的每一个时间点，它返回    <code>true</code>。 由于传给    <code>boost::posix_time::time_period</code>    的构造函数的结束时间不是时间区间的一部分，所以上例中第二个 <code>contains()</code> 调用将返回    <code>false</code>。</p>
<p><code>boost::posix_time::time_period</code> 还提供了其它方法，如    <code>intersection()</code> 和 <code>merge()</code>    分别用于计算两个重叠时间区间的交集，以及合并两个相交区间。</p>
<p>最后，迭代器 <code>boost::posix_time::time_iterator</code>    用于对时间点进行迭代。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/local_time/local_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0)); 
  boost::posix_time::time_iterator it(pt, boost::posix_time::time_duration(6, 30, 0)); 
  std::cout &lt;&lt; *++it &lt;&lt; std::endl; 
  std::cout &lt;&lt; *++it &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.3.7/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序使用了迭代器 it 从时间点 pt    开始向前跳6.5个小时 。 由于迭代器被递增两次，所以相应的输出分别为 <code>2009-Jan-05    18:30:00</code> 和 <code>2009-Jan-06    01:00:00</code>。</p>
<hr />
<h2 id="104-位置相关的时间"><a class="header" href="#104-位置相关的时间">10.4. 位置相关的时间</a></h2>
<p>和前一节所介绍的位置无关时间不一样，位置相关时间是要考虑时区的。 为此，Boost.DateTime 提供了    <code>boost::local_time::local_date_time</code> 类，它定义于 <code>boost/date_time/local_time/local_time.hpp</code>,    并使用 <code>boost::local_time::posix_time_zone</code>    来保存时区信息。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/local_time/local_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+1&quot;)); 
  boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0)); 
  boost::local_time::local_date_time dt(pt, tz); 
  std::cout &lt;&lt; dt.utc_time() &lt;&lt; std::endl; 
  std::cout &lt;&lt; dt &lt;&lt; std::endl; 
  std::cout &lt;&lt; dt.local_time() &lt;&lt; std::endl; 
  std::cout &lt;&lt; dt.zone_name() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.4.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::local_time::local_date_time</code> 的构造函数要求一个    <code>boost::posix_time::ptime</code> 类型的对象作为其第一个参数，以及一个    <code>boost::local_time::time_zone_ptr</code> 类型的对象作为第二个参数。 后者只不过是    <code>boost::shared_ptr&lt;boost::local_time::posix_time_zone&gt;</code>    的类型定义。 换句话说，并不是传递一个    <code>boost::local_time::posix_time_zone</code>    对象，而是传递一个指向该对象的智能指针。 这样，多个    <code>boost::local_time::local_date_time</code> 类型的对象就可以共享时区信息。    只有当最后一个对象被销毁时，相应的表示时区的对象才会被自动释放。</p>
<p>要创建一个 <code>boost::local_time::posix_time_zone</code>    类型的对象，就要将一个描述该时区的字符串作为单一参数传递给构造函数。 以上例子指定了欧洲中部时区：CET 是欧洲中部时间(Central    European Time)的缩写。 由于 CET 比 UTC 早一个小时，所以时差以 +1 表示。 Boost.DateTime    并不能解释时区的缩写，也就不知道 CET 的意思。 所以，必须以小时数给出时差；传入 +0 表示没有时差。</p>
<p>在执行时，该程序将打印 <code>2009-Jan-05 12:00:00</code>,    <code>2009-Jan-05 13:00:00 CET</code>,    <code>2009-Jan-05 13:00:00</code> 和    <code>CET</code> 到标准输出流。 用以初始化    <code>boost::posix_time::ptime</code> 和    <code>boost::local_time::local_date_time</code> 类型的值缺省总是与 UTC    时区相关的。 只有当一个 <code>boost::local_time::local_date_time</code>    类型的对象被写出至标准输出流时，或者调用 <code>local_time()</code>    方法时，才使用时差来计算本地时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/local_time/local_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+1&quot;)); 
  boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0)); 
  boost::local_time::local_date_time dt(pt, tz); 
  std::cout &lt;&lt; dt.local_time() &lt;&lt; std::endl; 
  boost::local_time::time_zone_ptr tz2(new boost::local_time::posix_time_zone(&quot;EET+2&quot;)); 
  std::cout &lt;&lt; dt.local_time_in(tz2).local_time() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>通过使用 <code>local_time()</code> 方法，时区的偏差才被考虑进来。 为了计算 CET    时间，需要往保存在 dt 中的 UTC 时间 12 PM 上加一个小时，因为 CET 比 UTC 早一个小时。    <code>local_time()</code> 会相应地输出 <code>2009-Jan-05    13:00:00</code> 到标准输出流。</p>
<p>相比之下，<code>local_time_in()</code> 方法是在所传入参数的时区内解释保存在    dt 中的时间。 这意味着 12 PM UTC 相当于 2 PM EET，即东部欧洲时间，它比 UTC    早两个小时。</p>
<p>最后，Boost.DateTime 通过    <code>boost::local_time::local_time_period</code>    类提供了位置相关的时间区间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/local_time/local_time.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+0&quot;)); 
  boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0)); 
  boost::local_time::local_date_time dt1(pt1, tz); 
  boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(18, 0, 0)); 
  boost::local_time::local_date_time dt2(pt2, tz); 
  boost::local_time::local_time_period tp(dt1, dt2); 
  std::cout &lt;&lt; tp.contains(dt1) &lt;&lt; std::endl; 
  std::cout &lt;&lt; tp.contains(dt2) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.4.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::local_time::local_time_period</code>    的构造函数要求两个类型为 <code>boost::local_time::local_date_time</code>    的参数。 和其它类型的时间区间一样，第二个参数所表示的结束时间并不包含在区间之内。 通过如    <code>contains()</code>, <code>intersection()</code>,    <code>merge()</code> 以及其它的方法，时间区间可以与其它    <code>boost::local_time::local_time_period</code> 相互操作。</p>
<hr />
<h2 id="105-格式化输入输出"><a class="header" href="#105-格式化输入输出">10.5. 格式化输入输出</a></h2>
<p>本章中的所有例子在执行后都提供形如 <code>2009-Jan-07</code>    这样的输出结果。 有的人可能更喜欢用其它格式来显示结果。 Boost.DateTime 允许    <code>boost::date_time::date_facet</code> 和    <code>boost::date_time::time_facet</code> 类来格式化历法日期和时间。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;locale&gt; 

int main() 
{ 
  boost::gregorian::date d(2009, 1, 7); 
  boost::gregorian::date_facet *df = new boost::gregorian::date_facet(&quot;%A, %d %B %Y&quot;); 
  std::cout.imbue(std::locale(std::cout.getloc(), df)); 
  std::cout &lt;&lt; d &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.5.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.DateTime 使用了 locales 的概念，它来自于 C++ 标准，在 <a href="./stringhandling.html">第 5 章 <em>字符串处理</em></a> 中有概括的介绍。 要格式化一个历法日期，必须创建一个    <code>boost::date_time::date_facet</code> 类型的对象并安装在一个 locale 内。    一个描述新格式的字符串被传递给 <code>boost::date_time::date_facet</code> 的构造函数。    上面的例子传递的是 <code>%A, %d %B %Y</code>，指定格式为：星期几后跟日月年全名：    <code>Wednesday, 07 January 2009</code>。</p>
<p>Boost.DateTime 提供了多个格式化标志，标志由一个百分号后跟一个字符组成。 Boost.DateTime    的文档中对于所支持的所有标志有一个完整的介绍。 例如，%A 表示星期几的全名。</p>
<p>如果应用程序的基本用户是位于德国或德语国家，最好可以用德语而不是英语来显示星期几和月份。</p>
<pre><code class="language-c++">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;locale&gt; 
#include &lt;string&gt; 
#include &lt;vector&gt; 

int main() 
{ 
  std::locale::global(std::locale(&quot;German&quot;)); 
  std::string months[12] = { &quot;Januar&quot;, &quot;Februar&quot;, &quot;März&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;, &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot; }; 
  std::string weekdays[7] = { &quot;Sonntag&quot;, &quot;Montag&quot;, &quot;Dienstag&quot;, &quot;Mittwoch&quot;, &quot;Donnerstag&quot;, &quot;Freitag&quot;, &quot;Samstag&quot; }; 
  boost::gregorian::date d(2009, 1, 7); 
  boost::gregorian::date_facet *df = new boost::gregorian::date_facet(&quot;%A, %d. %B %Y&quot;); 
  df-&gt;long_month_names(std::vector&lt;std::string&gt;(months, months + 12)); 
  df-&gt;long_weekday_names(std::vector&lt;std::string&gt;(weekdays, weekdays + 7)); 
  std::cout.imbue(std::locale(std::cout.getloc(), df)); 
  std::cout &lt;&lt; d &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/10.5.2/main.cpp">下载源代码</a></li>
</ul>
<p>星期几和月份的名字可以通过分别传入两个数组给    <code>boost::date_time::date_facet</code> 类的    <code>long_month_names()</code> 和    <code>long_weekday_names()</code> 方法来修改，这两个数组分别包含了相应的名字。    以上例子现在将打印 <code>Mittwoch, 07. Januar 2009</code>    到标准输出流。</p>
<p>Boost.DateTime 在格式化输入输出方面是非常灵活的。 除了输出类    <code>boost::date_time::date_facet</code> 和    <code>boost::date_time::time_facet</code> 以外，类    <code>boost::date_time::date_input_facet</code> 和    <code>boost::date_time::time_input_facet</code> 可用于格式化输入。    所有这四个类都提供了许多方法，来为 Boost.DateTime 所提供的各种不同对象配置输入和输出的方式。 例如，可以指定    <code>boost::gregorian::date_period</code> 类型的时间长度如何输入和输出。    要弄清楚各种格式化输入输出的可能性，请参考 Boost.DateTime 的文档。</p>
<hr />
<h2 id="106-练习"><a class="header" href="#106-练习">10.6. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>创建一个程序，打印下一个 Christmas Eve, Christmas Day        及其后一天是星期几到标准输出流。</li>
<li>以天数计算你的年龄。 该程序应该自动根据当前日期来计算。</li>
</ol>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="filesystem.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="serialization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="filesystem.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="serialization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
