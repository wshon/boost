<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 4 章 事件处理 - Boost C++ 库</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="frontpage.html"><strong aria-hidden="true">1.</strong> 导言</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">2.</strong> 第 1 章 简介</a></li><li class="chapter-item expanded "><a href="smartpointers.html"><strong aria-hidden="true">3.</strong> 第 2 章 智能指针</a></li><li class="chapter-item expanded "><a href="functionobjects.html"><strong aria-hidden="true">4.</strong> 第 3 章 函数对象</a></li><li class="chapter-item expanded "><a href="eventhandling.html" class="active"><strong aria-hidden="true">5.</strong> 第 4 章 事件处理</a></li><li class="chapter-item expanded "><a href="stringhandling.html"><strong aria-hidden="true">6.</strong> 第 5 章 字符串处理</a></li><li class="chapter-item expanded "><a href="multithreading.html"><strong aria-hidden="true">7.</strong> 第 6 章 多线程</a></li><li class="chapter-item expanded "><a href="asio.html"><strong aria-hidden="true">8.</strong> 第 7 章 异步输入输出</a></li><li class="chapter-item expanded "><a href="interprocesscommunication.html"><strong aria-hidden="true">9.</strong> 第 8 章 进程间通讯</a></li><li class="chapter-item expanded "><a href="filesystem.html"><strong aria-hidden="true">10.</strong> 第 9 章 文件系统</a></li><li class="chapter-item expanded "><a href="datetime.html"><strong aria-hidden="true">11.</strong> 第 10 章 日期与时间</a></li><li class="chapter-item expanded "><a href="serialization.html"><strong aria-hidden="true">12.</strong> 第 11 章 序列化</a></li><li class="chapter-item expanded "><a href="parser.html"><strong aria-hidden="true">13.</strong> 第 12 章 词法分析器</a></li><li class="chapter-item expanded "><a href="containers.html"><strong aria-hidden="true">14.</strong> 第 13 章 容器</a></li><li class="chapter-item expanded "><a href="datastructures.html"><strong aria-hidden="true">15.</strong> 第 14 章 数据结构</a></li><li class="chapter-item expanded "><a href="errorhandling.html"><strong aria-hidden="true">16.</strong> 第 15 章 错误处理</a></li><li class="chapter-item expanded "><a href="castoperators.html"><strong aria-hidden="true">17.</strong> 第 16 章 类型转换操作符</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Boost C++ 库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-4-章-事件处理"><a class="header" href="#第-4-章-事件处理">第 4 章 事件处理</a></h1>
<h2 id="41-概述"><a class="header" href="#41-概述">4.1. 概述</a></h2>
<p>很多开发者在听到术语'事件处理'时就会想到GUI：点击一下某个按钮，相关联的功能就会被执行。    点击本身就是事件，而功能就是相对应的事件处理器。</p>
<p>这一模式的使用当然不仅限于GUI。 一般情况下，任意对象都可以调用基于特定事件的专门函数。 本章所介绍的 <a href="http://www.boost.org/libs/signals">Boost.Signals</a>    库提供了一个简单的方法在 C++ 中应用这一模式。</p>
<p>严格来说，Boost.Function 库也可以用于事件处理。 不过，Boost.Function 和 Boost.Signals    之间的一个主要区别在于，Boost.Signals 能够将一个以上的事件处理器关联至单个事件。 因此，Boost.Signals    可以更好地支持事件驱动的开发，当需要进行事件处理时，应作为第一选择。</p>
<hr />
<h2 id="42-信号-signals"><a class="header" href="#42-信号-signals">4.2. 信号 Signals</a></h2>
<p>虽然这个库的名字乍一看好象有点误导，但实际上并非如此。 Boost.Signals 所实现的模式被命名为 '信号至插槽' (signal    to slot)，它基于以下概念：当对应的信号被发出时，相关联的插槽即被执行。 原则上，你可以把单词 '信号' 和 '插槽' 分别替换为 '事件'    和 '事件处理器'。 不过，由于信号可以在任意给定的时间发出，所以这一概念放弃了 '事件' 的名字。</p>
<p>因此，Boost.Signals 没有提供任何类似于 '事件' 的类。 相反，它提供了一个名为    <code>boost::signal</code> 的类，定义于 <code>boost/signal.hpp</code>.    实际上，这个头文件是唯一一个需要知道的，因为它会自动包含其它相关的头文件。</p>
<p>Boost.Signals 定义了其它一些类，位于 boost::signals 名字空间中。    由于 <code>boost::signal</code> 是最常被用到的类，所以它是位于名字空间    boost 中的。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(func); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::signal</code>    实际上被实现为一个模板函数，具有被用作为事件处理器的函数的签名，该签名也是它的模板参数。 在这个例子中，只有签名为 <code>void    ()</code> 的函数可以被成功关联至信号 s。</p>
<p>函数 <code>func()</code> 被通过 <code>connect()</code>    方法关联至信号 s。 由于 <code>func()</code> 符合所要求的    <code>void ()</code> 签名，所以该关联成功建立。因此当信号 s    被触发时，<code>func()</code> 将被调用。</p>
<p>信号是通过调用 s 来触发的，就象普通的函数调用那样。    这个函数的签名对应于作为模板参数传入的签名：因为 <code>void ()</code> 不要求任何参数，所以括号内是空的。</p>
<p>调用 s 会引发一个触发器，进而执行相应的 <code>func()</code>    函数 - 之前用 <code>connect()</code> 关联了的。</p>
<p>同一例子也可以用 Boost.Function 来实现。</p>
<pre><code class="language-c++">#include &lt;boost/function.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::function&lt;void ()&gt; f; 
  f = func; 
  f(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>和前一个例子相类似，<code>func()</code> 被关联至 f。 当    f 被调用时，就会相应地执行 <code>func()</code>。    Boost.Function 仅限于这种情形下适用，而 Boost.Signals    则提供了多得多的方式，如关联多个函数至单个特定信号，示例如下。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func1() 
{ 
  std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; 
} 

void func2() 
{ 
  std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::signal</code> 可以通过反复调用    <code>connect()</code> 方法来把多个函数赋值给单个特定信号。 当该信号被触发时，这些函数被按照之前用    <code>connect()</code> 进行关联时的顺序来执行。</p>
<p>另外，执行的顺序也可通过 <code>connect()</code>    方法的另一个重载版本来明确指定，该重载版本要求以一个 <code>int</code> 类型的值作为额外的参数。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func1() 
{ 
  std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; 
} 

void func2() 
{ 
  std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(1, func2); 
  s.connect(0, func1); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>和前一个例子一样，<code>func1()</code> 在 <code>func2()</code>    之前执行。</p>
<p>要释放某个函数与给定信号的关联，可以用 <code>disconnect()</code> 方法。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func1() 
{ 
  std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; 
} 

void func2() 
{ 
  std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  s.disconnect(func2); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子仅输出 <code>Hello</code>，因为与    <code>func2()</code> 的关联在触发信号之前已经被释放。</p>
<p>除了 <code>connect()</code> 和    <code>disconnect()</code>    以外，<code>boost::signal</code> 还提供了几个方法。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func1() 
{ 
  std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; 
} 

void func2() 
{ 
  std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl; 
  if (!s.empty()) 
    s(); 
  s.disconnect_all_slots(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.6/main.cpp">下载源代码</a></li>
</ul>
<p><code>num_slots()</code> 返回已关联函数的数量。如果没有函数被关联，则    <code>num_slots()</code> 返回0。 在这种特定情况下，可以用    <code>empty()</code> 方法来替代。    <code>disconnect_all_slots()</code>    方法所做的实际上正是它的名字所表达的：释放所有已有的关联。</p>
<p>看完了函数如何被关联至信号，以及弄明白了信号被触发时会发生什么事之后，还有一个问题：这些函数的返回值去了哪里？    以下例子回答了这个问题。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

int func1() 
{ 
  return 1; 
} 

int func2() 
{ 
  return 2; 
} 

int main() 
{ 
  boost::signal&lt;int ()&gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  std::cout &lt;&lt; s() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.7/main.cpp">下载源代码</a></li>
</ul>
<p><code>func1()</code> 和 <code>func2()</code> 都具有    <code>int</code> 类型的返回值。 s 将处理两个返回值，并将它们都写出至标准输出流。    那么，到底会发生什么呢？</p>
<p>以上例子实际上会把 <code>2</code> 写出至标准输出流。 两个返回值都被    s 正确接收，但除了最后一个值，其它值都会被忽略。    缺省情况下，所有被关联函数中，实际上只有最后一个返回值被返回。</p>
<p>你可以定制一个信号，令每个返回值都被相应地处理。 为此，要把一个称为合成器(combiner)的东西作为第二个参数传递给    <code>boost::signal</code>。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;algorithm&gt; 

int func1() 
{ 
  return 1; 
} 

int func2() 
{ 
  return 2; 
} 

template &lt;typename T&gt; 
struct min_element 
{ 
  typedef T result_type; 

  template &lt;typename InputIterator&gt; 
  T operator()(InputIterator first, InputIterator last) const 
  { 
    return *std::min_element(first, last); 
  } 
}; 

int main() 
{ 
  boost::signal&lt;int (), min_element&lt;int&gt; &gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  std::cout &lt;&lt; s() &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.8/main.cpp">下载源代码</a></li>
</ul>
<p>合成器是一个重载了 <code>operator()()</code>    操作符的类。这个操作符会被自动调用，传入两个迭代器，指向某个特定信号的所有返回值。 以上例子使用了标准 C++ 算法    <code>std::min_element()</code> 来确定并返回最小的值。</p>
<p>不幸的是，我们不可能把象 <code>std::min_element()</code> 这样的一个算法直接传给    <code>boost::signal</code> 作为一个模板参数。    <code>boost::signal</code> 要求这个合成器定义一个名为    <code>result_type</code> 的类型，用于说明 <code>operator()()</code>    操作符返回值的类型。 由于在标准 C++ 算法中缺少这个类型，所以在编译时会产生一个相应的错误。</p>
<p>除了对返回值进行分析以外，合成器也可以保存它们。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;algorithm&gt; 

int func1() 
{ 
  return 1; 
} 

int func2() 
{ 
  return 2; 
} 

template &lt;typename T&gt; 
struct min_element 
{ 
  typedef T result_type; 

  template &lt;typename InputIterator&gt; 
  T operator()(InputIterator first, InputIterator last) const 
  { 
    return T(first, last); 
  } 
}; 

int main() 
{ 
  boost::signal&lt;int (), min_element&lt;std::vector&lt;int&gt; &gt; &gt; s; 
  s.connect(func1); 
  s.connect(func2); 
  std::vector&lt;int&gt; v = s(); 
  std::cout &lt;&lt; *std::min_element(v.begin(), v.end()) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.2.9/main.cpp">下载源代码</a></li>
</ul>
<p>这个例子把所有返回值保存在一个 vector 中，再由 <code>s()</code> 返回。</p>
<hr />
<h2 id="43-连接-connections"><a class="header" href="#43-连接-connections">4.3. 连接 Connections</a></h2>
<p>函数可以通过由 <code>boost::signal</code> 所提供的    <code>connect()</code> 和 <code>disconnect()</code>    方法的帮助来进行管理。 由于 <code>connect()</code> 会返回一个类型为    <code>boost::signals::connection</code> 的值，它们可以通过其它方法来管理。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  boost::signals::connection c = s.connect(func); 
  s(); 
  c.disconnect(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.1/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::signal</code> 的    <code>disconnect()</code> 方法需要传入一个函数指针，而直接调用    <code>boost::signals::connection</code> 对象上的    <code>disconnect()</code> 方法则略去该参数。</p>
<p>除了 <code>disconnect()</code>    方法之外，<code>boost::signals::connection</code> 还提供了其它方法，如    <code>block()</code> 和 <code>unblock()</code>。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  boost::signals::connection c = s.connect(func); 
  c.block(); 
  s(); 
  c.unblock(); 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序只会执行一次 <code>func()</code>。 虽然信号 s    被触发了两次，但是在第一次触发时 <code>func()</code> 不会被调用，因为连接 c    实际上已经被 <code>block()</code> 调用所阻塞。 由于在第二次触发之前调用了    <code>unblock()</code>，所以之后 <code>func()</code>    被正确地执行。</p>
<p>除了 <code>boost::signals::connection</code> 以外，还有一个名为    <code>boost::signals::scoped_connection</code>    的类，它会在析构时自动释放连接。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;iostream&gt; 

void func() 
{ 
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
} 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  { 
    boost::signals::scoped_connection c = s.connect(func); 
  } 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>因为连接对象 c 在信号触发之前被销毁，所以 <code>func()</code>    不会被调用。</p>
<p><code>boost::signals::scoped_connection</code> 实际上是派生自    <code>boost::signals::connection</code>    的，所以它提供了相同的方法。它们之间的区别仅在于，在析构    <code>boost::signals::scoped_connection</code> 时，连接会自动释放。</p>
<p>虽然 <code>boost::signals::scoped_connection</code>    的确令自动释放连接更为容易，但是该类型的对象仍需要管理。 如果在其它情形下连接也可以被自动释放，而且不需要管理这些对象的话，就更好了。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;boost/bind.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;memory&gt; 

class world 
{ 
  public: 
    void hello() const 
    { 
      std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
    } 
}; 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  { 
    std::auto_ptr&lt;world&gt; w(new world()); 
    s.connect(boost::bind(&amp;world::hello, w.get())); 
  } 
  std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl; 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.4/main.cpp">下载源代码</a></li>
</ul>
<p>以上程序使用 Boost.Bind 将一个对象的方法关联至一个信号。 在信号触发之前，这个对象就被销毁了，这会产生问题。    我们不传递实际的对象 w，而只传递一个指针给    <code>boost::bind()</code>。 在 <code>s()</code>    被实际调用的时候，该指针所引向的对象已不再存在。</p>
<p>可以如下修改这个程序，使得一旦对象 w 被销毁，连接就会自动释放。</p>
<pre><code class="language-c++">#include &lt;boost/signal.hpp&gt; 
#include &lt;boost/bind.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;memory&gt; 

class world : 
  public boost::signals::trackable 
{ 
  public: 
    void hello() const 
    { 
      std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; 
    } 
}; 

int main() 
{ 
  boost::signal&lt;void ()&gt; s; 
  { 
    std::auto_ptr&lt;world&gt; w(new world()); 
    s.connect(boost::bind(&amp;world::hello, w.get())); 
  } 
  std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl; 
  s(); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/4.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>如果现在再执行，<code>num_slots()</code> 会返回    <code>0</code> 以确保不会试图调用已销毁对象之上的方法。 仅需的修改是让    <code>world</code> 类继承自    <code>boost::signals::trackable</code>。    当使用对象的指针而不是对象的副本来关联函数至信号时，<code>boost::signals::trackable</code>    可以显著简化连接的管理。</p>
<hr />
<h2 id="44-练习"><a class="header" href="#44-练习">4.4. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>
<p>编写一个程序，定义一个名为 <code>button</code> 的类，表示GUI中的一个可点击按钮。        为该类加入两个方法 <code>add_handler()</code> 和        <code>remove_handler()</code>，它们均要求一个函数名作为参数。 如果        <code>click()</code> 方法被调用，已登记的函数将被按顺序执行。</p>
<p>如下测试你的代码，创建一个 <code>button</code>        类的实例，从事件处理器内部向标准输出流写出一个信息。 调用 <code>click()</code>        函数模拟用鼠标点击该按钮。</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="functionobjects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="stringhandling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="functionobjects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="stringhandling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
