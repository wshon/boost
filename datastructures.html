<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 14 章 数据结构 - Boost C++ 库</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="frontpage.html"><strong aria-hidden="true">1.</strong> 导言</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">2.</strong> 第 1 章 简介</a></li><li class="chapter-item expanded "><a href="smartpointers.html"><strong aria-hidden="true">3.</strong> 第 2 章 智能指针</a></li><li class="chapter-item expanded "><a href="functionobjects.html"><strong aria-hidden="true">4.</strong> 第 3 章 函数对象</a></li><li class="chapter-item expanded "><a href="eventhandling.html"><strong aria-hidden="true">5.</strong> 第 4 章 事件处理</a></li><li class="chapter-item expanded "><a href="stringhandling.html"><strong aria-hidden="true">6.</strong> 第 5 章 字符串处理</a></li><li class="chapter-item expanded "><a href="multithreading.html"><strong aria-hidden="true">7.</strong> 第 6 章 多线程</a></li><li class="chapter-item expanded "><a href="asio.html"><strong aria-hidden="true">8.</strong> 第 7 章 异步输入输出</a></li><li class="chapter-item expanded "><a href="interprocesscommunication.html"><strong aria-hidden="true">9.</strong> 第 8 章 进程间通讯</a></li><li class="chapter-item expanded "><a href="filesystem.html"><strong aria-hidden="true">10.</strong> 第 9 章 文件系统</a></li><li class="chapter-item expanded "><a href="datetime.html"><strong aria-hidden="true">11.</strong> 第 10 章 日期与时间</a></li><li class="chapter-item expanded "><a href="serialization.html"><strong aria-hidden="true">12.</strong> 第 11 章 序列化</a></li><li class="chapter-item expanded "><a href="parser.html"><strong aria-hidden="true">13.</strong> 第 12 章 词法分析器</a></li><li class="chapter-item expanded "><a href="containers.html"><strong aria-hidden="true">14.</strong> 第 13 章 容器</a></li><li class="chapter-item expanded "><a href="datastructures.html" class="active"><strong aria-hidden="true">15.</strong> 第 14 章 数据结构</a></li><li class="chapter-item expanded "><a href="errorhandling.html"><strong aria-hidden="true">16.</strong> 第 15 章 错误处理</a></li><li class="chapter-item expanded "><a href="castoperators.html"><strong aria-hidden="true">17.</strong> 第 16 章 类型转换操作符</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Boost C++ 库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-14-章-数据结构"><a class="header" href="#第-14-章-数据结构">第 14 章 数据结构</a></h1>
<h2 id="141-概述"><a class="header" href="#141-概述">14.1. 概述</a></h2>
<p>在 Boost C++ 库中， 把一些类型定义为container显得不太合适， 所以就并没有放在 <a href="./containers.html">第 13 章 <em>容器</em></a> 里。 而把他们放在本章就比较合适了。 举例来说， <code>boost::tuple</code> 就扩展了 C++ 的数据类型 <code>std::pair</code> 用以储存多个而不只是两个值。 </p>
<p>除了 <code>boost::tuple</code>， 这一章还涵盖了类  <code>boost::any</code> 和 <code>boost::variant</code> 以储存那些不确定类型的值。 其中 <code>boost::any</code> 类型的变量使用起来就像弱类型语言中的变量一样灵活。 另一方面， <code>boost::variant</code> 类型的变量可以储存一些预定义的数据类型， 就像我们用 <code>union</code> 时候一样。</p>
<hr />
<h2 id="142-元组"><a class="header" href="#142-元组">14.2. 元组</a></h2>
<p><a href="http://www.boost.org/libs/tuple/">Boost.Tuple</a> 库提供了一个更一般的版本的 <code>std::pair</code> ——  <code>boost::tuple</code> 。 不过 <code>std::pair</code> 只能储存两个值而已, <code>boost::tuple</code> 则给了我们更多的选择。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string&gt; person; 
  person p(&quot;Boris&quot;, &quot;Schaeling&quot;); 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.1/main.cpp">下载源代码</a></li>
</ul>
<p>为了使用 <code>boost::tuple</code>， 你必须要包含头文件： <code>boost/tuple/tuple.hpp</code> 。 若想要让元组和流一起使用， 你还需要包含头文件：   <code>boost/tuple/tuple_io.hpp</code> 才行。 </p>
<p>其实， <code>boost::tuple</code> 的用法基本上和  <code>std::pair</code> 一样。 就像我们在上面的例子里看到的那样， 两个值类型的 <code>std::string</code> 通过两个相应的模板参数存储在了元组里。 </p>
<p>当然 <code>person</code> 类型也可以用 <code>std::pair</code> 来实现。 所有  <code>boost::tuple</code> 类型的对象都可以被写入流里。 再次强调， 为了使用流操作和各种流操作运算符， 你必须要包含头文件： <code>boost/tuple/tuple_io.hpp</code> 。 显然，我们的例子会输出： <code>(Boris Schaeling)</code> 。</p>
<p><code>boost::tuple</code> 和 <code>std::pair</code> 之间最重要的一点不同点： 元组可以存储无限多个值！ </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string, int&gt; person; 
  person p(&quot;Boris&quot;, &quot;Schaeling&quot;, 43); 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.2/main.cpp">下载源代码</a></li>
</ul>
<p>我们修改了实例， 现在的元组里不仅储存了一个人的firstname和lastname， 还加上了他的鞋子的尺码。 现在， 我们的例子将会输出：  <code>(Boris Schaeling 43)</code> 。</p>
<p>就像 <code>std::pair</code> 有辅助函数 <code>std::make_pair()</code> 一样， 一个元组也可以用它的辅助函数 <code>boost::make_tuple()</code> 来创建。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::cout &lt;&lt; boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.3/main.cpp">下载源代码</a></li>
</ul>
<p>就像下面的例子所演示的那样， 一个元组也可以存储引用类型的值。 </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  std::string s = &quot;Boris&quot;; 
  std::cout &lt;&lt; boost::make_tuple(boost::ref(s), &quot;Schaeling&quot;, 43) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.4/main.cpp">下载源代码</a></li>
</ul>
<p>因为 &quot;Schaeling&quot; 和 43 是按值传递的，所以就直接存储在了元组中。  与他们不同的是： person 的第一个元素是一个指向 s 的引用。 Boost.Ref 中的  <code>boost::ref()</code> 就是用来创建这样的引用的。 相对的， 要创建一个常量的引用的时候， 你需要使用 <code>boost::cref()</code> 。</p>
<p>在学习了创建元组的方法之后， 让我们来了解一下访问元组中元素的方式。 <code>std::pair</code> 只包含两个元素， 故可以使用属性 first 和 second 来访问其中的元素。 但元组可以包含无限多个元素， 显然， 我们需要用另一种方式来解决访问的问题。 </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string, int&gt; person; 
  person p = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43); 
  std::cout &lt;&lt; p.get&lt;0&gt;() &lt;&lt; std::endl; 
  std::cout &lt;&lt; boost::get&lt;0&gt;(p) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.5/main.cpp">下载源代码</a></li>
</ul>
<p>我们可以用两种方式来访问元组中的元素： 使用成员函数  <code>get()</code> ， 或者将元组传给一个独立的函数  <code>boost::get()</code> 。 使用这两种方式时， 元素的索引值都是通过模板参数来指定的。 例子中就分别使用了这两种方式来访问  p 中的第一个元素。 因此， <code>Boris</code> 会被输出两次。 </p>
<p>另外， 对于索引值合法性的检查会在编译期执行， 故访问非法的索引值会引起编译期错误而不是运行时的错误。</p>
<p>对于元组中元素的修改， 你同样可以使用   <code>get()</code> 和 <code>boost::get()</code> 函数。 </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string, int&gt; person; 
  person p = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43); 
  p.get&lt;1&gt;() = &quot;Becker&quot;; 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.6/main.cpp">下载源代码</a></li>
</ul>
<p><code>get()</code> 和 <code>boost::get()</code> 都会返回一个引用值。 例子中修改了 lastname 之后将会输出： <code>(Boris Becker 43)</code> 。</p>
<p>Boost.Tuple 除了重载了流操作运算符以外， 还为我们提供了比较运算符。 为了使用它们， 你必须要包含相应的头文件： <code>boost/tuple/tuple_comparison.hpp</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_comparison.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string, std::string, int&gt; person; 
  person p1 = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43); 
  person p2 = boost::make_tuple(&quot;Boris&quot;, &quot;Becker&quot;, 43); 
  std::cout &lt;&lt; (p1 != p2) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.7/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子将会输出 <code>1</code> 因为两个元组  p1 和 p2 是不同的。</p>
<p>同时， 头文件 <code>boost/tuple/tuple_comparison.hpp</code> 还定义了一些其他的比较操作， 比如用来做字典序比较的大于操作等。 </p>
<p>Boost.Tuple 还提供了一种叫做 Tier 的特殊元组。 Tier 的特殊之处在于它包含的所有元素都是引用类型的。 它可以通过构造函数  <code>boost::tie()</code> 来创建。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string&amp;, std::string&amp;, int&amp;&gt; person; 

  std::string firstname = &quot;Boris&quot;; 
  std::string surname = &quot;Schaeling&quot;; 
  int shoesize = 43; 
  person p = boost::tie(firstname, surname, shoesize); 
  surname = &quot;Becker&quot;; 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.8/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子创建了一个 tier p， 他包含了三个分别指向 firstname， surname 和 shoesize 的引用值。 在修改变量  surname 的同时， tier 也会跟着改变。 </p>
<p>就像下面的例子展示的那样，你当然可以用  <code>boost::make_tuple()</code> 和 <code>boost::ref()</code> 来代替构造函数  <code>boost::tie()</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;boost/tuple/tuple_io.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  typedef boost::tuple&lt;std::string&amp;, std::string&amp;, int&amp;&gt; person; 

  std::string firstname = &quot;Boris&quot;; 
  std::string surname = &quot;Schaeling&quot;; 
  int shoesize = 43; 
  person p = boost::make_tuple(boost::ref(firstname), boost::ref(surname), boost::ref(shoesize)); 
  surname = &quot;Becker&quot;; 
  std::cout &lt;&lt; p &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.9/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::tie()</code> 在一定程度上简化了语法， 同时， 也可以用作“拆箱”元组。 在接下来的这个例子里， 元组中的各个元素就被很方便的“拆箱”并直接赋给了其他变量。 </p>
<pre><code class="language-c++">#include &lt;boost/tuple/tuple.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

boost::tuple&lt;std::string, int&gt; func() 
{ 
  return boost::make_tuple(&quot;Error message&quot;, 2009); 
}

int main() 
{ 
  std::string errmsg; 
  int errcode; 

  boost::tie(errmsg, errcode) = func(); 
  std::cout &lt;&lt; errmsg &lt;&lt; &quot;: &quot; &lt;&lt; errcode &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.2.10/main.cpp">下载源代码</a></li>
</ul>
<p>通过使用 <code>boost::tie()</code> ， 元组中的元素：字符串“Error massage”和错误代码“2009”就很方便地经  <code>func()</code> 的返回值直接赋给了  errmsg 和 errcode 。</p>
<hr />
<h2 id="143-boostany"><a class="header" href="#143-boostany">14.3. Boost.Any</a></h2>
<p>像 C++ 这样的强类型语言要求给每个变量一个确定的类型。 而以 JavaScript 为代表的弱类型语言却不这样做， 弱类型的每个变量都可以存储数组、 布尔值、 或者是字符串。</p>
<p>库 <a href="http://www.boost.org/libs/any/">Boost.Any</a> 给我们提供了 <code>boost::any</code> 类， 让我们可以在 C++ 中像 JavaScript 一样的使用弱类型的变量。 </p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 

int main() 
{ 
  boost::any a = 1; 
  a = 3.14; 
  a = true; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.1/main.cpp">下载源代码</a></li>
</ul>
<p>为了使用 <code>boost::any</code>， 你必须要包含头文件：  <code>boost/any.hpp</code>。 接下来， 你就可以定义和使用 <code>boost::any</code> 的对象了。 </p>
<p>需要注明的是： <code>boost::any</code> 并不能真的存储任意类型的值； Boost.Any 需要一些特定的前提条件才能工作。 任何想要存储在 <code>boost::any</code> 中的值，都必须是可拷贝构造的。  因此，想要在 <code>boost::any</code> 存储一个字符串类型的值， 就必须要用到 <code>std::string</code> ， 就像在下面那个例子中做的一样。 </p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::any a = 1; 
  a = 3.14; 
  a = true; 
  a = std::string(&quot;Hello, world!&quot;); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.2/main.cpp">下载源代码</a></li>
</ul>
<p>如果你企图把字符串 &quot;Hello, world!&quot; 直接赋给 a ， 你的编译器就会报错， 因为由基类型 <code>char</code> 构成的字符串在 C++ 中并不是可拷贝构造的。 </p>
<p>想要访问 <code>boost::any</code> 中具体的内容， 你必须要使用转型操作： <code>boost::any_cast</code> 。</p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::any a = 1; 
  std::cout &lt;&lt; boost::any_cast&lt;int&gt;(a) &lt;&lt; std::endl; 
  a = 3.14; 
  std::cout &lt;&lt; boost::any_cast&lt;double&gt;(a) &lt;&lt; std::endl; 
  a = true; 
  std::cout &lt;&lt; boost::any_cast&lt;bool&gt;(a) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.3/main.cpp">下载源代码</a></li>
</ul>
<p>通过由模板参数传入 <code>boost::any_cast</code> 的值， 变量会被转化成相应的类型。 一旦你指定了一种非法的类型， 该操作会抛出  <code>boost::bad_any_cast</code> 类型的异常。</p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    boost::any a = 1; 
    std::cout &lt;&lt; boost::any_cast&lt;float&gt;(a) &lt;&lt; std::endl; 
  } 
  catch (boost::bad_any_cast &amp;e) 
  { 
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.4/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子就抛出了一个异常， 因为 <code>float</code> 并不能匹配原本存储在 a 中的 <code>int</code> 类型。 记住， 在任何情况下都保证 <code>boost::any</code> 中的类型匹配是很重要的。 在没有通过模板参数指定 <code>short</code> 或 <code>long</code>  类型时， 同样会有异常抛出。</p>
<p>既然 <code>boost::bad_any_cast</code> 继承自  <code>std::bad_cast</code>， <code>catch</code> 当然也可以捕获相应类型的异常。 </p>
<p>想要检查 <code>boost::any</code> 是否为空， 你可以使用  <code>empty()</code> 函数。 想要确定其中具体的类型信息， 你可以使用 <code>type()</code> 函数。</p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;typeinfo&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::any a = 1; 
  if (!a.empty()) 
  { 
    const std::type_info &amp;ti = a.type(); 
    std::cout &lt;&lt; ti.name() &lt;&lt; std::endl; 
  } 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.5/main.cpp">下载源代码</a></li>
</ul>
<p>上面的例子同时用到了 <code>empty()</code> 和 <code>type()</code> 函数。 <code>empty()</code> 将会返回一个布尔值， 而 <code>type()</code> 则会返回一个在 <code>typeinfo</code> 中定义的  <code>std::type_info</code> 值。</p>
<p>作为对这一节的总结， 最后一个例子会向你展示怎样用 <code>boost::any_cast</code> 来定义一个指向 <code>boost::any</code> 中内容的指针。</p>
<pre><code class="language-c++">#include &lt;boost/any.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::any a = 1; 
  int *i = boost::any_cast&lt;int&gt;(&amp;a); 
  std::cout &lt;&lt; *i &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.3.6/main.cpp">下载源代码</a></li>
</ul>
<p>你需要做的就是传递一个 <code>boost::any</code> 类型的指针， 作为 <code>boost::any_cast</code> 的参数； 模板参数却没有任何改动。</p>
<hr />
<h2 id="144-boostvariant"><a class="header" href="#144-boostvariant">14.4. Boost.Variant</a></h2>
<p><a href="http://www.boost.org/libs/variant/">Boost.Variant</a> 和 Boost.Any 之间的不同点在于 Boost.Any 可以被视为任意的类型， 而 Boost.Variant 只能被视为固定数量的类型。 让我们来看下面这个例子。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 

int main() 
{ 
  boost::variant&lt;double, char&gt; v; 
  v = 3.14; 
  v = 'A'; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.1/main.cpp">下载源代码</a></li>
</ul>
<p>Boost.Variant 为我们提供了一个定义在 <code>boost/variant.hpp</code> 中的类：  <code>boost::variant</code> 。 既然 <code>boost::variant</code> 是一个模板， 你必须要指定至少一个参数。 Variant 所存储的数据类型就由这些参数来指定。 上面的例子就给  v 指定了 <code>double</code> 类型和 <code>char</code> 类型。 注意， 一旦你将一个 <code>int</code> 值赋给了 v， 你的代码将不会编译通过。</p>
<p>当然， 上面的例子也可以用一个 <code>union</code> 类型来实现， 但是与 union 不同的是： <code>boost::variant</code> 可以储存像 <code>std::string</code>  这样的 class 类型的数据。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  v = 'A'; 
  v = &quot;Hello, world!&quot;; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.2/main.cpp">下载源代码</a></li>
</ul>
<p>要访问 v 中的数据， 你可以使用独立的  <code>boost::get()</code> 函数。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  std::cout &lt;&lt; boost::get&lt;double&gt;(v) &lt;&lt; std::endl; 
  v = 'A'; 
  std::cout &lt;&lt; boost::get&lt;char&gt;(v) &lt;&lt; std::endl; 
  v = &quot;Hello, world!&quot;; 
  std::cout &lt;&lt; boost::get&lt;std::string&gt;(v) &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.3/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::get()</code> 需要传入一个模板参数来指明你需要返回的数据类型。 若是指定了一个非法的类型， 你会遇到一个运行时而不是编译期的错误。</p>
<p>所有 <code>boost::variant</code> 类型的值都可以被直接写入标准输入流这样的流中， 这可以在一定程度上让你避开运行时错误的风险。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  std::cout &lt;&lt; v &lt;&lt; std::endl; 
  v = 'A'; 
  std::cout &lt;&lt; v &lt;&lt; std::endl; 
  v = &quot;Hello, world!&quot;; 
  std::cout &lt;&lt; v &lt;&lt; std::endl; 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.4/main.cpp">下载源代码</a></li>
</ul>
<p>想要分别处理各种不同类型的数据， Boost.Variant 为我们提供了一个名为 <code>boost::apply_visitor()</code> 的函数。</p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;boost/any.hpp&gt; 
#include &lt;vector&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

std::vector&lt;boost::any&gt; vector; 

struct output : 
  public boost::static_visitor&lt;&gt; 
{ 
  void operator()(double &amp;d) const 
  { 
    vector.push_back(d); 
  } 

  void operator()(char &amp;c) const 
  { 
    vector.push_back(c); 
  } 

  void operator()(std::string &amp;s) const 
  { 
    vector.push_back(s); 
  } 
}; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  boost::apply_visitor(output(), v); 
  v = 'A'; 
  boost::apply_visitor(output(), v); 
  v = &quot;Hello, world!&quot;; 
  boost::apply_visitor(output(), v); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.5/main.cpp">下载源代码</a></li>
</ul>
<p><code>boost::apply_visitor()</code> 第一个参数需要传入一个继承自 <code>boost::static_visitor</code> 类型的对象。 这个类必须要重载 <code>operator()()</code> 运算符来处理  <code>boost::variant</code> 每个可能的类型。 相应的， 例子中的  v 就重载了三次 operator() 来处理三种可能的类型：  <code>double</code>， <code>char</code> 和 <code>std::string</code>。</p>
<p>再仔细看代码， 不难发现 <code>boost::static_visitor</code> 是一个模板。 那么，当  <code>operator()()</code> 有返回值的时候， 就必须返回一个模板才行。 如果 operator() 像例子那样没有返回值时， 你就不需要模板了。</p>
<p><code>boost::apply_visitor()</code> 的第二个参数是一个  <code>boost::variant</code> 类型的值。</p>
<p>在使用时， <code>boost::apply_visitor()</code> 会自动调用跟第二个参数匹配的 <code>operator()()</code> 。 示例程序中的  <code>boost::apply_visitor()</code> 就自动调用了三个不同的 operator 第一个是 <code>double</code> 类型的， 第二个是  <code>char</code> 最后一个是 <code>std::string</code>。</p>
<p><code>boost::apply_visitor()</code> 的优点不只是“自动调用匹配的函数”这一点。 更有用的是，  <code>boost::apply_visitor()</code> 会确认是否  <code>boost::variant</code> 中的每个可能值都定义了相应的函数。  如果你忘记重载了任何一个函数， 代码都不会编译通过。 </p>
<p>当然， 如果对每种类型的操作都是一样的， 你也可以像下面的示例一样使用一个模板来简化你的代码。 </p>
<pre><code class="language-c++">#include &lt;boost/variant.hpp&gt; 
#include &lt;boost/any.hpp&gt; 
#include &lt;vector&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

std::vector&lt;boost::any&gt; vector; 

struct output : 
  public boost::static_visitor&lt;&gt; 
{ 
  template &lt;typename T&gt; 
  void operator()(T &amp;t) const 
  { 
    vector.push_back(t); 
  } 
}; 

int main() 
{ 
  boost::variant&lt;double, char, std::string&gt; v; 
  v = 3.14; 
  boost::apply_visitor(output(), v); 
  v = 'A'; 
  boost::apply_visitor(output(), v); 
  v = &quot;Hello, world!&quot;; 
  boost::apply_visitor(output(), v); 
} 
</code></pre>
<ul>
<li><a href="http://zh.highscore.de/cpp/boost/src/14.4.6/main.cpp">下载源代码</a></li>
</ul>
<p>既然 <code>boost::apply_visitor()</code> 可以在编译期确定代码的正确性， 你就该更多的使用它而不是  <code>boost::get()</code>。</p>
<hr />
<h2 id="145-练习"><a class="header" href="#145-练习">14.5. 练习</a></h2>
<p>​              You can buy               <a href="http://en.highscore.de/shop/index.php?p=boost-solution">solutions to all exercises</a>              in this book as a ZIP file.</p>
<ol>
<li>自定义一种数据类型： <code>configuration</code>  它可以存储一个 name-value 对。 Name 为  <code>std::string</code> 类型， 而 value 可为 <code>std::string</code> 或者 <code>int</code> 或者  <code>float</code> 类型。 在 <code>main()</code> 函数里， 用 <code>configuration</code> 存储下列 name-value 对:  path=C:\Windows, version=3， pi=3.1415。 通过向便准输出流输出来验证你对数据类型的设计。 </li>
<li>在输出后， 将对象中的 path 修改为 C:\Windows\System。 再次向标准输出流输出以验证你的设计。</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="containers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="errorhandling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="containers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="errorhandling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
